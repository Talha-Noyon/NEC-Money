/*! jQuery v3.2.1 | (c) JS Foundation and other contributors | jquery.org/license */ ! function(a, b) {
    "use strict";
    "object" == typeof module && "object" == typeof module.exports ? module.exports = a.document ? b(a, !0) : function(a) {
        if (!a.document) throw new Error("jQuery requires a window with a document");
        return b(a)
    } : b(a)
}("undefined" != typeof window ? window : this, function(a, b) {
    "use strict";
    var c = [],
        d = a.document,
        e = Object.getPrototypeOf,
        f = c.slice,
        g = c.concat,
        h = c.push,
        i = c.indexOf,
        j = {},
        k = j.toString,
        l = j.hasOwnProperty,
        m = l.toString,
        n = m.call(Object),
        o = {};

    function p(a, b) {
        b = b || d;
        var c = b.createElement("script");
        c.text = a, b.head.appendChild(c).parentNode.removeChild(c)
    }
    var q = "3.2.1",
        r = function(a, b) {
            return new r.fn.init(a, b)
        },
        s = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,
        t = /^-ms-/,
        u = /-([a-z])/g,
        v = function(a, b) {
            return b.toUpperCase()
        };
    r.fn = r.prototype = {
        jquery: q,
        constructor: r,
        length: 0,
        toArray: function() {
            return f.call(this)
        },
        get: function(a) {
            return null == a ? f.call(this) : a < 0 ? this[a + this.length] : this[a]
        },
        pushStack: function(a) {
            var b = r.merge(this.constructor(), a);
            return b.prevObject = this, b
        },
        each: function(a) {
            return r.each(this, a)
        },
        map: function(a) {
            return this.pushStack(r.map(this, function(b, c) {
                return a.call(b, c, b)
            }))
        },
        slice: function() {
            return this.pushStack(f.apply(this, arguments))
        },
        first: function() {
            return this.eq(0)
        },
        last: function() {
            return this.eq(-1)
        },
        eq: function(a) {
            var b = this.length,
                c = +a + (a < 0 ? b : 0);
            return this.pushStack(c >= 0 && c < b ? [this[c]] : [])
        },
        end: function() {
            return this.prevObject || this.constructor()
        },
        push: h,
        sort: c.sort,
        splice: c.splice
    }, r.extend = r.fn.extend = function() {
        var a, b, c, d, e, f, g = arguments[0] || {},
            h = 1,
            i = arguments.length,
            j = !1;
        for ("boolean" == typeof g && (j = g, g = arguments[h] || {}, h++), "object" == typeof g || r.isFunction(g) || (g = {}), h === i && (g = this, h--); h < i; h++)
            if (null != (a = arguments[h]))
                for (b in a) c = g[b], d = a[b], g !== d && (j && d && (r.isPlainObject(d) || (e = Array.isArray(d))) ? (e ? (e = !1, f = c && Array.isArray(c) ? c : []) : f = c && r.isPlainObject(c) ? c : {}, g[b] = r.extend(j, f, d)) : void 0 !== d && (g[b] = d));
        return g
    }, r.extend({
        expando: "jQuery" + (q + Math.random()).replace(/\D/g, ""),
        isReady: !0,
        error: function(a) {
            throw new Error(a)
        },
        noop: function() {},
        isFunction: function(a) {
            return "function" === r.type(a)
        },
        isWindow: function(a) {
            return null != a && a === a.window
        },
        isNumeric: function(a) {
            var b = r.type(a);
            return ("number" === b || "string" === b) && !isNaN(a - parseFloat(a))
        },
        isPlainObject: function(a) {
            var b, c;
            return !(!a || "[object Object]" !== k.call(a)) && (!(b = e(a)) || (c = l.call(b, "constructor") && b.constructor, "function" == typeof c && m.call(c) === n))
        },
        isEmptyObject: function(a) {
            var b;
            for (b in a) return !1;
            return !0
        },
        type: function(a) {
            return null == a ? a + "" : "object" == typeof a || "function" == typeof a ? j[k.call(a)] || "object" : typeof a
        },
        globalEval: function(a) {
            p(a)
        },
        camelCase: function(a) {
            return a.replace(t, "ms-").replace(u, v)
        },
        each: function(a, b) {
            var c, d = 0;
            if (w(a)) {
                for (c = a.length; d < c; d++)
                    if (b.call(a[d], d, a[d]) === !1) break
            } else
                for (d in a)
                    if (b.call(a[d], d, a[d]) === !1) break;
            return a
        },
        trim: function(a) {
            return null == a ? "" : (a + "").replace(s, "")
        },
        makeArray: function(a, b) {
            var c = b || [];
            return null != a && (w(Object(a)) ? r.merge(c, "string" == typeof a ? [a] : a) : h.call(c, a)), c
        },
        inArray: function(a, b, c) {
            return null == b ? -1 : i.call(b, a, c)
        },
        merge: function(a, b) {
            for (var c = +b.length, d = 0, e = a.length; d < c; d++) a[e++] = b[d];
            return a.length = e, a
        },
        grep: function(a, b, c) {
            for (var d, e = [], f = 0, g = a.length, h = !c; f < g; f++) d = !b(a[f], f), d !== h && e.push(a[f]);
            return e
        },
        map: function(a, b, c) {
            var d, e, f = 0,
                h = [];
            if (w(a))
                for (d = a.length; f < d; f++) e = b(a[f], f, c), null != e && h.push(e);
            else
                for (f in a) e = b(a[f], f, c), null != e && h.push(e);
            return g.apply([], h)
        },
        guid: 1,
        proxy: function(a, b) {
            var c, d, e;
            if ("string" == typeof b && (c = a[b], b = a, a = c), r.isFunction(a)) return d = f.call(arguments, 2), e = function() {
                return a.apply(b || this, d.concat(f.call(arguments)))
            }, e.guid = a.guid = a.guid || r.guid++, e
        },
        now: Date.now,
        support: o
    }), "function" == typeof Symbol && (r.fn[Symbol.iterator] = c[Symbol.iterator]), r.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function(a, b) {
        j["[object " + b + "]"] = b.toLowerCase()
    });

    function w(a) {
        var b = !!a && "length" in a && a.length,
            c = r.type(a);
        return "function" !== c && !r.isWindow(a) && ("array" === c || 0 === b || "number" == typeof b && b > 0 && b - 1 in a)
    }
    var x = function(a) {
        var b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u = "sizzle" + 1 * new Date,
            v = a.document,
            w = 0,
            x = 0,
            y = ha(),
            z = ha(),
            A = ha(),
            B = function(a, b) {
                return a === b && (l = !0), 0
            },
            C = {}.hasOwnProperty,
            D = [],
            E = D.pop,
            F = D.push,
            G = D.push,
            H = D.slice,
            I = function(a, b) {
                for (var c = 0, d = a.length; c < d; c++)
                    if (a[c] === b) return c;
                return -1
            },
            J = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
            K = "[\\x20\\t\\r\\n\\f]",
            L = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",
            M = "\\[" + K + "*(" + L + ")(?:" + K + "*([*^$|!~]?=)" + K + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + L + "))|)" + K + "*\\]",
            N = ":(" + L + ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" + M + ")*)|.*)\\)|)",
            O = new RegExp(K + "+", "g"),
            P = new RegExp("^" + K + "+|((?:^|[^\\\\])(?:\\\\.)*)" + K + "+$", "g"),
            Q = new RegExp("^" + K + "*," + K + "*"),
            R = new RegExp("^" + K + "*([>+~]|" + K + ")" + K + "*"),
            S = new RegExp("=" + K + "*([^\\]'\"]*?)" + K + "*\\]", "g"),
            T = new RegExp(N),
            U = new RegExp("^" + L + "$"),
            V = {
                ID: new RegExp("^#(" + L + ")"),
                CLASS: new RegExp("^\\.(" + L + ")"),
                TAG: new RegExp("^(" + L + "|[*])"),
                ATTR: new RegExp("^" + M),
                PSEUDO: new RegExp("^" + N),
                CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + K + "*(even|odd|(([+-]|)(\\d*)n|)" + K + "*(?:([+-]|)" + K + "*(\\d+)|))" + K + "*\\)|)", "i"),
                bool: new RegExp("^(?:" + J + ")$", "i"),
                needsContext: new RegExp("^" + K + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + K + "*((?:-\\d)?\\d*)" + K + "*\\)|)(?=[^-]|$)", "i")
            },
            W = /^(?:input|select|textarea|button)$/i,
            X = /^h\d$/i,
            Y = /^[^{]+\{\s*\[native \w/,
            Z = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
            $ = /[+~]/,
            _ = new RegExp("\\\\([\\da-f]{1,6}" + K + "?|(" + K + ")|.)", "ig"),
            aa = function(a, b, c) {
                var d = "0x" + b - 65536;
                return d !== d || c ? b : d < 0 ? String.fromCharCode(d + 65536) : String.fromCharCode(d >> 10 | 55296, 1023 & d | 56320)
            },
            ba = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
            ca = function(a, b) {
                return b ? "\0" === a ? "\ufffd" : a.slice(0, -1) + "\\" + a.charCodeAt(a.length - 1).toString(16) + " " : "\\" + a
            },
            da = function() {
                m()
            },
            ea = ta(function(a) {
                return a.disabled === !0 && ("form" in a || "label" in a)
            }, {
                dir: "parentNode",
                next: "legend"
            });
        try {
            G.apply(D = H.call(v.childNodes), v.childNodes), D[v.childNodes.length].nodeType
        } catch (fa) {
            G = {
                apply: D.length ? function(a, b) {
                    F.apply(a, H.call(b))
                } : function(a, b) {
                    var c = a.length,
                        d = 0;
                    while (a[c++] = b[d++]);
                    a.length = c - 1
                }
            }
        }

        function ga(a, b, d, e) {
            var f, h, j, k, l, o, r, s = b && b.ownerDocument,
                w = b ? b.nodeType : 9;
            if (d = d || [], "string" != typeof a || !a || 1 !== w && 9 !== w && 11 !== w) return d;
            if (!e && ((b ? b.ownerDocument || b : v) !== n && m(b), b = b || n, p)) {
                if (11 !== w && (l = Z.exec(a)))
                    if (f = l[1]) {
                        if (9 === w) {
                            if (!(j = b.getElementById(f))) return d;
                            if (j.id === f) return d.push(j), d
                        } else if (s && (j = s.getElementById(f)) && t(b, j) && j.id === f) return d.push(j), d
                    } else {
                        if (l[2]) return G.apply(d, b.getElementsByTagName(a)), d;
                        if ((f = l[3]) && c.getElementsByClassName && b.getElementsByClassName) return G.apply(d, b.getElementsByClassName(f)), d
                    }
                if (c.qsa && !A[a + " "] && (!q || !q.test(a))) {
                    if (1 !== w) s = b, r = a;
                    else if ("object" !== b.nodeName.toLowerCase()) {
                        (k = b.getAttribute("id")) ? k = k.replace(ba, ca): b.setAttribute("id", k = u), o = g(a), h = o.length;
                        while (h--) o[h] = "#" + k + " " + sa(o[h]);
                        r = o.join(","), s = $.test(a) && qa(b.parentNode) || b
                    }
                    if (r) try {
                        return G.apply(d, s.querySelectorAll(r)), d
                    } catch (x) {} finally {
                        k === u && b.removeAttribute("id")
                    }
                }
            }
            return i(a.replace(P, "$1"), b, d, e)
        }

        function ha() {
            var a = [];

            function b(c, e) {
                return a.push(c + " ") > d.cacheLength && delete b[a.shift()], b[c + " "] = e
            }
            return b
        }

        function ia(a) {
            return a[u] = !0, a
        }

        function ja(a) {
            var b = n.createElement("fieldset");
            try {
                return !!a(b)
            } catch (c) {
                return !1
            } finally {
                b.parentNode && b.parentNode.removeChild(b), b = null
            }
        }

        function ka(a, b) {
            var c = a.split("|"),
                e = c.length;
            while (e--) d.attrHandle[c[e]] = b
        }

        function la(a, b) {
            var c = b && a,
                d = c && 1 === a.nodeType && 1 === b.nodeType && a.sourceIndex - b.sourceIndex;
            if (d) return d;
            if (c)
                while (c = c.nextSibling)
                    if (c === b) return -1;
            return a ? 1 : -1
        }

        function ma(a) {
            return function(b) {
                var c = b.nodeName.toLowerCase();
                return "input" === c && b.type === a
            }
        }

        function na(a) {
            return function(b) {
                var c = b.nodeName.toLowerCase();
                return ("input" === c || "button" === c) && b.type === a
            }
        }

        function oa(a) {
            return function(b) {
                return "form" in b ? b.parentNode && b.disabled === !1 ? "label" in b ? "label" in b.parentNode ? b.parentNode.disabled === a : b.disabled === a : b.isDisabled === a || b.isDisabled !== !a && ea(b) === a : b.disabled === a : "label" in b && b.disabled === a
            }
        }

        function pa(a) {
            return ia(function(b) {
                return b = +b, ia(function(c, d) {
                    var e, f = a([], c.length, b),
                        g = f.length;
                    while (g--) c[e = f[g]] && (c[e] = !(d[e] = c[e]))
                })
            })
        }

        function qa(a) {
            return a && "undefined" != typeof a.getElementsByTagName && a
        }
        c = ga.support = {}, f = ga.isXML = function(a) {
            var b = a && (a.ownerDocument || a).documentElement;
            return !!b && "HTML" !== b.nodeName
        }, m = ga.setDocument = function(a) {
            var b, e, g = a ? a.ownerDocument || a : v;
            return g !== n && 9 === g.nodeType && g.documentElement ? (n = g, o = n.documentElement, p = !f(n), v !== n && (e = n.defaultView) && e.top !== e && (e.addEventListener ? e.addEventListener("unload", da, !1) : e.attachEvent && e.attachEvent("onunload", da)), c.attributes = ja(function(a) {
                return a.className = "i", !a.getAttribute("className")
            }), c.getElementsByTagName = ja(function(a) {
                return a.appendChild(n.createComment("")), !a.getElementsByTagName("*").length
            }), c.getElementsByClassName = Y.test(n.getElementsByClassName), c.getById = ja(function(a) {
                return o.appendChild(a).id = u, !n.getElementsByName || !n.getElementsByName(u).length
            }), c.getById ? (d.filter.ID = function(a) {
                var b = a.replace(_, aa);
                return function(a) {
                    return a.getAttribute("id") === b
                }
            }, d.find.ID = function(a, b) {
                if ("undefined" != typeof b.getElementById && p) {
                    var c = b.getElementById(a);
                    return c ? [c] : []
                }
            }) : (d.filter.ID = function(a) {
                var b = a.replace(_, aa);
                return function(a) {
                    var c = "undefined" != typeof a.getAttributeNode && a.getAttributeNode("id");
                    return c && c.value === b
                }
            }, d.find.ID = function(a, b) {
                if ("undefined" != typeof b.getElementById && p) {
                    var c, d, e, f = b.getElementById(a);
                    if (f) {
                        if (c = f.getAttributeNode("id"), c && c.value === a) return [f];
                        e = b.getElementsByName(a), d = 0;
                        while (f = e[d++])
                            if (c = f.getAttributeNode("id"), c && c.value === a) return [f]
                    }
                    return []
                }
            }), d.find.TAG = c.getElementsByTagName ? function(a, b) {
                return "undefined" != typeof b.getElementsByTagName ? b.getElementsByTagName(a) : c.qsa ? b.querySelectorAll(a) : void 0
            } : function(a, b) {
                var c, d = [],
                    e = 0,
                    f = b.getElementsByTagName(a);
                if ("*" === a) {
                    while (c = f[e++]) 1 === c.nodeType && d.push(c);
                    return d
                }
                return f
            }, d.find.CLASS = c.getElementsByClassName && function(a, b) {
                if ("undefined" != typeof b.getElementsByClassName && p) return b.getElementsByClassName(a)
            }, r = [], q = [], (c.qsa = Y.test(n.querySelectorAll)) && (ja(function(a) {
                o.appendChild(a).innerHTML = "<a id='" + u + "'></a><select id='" + u + "-\r\\' msallowcapture=''><option selected=''></option></select>", a.querySelectorAll("[msallowcapture^='']").length && q.push("[*^$]=" + K + "*(?:''|\"\")"), a.querySelectorAll("[selected]").length || q.push("\\[" + K + "*(?:value|" + J + ")"), a.querySelectorAll("[id~=" + u + "-]").length || q.push("~="), a.querySelectorAll(":checked").length || q.push(":checked"), a.querySelectorAll("a#" + u + "+*").length || q.push(".#.+[+~]")
            }), ja(function(a) {
                a.innerHTML = "<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";
                var b = n.createElement("input");
                b.setAttribute("type", "hidden"), a.appendChild(b).setAttribute("name", "D"), a.querySelectorAll("[name=d]").length && q.push("name" + K + "*[*^$|!~]?="), 2 !== a.querySelectorAll(":enabled").length && q.push(":enabled", ":disabled"), o.appendChild(a).disabled = !0, 2 !== a.querySelectorAll(":disabled").length && q.push(":enabled", ":disabled"), a.querySelectorAll("*,:x"), q.push(",.*:")
            })), (c.matchesSelector = Y.test(s = o.matches || o.webkitMatchesSelector || o.mozMatchesSelector || o.oMatchesSelector || o.msMatchesSelector)) && ja(function(a) {
                c.disconnectedMatch = s.call(a, "*"), s.call(a, "[s!='']:x"), r.push("!=", N)
            }), q = q.length && new RegExp(q.join("|")), r = r.length && new RegExp(r.join("|")), b = Y.test(o.compareDocumentPosition), t = b || Y.test(o.contains) ? function(a, b) {
                var c = 9 === a.nodeType ? a.documentElement : a,
                    d = b && b.parentNode;
                return a === d || !(!d || 1 !== d.nodeType || !(c.contains ? c.contains(d) : a.compareDocumentPosition && 16 & a.compareDocumentPosition(d)))
            } : function(a, b) {
                if (b)
                    while (b = b.parentNode)
                        if (b === a) return !0;
                return !1
            }, B = b ? function(a, b) {
                if (a === b) return l = !0, 0;
                var d = !a.compareDocumentPosition - !b.compareDocumentPosition;
                return d ? d : (d = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1, 1 & d || !c.sortDetached && b.compareDocumentPosition(a) === d ? a === n || a.ownerDocument === v && t(v, a) ? -1 : b === n || b.ownerDocument === v && t(v, b) ? 1 : k ? I(k, a) - I(k, b) : 0 : 4 & d ? -1 : 1)
            } : function(a, b) {
                if (a === b) return l = !0, 0;
                var c, d = 0,
                    e = a.parentNode,
                    f = b.parentNode,
                    g = [a],
                    h = [b];
                if (!e || !f) return a === n ? -1 : b === n ? 1 : e ? -1 : f ? 1 : k ? I(k, a) - I(k, b) : 0;
                if (e === f) return la(a, b);
                c = a;
                while (c = c.parentNode) g.unshift(c);
                c = b;
                while (c = c.parentNode) h.unshift(c);
                while (g[d] === h[d]) d++;
                return d ? la(g[d], h[d]) : g[d] === v ? -1 : h[d] === v ? 1 : 0
            }, n) : n
        }, ga.matches = function(a, b) {
            return ga(a, null, null, b)
        }, ga.matchesSelector = function(a, b) {
            if ((a.ownerDocument || a) !== n && m(a), b = b.replace(S, "='$1']"), c.matchesSelector && p && !A[b + " "] && (!r || !r.test(b)) && (!q || !q.test(b))) try {
                var d = s.call(a, b);
                if (d || c.disconnectedMatch || a.document && 11 !== a.document.nodeType) return d
            } catch (e) {}
            return ga(b, n, null, [a]).length > 0
        }, ga.contains = function(a, b) {
            return (a.ownerDocument || a) !== n && m(a), t(a, b)
        }, ga.attr = function(a, b) {
            (a.ownerDocument || a) !== n && m(a);
            var e = d.attrHandle[b.toLowerCase()],
                f = e && C.call(d.attrHandle, b.toLowerCase()) ? e(a, b, !p) : void 0;
            return void 0 !== f ? f : c.attributes || !p ? a.getAttribute(b) : (f = a.getAttributeNode(b)) && f.specified ? f.value : null
        }, ga.escape = function(a) {
            return (a + "").replace(ba, ca)
        }, ga.error = function(a) {
            throw new Error("Syntax error, unrecognized expression: " + a)
        }, ga.uniqueSort = function(a) {
            var b, d = [],
                e = 0,
                f = 0;
            if (l = !c.detectDuplicates, k = !c.sortStable && a.slice(0), a.sort(B), l) {
                while (b = a[f++]) b === a[f] && (e = d.push(f));
                while (e--) a.splice(d[e], 1)
            }
            return k = null, a
        }, e = ga.getText = function(a) {
            var b, c = "",
                d = 0,
                f = a.nodeType;
            if (f) {
                if (1 === f || 9 === f || 11 === f) {
                    if ("string" == typeof a.textContent) return a.textContent;
                    for (a = a.firstChild; a; a = a.nextSibling) c += e(a)
                } else if (3 === f || 4 === f) return a.nodeValue
            } else
                while (b = a[d++]) c += e(b);
            return c
        }, d = ga.selectors = {
            cacheLength: 50,
            createPseudo: ia,
            match: V,
            attrHandle: {},
            find: {},
            relative: {
                ">": {
                    dir: "parentNode",
                    first: !0
                },
                " ": {
                    dir: "parentNode"
                },
                "+": {
                    dir: "previousSibling",
                    first: !0
                },
                "~": {
                    dir: "previousSibling"
                }
            },
            preFilter: {
                ATTR: function(a) {
                    return a[1] = a[1].replace(_, aa), a[3] = (a[3] || a[4] || a[5] || "").replace(_, aa), "~=" === a[2] && (a[3] = " " + a[3] + " "), a.slice(0, 4)
                },
                CHILD: function(a) {
                    return a[1] = a[1].toLowerCase(), "nth" === a[1].slice(0, 3) ? (a[3] || ga.error(a[0]), a[4] = +(a[4] ? a[5] + (a[6] || 1) : 2 * ("even" === a[3] || "odd" === a[3])), a[5] = +(a[7] + a[8] || "odd" === a[3])) : a[3] && ga.error(a[0]), a
                },
                PSEUDO: function(a) {
                    var b, c = !a[6] && a[2];
                    return V.CHILD.test(a[0]) ? null : (a[3] ? a[2] = a[4] || a[5] || "" : c && T.test(c) && (b = g(c, !0)) && (b = c.indexOf(")", c.length - b) - c.length) && (a[0] = a[0].slice(0, b), a[2] = c.slice(0, b)), a.slice(0, 3))
                }
            },
            filter: {
                TAG: function(a) {
                    var b = a.replace(_, aa).toLowerCase();
                    return "*" === a ? function() {
                        return !0
                    } : function(a) {
                        return a.nodeName && a.nodeName.toLowerCase() === b
                    }
                },
                CLASS: function(a) {
                    var b = y[a + " "];
                    return b || (b = new RegExp("(^|" + K + ")" + a + "(" + K + "|$)")) && y(a, function(a) {
                        return b.test("string" == typeof a.className && a.className || "undefined" != typeof a.getAttribute && a.getAttribute("class") || "")
                    })
                },
                ATTR: function(a, b, c) {
                    return function(d) {
                        var e = ga.attr(d, a);
                        return null == e ? "!=" === b : !b || (e += "", "=" === b ? e === c : "!=" === b ? e !== c : "^=" === b ? c && 0 === e.indexOf(c) : "*=" === b ? c && e.indexOf(c) > -1 : "$=" === b ? c && e.slice(-c.length) === c : "~=" === b ? (" " + e.replace(O, " ") + " ").indexOf(c) > -1 : "|=" === b && (e === c || e.slice(0, c.length + 1) === c + "-"))
                    }
                },
                CHILD: function(a, b, c, d, e) {
                    var f = "nth" !== a.slice(0, 3),
                        g = "last" !== a.slice(-4),
                        h = "of-type" === b;
                    return 1 === d && 0 === e ? function(a) {
                        return !!a.parentNode
                    } : function(b, c, i) {
                        var j, k, l, m, n, o, p = f !== g ? "nextSibling" : "previousSibling",
                            q = b.parentNode,
                            r = h && b.nodeName.toLowerCase(),
                            s = !i && !h,
                            t = !1;
                        if (q) {
                            if (f) {
                                while (p) {
                                    m = b;
                                    while (m = m[p])
                                        if (h ? m.nodeName.toLowerCase() === r : 1 === m.nodeType) return !1;
                                    o = p = "only" === a && !o && "nextSibling"
                                }
                                return !0
                            }
                            if (o = [g ? q.firstChild : q.lastChild], g && s) {
                                m = q, l = m[u] || (m[u] = {}), k = l[m.uniqueID] || (l[m.uniqueID] = {}), j = k[a] || [], n = j[0] === w && j[1], t = n && j[2], m = n && q.childNodes[n];
                                while (m = ++n && m && m[p] || (t = n = 0) || o.pop())
                                    if (1 === m.nodeType && ++t && m === b) {
                                        k[a] = [w, n, t];
                                        break
                                    }
                            } else if (s && (m = b, l = m[u] || (m[u] = {}), k = l[m.uniqueID] || (l[m.uniqueID] = {}), j = k[a] || [], n = j[0] === w && j[1], t = n), t === !1)
                                while (m = ++n && m && m[p] || (t = n = 0) || o.pop())
                                    if ((h ? m.nodeName.toLowerCase() === r : 1 === m.nodeType) && ++t && (s && (l = m[u] || (m[u] = {}), k = l[m.uniqueID] || (l[m.uniqueID] = {}), k[a] = [w, t]), m === b)) break;
                            return t -= e, t === d || t % d === 0 && t / d >= 0
                        }
                    }
                },
                PSEUDO: function(a, b) {
                    var c, e = d.pseudos[a] || d.setFilters[a.toLowerCase()] || ga.error("unsupported pseudo: " + a);
                    return e[u] ? e(b) : e.length > 1 ? (c = [a, a, "", b], d.setFilters.hasOwnProperty(a.toLowerCase()) ? ia(function(a, c) {
                        var d, f = e(a, b),
                            g = f.length;
                        while (g--) d = I(a, f[g]), a[d] = !(c[d] = f[g])
                    }) : function(a) {
                        return e(a, 0, c)
                    }) : e
                }
            },
            pseudos: {
                not: ia(function(a) {
                    var b = [],
                        c = [],
                        d = h(a.replace(P, "$1"));
                    return d[u] ? ia(function(a, b, c, e) {
                        var f, g = d(a, null, e, []),
                            h = a.length;
                        while (h--)(f = g[h]) && (a[h] = !(b[h] = f))
                    }) : function(a, e, f) {
                        return b[0] = a, d(b, null, f, c), b[0] = null, !c.pop()
                    }
                }),
                has: ia(function(a) {
                    return function(b) {
                        return ga(a, b).length > 0
                    }
                }),
                contains: ia(function(a) {
                    return a = a.replace(_, aa),
                        function(b) {
                            return (b.textContent || b.innerText || e(b)).indexOf(a) > -1
                        }
                }),
                lang: ia(function(a) {
                    return U.test(a || "") || ga.error("unsupported lang: " + a), a = a.replace(_, aa).toLowerCase(),
                        function(b) {
                            var c;
                            do
                                if (c = p ? b.lang : b.getAttribute("xml:lang") || b.getAttribute("lang")) return c = c.toLowerCase(), c === a || 0 === c.indexOf(a + "-"); while ((b = b.parentNode) && 1 === b.nodeType);
                            return !1
                        }
                }),
                target: function(b) {
                    var c = a.location && a.location.hash;
                    return c && c.slice(1) === b.id
                },
                root: function(a) {
                    return a === o
                },
                focus: function(a) {
                    return a === n.activeElement && (!n.hasFocus || n.hasFocus()) && !!(a.type || a.href || ~a.tabIndex)
                },
                enabled: oa(!1),
                disabled: oa(!0),
                checked: function(a) {
                    var b = a.nodeName.toLowerCase();
                    return "input" === b && !!a.checked || "option" === b && !!a.selected
                },
                selected: function(a) {
                    return a.parentNode && a.parentNode.selectedIndex, a.selected === !0
                },
                empty: function(a) {
                    for (a = a.firstChild; a; a = a.nextSibling)
                        if (a.nodeType < 6) return !1;
                    return !0
                },
                parent: function(a) {
                    return !d.pseudos.empty(a)
                },
                header: function(a) {
                    return X.test(a.nodeName)
                },
                input: function(a) {
                    return W.test(a.nodeName)
                },
                button: function(a) {
                    var b = a.nodeName.toLowerCase();
                    return "input" === b && "button" === a.type || "button" === b
                },
                text: function(a) {
                    var b;
                    return "input" === a.nodeName.toLowerCase() && "text" === a.type && (null == (b = a.getAttribute("type")) || "text" === b.toLowerCase())
                },
                first: pa(function() {
                    return [0]
                }),
                last: pa(function(a, b) {
                    return [b - 1]
                }),
                eq: pa(function(a, b, c) {
                    return [c < 0 ? c + b : c]
                }),
                even: pa(function(a, b) {
                    for (var c = 0; c < b; c += 2) a.push(c);
                    return a
                }),
                odd: pa(function(a, b) {
                    for (var c = 1; c < b; c += 2) a.push(c);
                    return a
                }),
                lt: pa(function(a, b, c) {
                    for (var d = c < 0 ? c + b : c; --d >= 0;) a.push(d);
                    return a
                }),
                gt: pa(function(a, b, c) {
                    for (var d = c < 0 ? c + b : c; ++d < b;) a.push(d);
                    return a
                })
            }
        }, d.pseudos.nth = d.pseudos.eq;
        for (b in {
                radio: !0,
                checkbox: !0,
                file: !0,
                password: !0,
                image: !0
            }) d.pseudos[b] = ma(b);
        for (b in {
                submit: !0,
                reset: !0
            }) d.pseudos[b] = na(b);

        function ra() {}
        ra.prototype = d.filters = d.pseudos, d.setFilters = new ra, g = ga.tokenize = function(a, b) {
            var c, e, f, g, h, i, j, k = z[a + " "];
            if (k) return b ? 0 : k.slice(0);
            h = a, i = [], j = d.preFilter;
            while (h) {
                c && !(e = Q.exec(h)) || (e && (h = h.slice(e[0].length) || h), i.push(f = [])), c = !1, (e = R.exec(h)) && (c = e.shift(), f.push({
                    value: c,
                    type: e[0].replace(P, " ")
                }), h = h.slice(c.length));
                for (g in d.filter) !(e = V[g].exec(h)) || j[g] && !(e = j[g](e)) || (c = e.shift(), f.push({
                    value: c,
                    type: g,
                    matches: e
                }), h = h.slice(c.length));
                if (!c) break
            }
            return b ? h.length : h ? ga.error(a) : z(a, i).slice(0)
        };

        function sa(a) {
            for (var b = 0, c = a.length, d = ""; b < c; b++) d += a[b].value;
            return d
        }

        function ta(a, b, c) {
            var d = b.dir,
                e = b.next,
                f = e || d,
                g = c && "parentNode" === f,
                h = x++;
            return b.first ? function(b, c, e) {
                while (b = b[d])
                    if (1 === b.nodeType || g) return a(b, c, e);
                return !1
            } : function(b, c, i) {
                var j, k, l, m = [w, h];
                if (i) {
                    while (b = b[d])
                        if ((1 === b.nodeType || g) && a(b, c, i)) return !0
                } else
                    while (b = b[d])
                        if (1 === b.nodeType || g)
                            if (l = b[u] || (b[u] = {}), k = l[b.uniqueID] || (l[b.uniqueID] = {}), e && e === b.nodeName.toLowerCase()) b = b[d] || b;
                            else {
                                if ((j = k[f]) && j[0] === w && j[1] === h) return m[2] = j[2];
                                if (k[f] = m, m[2] = a(b, c, i)) return !0
                            } return !1
            }
        }

        function ua(a) {
            return a.length > 1 ? function(b, c, d) {
                var e = a.length;
                while (e--)
                    if (!a[e](b, c, d)) return !1;
                return !0
            } : a[0]
        }

        function va(a, b, c) {
            for (var d = 0, e = b.length; d < e; d++) ga(a, b[d], c);
            return c
        }

        function wa(a, b, c, d, e) {
            for (var f, g = [], h = 0, i = a.length, j = null != b; h < i; h++)(f = a[h]) && (c && !c(f, d, e) || (g.push(f), j && b.push(h)));
            return g
        }

        function xa(a, b, c, d, e, f) {
            return d && !d[u] && (d = xa(d)), e && !e[u] && (e = xa(e, f)), ia(function(f, g, h, i) {
                var j, k, l, m = [],
                    n = [],
                    o = g.length,
                    p = f || va(b || "*", h.nodeType ? [h] : h, []),
                    q = !a || !f && b ? p : wa(p, m, a, h, i),
                    r = c ? e || (f ? a : o || d) ? [] : g : q;
                if (c && c(q, r, h, i), d) {
                    j = wa(r, n), d(j, [], h, i), k = j.length;
                    while (k--)(l = j[k]) && (r[n[k]] = !(q[n[k]] = l))
                }
                if (f) {
                    if (e || a) {
                        if (e) {
                            j = [], k = r.length;
                            while (k--)(l = r[k]) && j.push(q[k] = l);
                            e(null, r = [], j, i)
                        }
                        k = r.length;
                        while (k--)(l = r[k]) && (j = e ? I(f, l) : m[k]) > -1 && (f[j] = !(g[j] = l))
                    }
                } else r = wa(r === g ? r.splice(o, r.length) : r), e ? e(null, g, r, i) : G.apply(g, r)
            })
        }

        function ya(a) {
            for (var b, c, e, f = a.length, g = d.relative[a[0].type], h = g || d.relative[" "], i = g ? 1 : 0, k = ta(function(a) {
                    return a === b
                }, h, !0), l = ta(function(a) {
                    return I(b, a) > -1
                }, h, !0), m = [function(a, c, d) {
                    var e = !g && (d || c !== j) || ((b = c).nodeType ? k(a, c, d) : l(a, c, d));
                    return b = null, e
                }]; i < f; i++)
                if (c = d.relative[a[i].type]) m = [ta(ua(m), c)];
                else {
                    if (c = d.filter[a[i].type].apply(null, a[i].matches), c[u]) {
                        for (e = ++i; e < f; e++)
                            if (d.relative[a[e].type]) break;
                        return xa(i > 1 && ua(m), i > 1 && sa(a.slice(0, i - 1).concat({
                            value: " " === a[i - 2].type ? "*" : ""
                        })).replace(P, "$1"), c, i < e && ya(a.slice(i, e)), e < f && ya(a = a.slice(e)), e < f && sa(a))
                    }
                    m.push(c)
                }
            return ua(m)
        }

        function za(a, b) {
            var c = b.length > 0,
                e = a.length > 0,
                f = function(f, g, h, i, k) {
                    var l, o, q, r = 0,
                        s = "0",
                        t = f && [],
                        u = [],
                        v = j,
                        x = f || e && d.find.TAG("*", k),
                        y = w += null == v ? 1 : Math.random() || .1,
                        z = x.length;
                    for (k && (j = g === n || g || k); s !== z && null != (l = x[s]); s++) {
                        if (e && l) {
                            o = 0, g || l.ownerDocument === n || (m(l), h = !p);
                            while (q = a[o++])
                                if (q(l, g || n, h)) {
                                    i.push(l);
                                    break
                                }
                            k && (w = y)
                        }
                        c && ((l = !q && l) && r--, f && t.push(l))
                    }
                    if (r += s, c && s !== r) {
                        o = 0;
                        while (q = b[o++]) q(t, u, g, h);
                        if (f) {
                            if (r > 0)
                                while (s--) t[s] || u[s] || (u[s] = E.call(i));
                            u = wa(u)
                        }
                        G.apply(i, u), k && !f && u.length > 0 && r + b.length > 1 && ga.uniqueSort(i)
                    }
                    return k && (w = y, j = v), t
                };
            return c ? ia(f) : f
        }
        return h = ga.compile = function(a, b) {
            var c, d = [],
                e = [],
                f = A[a + " "];
            if (!f) {
                b || (b = g(a)), c = b.length;
                while (c--) f = ya(b[c]), f[u] ? d.push(f) : e.push(f);
                f = A(a, za(e, d)), f.selector = a
            }
            return f
        }, i = ga.select = function(a, b, c, e) {
            var f, i, j, k, l, m = "function" == typeof a && a,
                n = !e && g(a = m.selector || a);
            if (c = c || [], 1 === n.length) {
                if (i = n[0] = n[0].slice(0), i.length > 2 && "ID" === (j = i[0]).type && 9 === b.nodeType && p && d.relative[i[1].type]) {
                    if (b = (d.find.ID(j.matches[0].replace(_, aa), b) || [])[0], !b) return c;
                    m && (b = b.parentNode), a = a.slice(i.shift().value.length)
                }
                f = V.needsContext.test(a) ? 0 : i.length;
                while (f--) {
                    if (j = i[f], d.relative[k = j.type]) break;
                    if ((l = d.find[k]) && (e = l(j.matches[0].replace(_, aa), $.test(i[0].type) && qa(b.parentNode) || b))) {
                        if (i.splice(f, 1), a = e.length && sa(i), !a) return G.apply(c, e), c;
                        break
                    }
                }
            }
            return (m || h(a, n))(e, b, !p, c, !b || $.test(a) && qa(b.parentNode) || b), c
        }, c.sortStable = u.split("").sort(B).join("") === u, c.detectDuplicates = !!l, m(), c.sortDetached = ja(function(a) {
            return 1 & a.compareDocumentPosition(n.createElement("fieldset"))
        }), ja(function(a) {
            return a.innerHTML = "<a href='#'></a>", "#" === a.firstChild.getAttribute("href")
        }) || ka("type|href|height|width", function(a, b, c) {
            if (!c) return a.getAttribute(b, "type" === b.toLowerCase() ? 1 : 2)
        }), c.attributes && ja(function(a) {
            return a.innerHTML = "<input/>", a.firstChild.setAttribute("value", ""), "" === a.firstChild.getAttribute("value")
        }) || ka("value", function(a, b, c) {
            if (!c && "input" === a.nodeName.toLowerCase()) return a.defaultValue
        }), ja(function(a) {
            return null == a.getAttribute("disabled")
        }) || ka(J, function(a, b, c) {
            var d;
            if (!c) return a[b] === !0 ? b.toLowerCase() : (d = a.getAttributeNode(b)) && d.specified ? d.value : null
        }), ga
    }(a);
    r.find = x, r.expr = x.selectors, r.expr[":"] = r.expr.pseudos, r.uniqueSort = r.unique = x.uniqueSort, r.text = x.getText, r.isXMLDoc = x.isXML, r.contains = x.contains, r.escapeSelector = x.escape;
    var y = function(a, b, c) {
            var d = [],
                e = void 0 !== c;
            while ((a = a[b]) && 9 !== a.nodeType)
                if (1 === a.nodeType) {
                    if (e && r(a).is(c)) break;
                    d.push(a)
                }
            return d
        },
        z = function(a, b) {
            for (var c = []; a; a = a.nextSibling) 1 === a.nodeType && a !== b && c.push(a);
            return c
        },
        A = r.expr.match.needsContext;

    function B(a, b) {
        return a.nodeName && a.nodeName.toLowerCase() === b.toLowerCase()
    }
    var C = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i,
        D = /^.[^:#\[\.,]*$/;

    function E(a, b, c) {
        return r.isFunction(b) ? r.grep(a, function(a, d) {
            return !!b.call(a, d, a) !== c
        }) : b.nodeType ? r.grep(a, function(a) {
            return a === b !== c
        }) : "string" != typeof b ? r.grep(a, function(a) {
            return i.call(b, a) > -1 !== c
        }) : D.test(b) ? r.filter(b, a, c) : (b = r.filter(b, a), r.grep(a, function(a) {
            return i.call(b, a) > -1 !== c && 1 === a.nodeType
        }))
    }
    r.filter = function(a, b, c) {
        var d = b[0];
        return c && (a = ":not(" + a + ")"), 1 === b.length && 1 === d.nodeType ? r.find.matchesSelector(d, a) ? [d] : [] : r.find.matches(a, r.grep(b, function(a) {
            return 1 === a.nodeType
        }))
    }, r.fn.extend({
        find: function(a) {
            var b, c, d = this.length,
                e = this;
            if ("string" != typeof a) return this.pushStack(r(a).filter(function() {
                for (b = 0; b < d; b++)
                    if (r.contains(e[b], this)) return !0
            }));
            for (c = this.pushStack([]), b = 0; b < d; b++) r.find(a, e[b], c);
            return d > 1 ? r.uniqueSort(c) : c
        },
        filter: function(a) {
            return this.pushStack(E(this, a || [], !1))
        },
        not: function(a) {
            return this.pushStack(E(this, a || [], !0))
        },
        is: function(a) {
            return !!E(this, "string" == typeof a && A.test(a) ? r(a) : a || [], !1).length
        }
    });
    var F, G = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,
        H = r.fn.init = function(a, b, c) {
            var e, f;
            if (!a) return this;
            if (c = c || F, "string" == typeof a) {
                if (e = "<" === a[0] && ">" === a[a.length - 1] && a.length >= 3 ? [null, a, null] : G.exec(a), !e || !e[1] && b) return !b || b.jquery ? (b || c).find(a) : this.constructor(b).find(a);
                if (e[1]) {
                    if (b = b instanceof r ? b[0] : b, r.merge(this, r.parseHTML(e[1], b && b.nodeType ? b.ownerDocument || b : d, !0)), C.test(e[1]) && r.isPlainObject(b))
                        for (e in b) r.isFunction(this[e]) ? this[e](b[e]) : this.attr(e, b[e]);
                    return this
                }
                return f = d.getElementById(e[2]), f && (this[0] = f, this.length = 1), this
            }
            return a.nodeType ? (this[0] = a, this.length = 1, this) : r.isFunction(a) ? void 0 !== c.ready ? c.ready(a) : a(r) : r.makeArray(a, this)
        };
    H.prototype = r.fn, F = r(d);
    var I = /^(?:parents|prev(?:Until|All))/,
        J = {
            children: !0,
            contents: !0,
            next: !0,
            prev: !0
        };
    r.fn.extend({
        has: function(a) {
            var b = r(a, this),
                c = b.length;
            return this.filter(function() {
                for (var a = 0; a < c; a++)
                    if (r.contains(this, b[a])) return !0
            })
        },
        closest: function(a, b) {
            var c, d = 0,
                e = this.length,
                f = [],
                g = "string" != typeof a && r(a);
            if (!A.test(a))
                for (; d < e; d++)
                    for (c = this[d]; c && c !== b; c = c.parentNode)
                        if (c.nodeType < 11 && (g ? g.index(c) > -1 : 1 === c.nodeType && r.find.matchesSelector(c, a))) {
                            f.push(c);
                            break
                        }
            return this.pushStack(f.length > 1 ? r.uniqueSort(f) : f)
        },
        index: function(a) {
            return a ? "string" == typeof a ? i.call(r(a), this[0]) : i.call(this, a.jquery ? a[0] : a) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1
        },
        add: function(a, b) {
            return this.pushStack(r.uniqueSort(r.merge(this.get(), r(a, b))))
        },
        addBack: function(a) {
            return this.add(null == a ? this.prevObject : this.prevObject.filter(a))
        }
    });

    function K(a, b) {
        while ((a = a[b]) && 1 !== a.nodeType);
        return a
    }
    r.each({
        parent: function(a) {
            var b = a.parentNode;
            return b && 11 !== b.nodeType ? b : null
        },
        parents: function(a) {
            return y(a, "parentNode")
        },
        parentsUntil: function(a, b, c) {
            return y(a, "parentNode", c)
        },
        next: function(a) {
            return K(a, "nextSibling")
        },
        prev: function(a) {
            return K(a, "previousSibling")
        },
        nextAll: function(a) {
            return y(a, "nextSibling")
        },
        prevAll: function(a) {
            return y(a, "previousSibling")
        },
        nextUntil: function(a, b, c) {
            return y(a, "nextSibling", c)
        },
        prevUntil: function(a, b, c) {
            return y(a, "previousSibling", c)
        },
        siblings: function(a) {
            return z((a.parentNode || {}).firstChild, a)
        },
        children: function(a) {
            return z(a.firstChild)
        },
        contents: function(a) {
            return B(a, "iframe") ? a.contentDocument : (B(a, "template") && (a = a.content || a), r.merge([], a.childNodes))
        }
    }, function(a, b) {
        r.fn[a] = function(c, d) {
            var e = r.map(this, b, c);
            return "Until" !== a.slice(-5) && (d = c), d && "string" == typeof d && (e = r.filter(d, e)), this.length > 1 && (J[a] || r.uniqueSort(e), I.test(a) && e.reverse()), this.pushStack(e)
        }
    });
    var L = /[^\x20\t\r\n\f]+/g;

    function M(a) {
        var b = {};
        return r.each(a.match(L) || [], function(a, c) {
            b[c] = !0
        }), b
    }
    r.Callbacks = function(a) {
        a = "string" == typeof a ? M(a) : r.extend({}, a);
        var b, c, d, e, f = [],
            g = [],
            h = -1,
            i = function() {
                for (e = e || a.once, d = b = !0; g.length; h = -1) {
                    c = g.shift();
                    while (++h < f.length) f[h].apply(c[0], c[1]) === !1 && a.stopOnFalse && (h = f.length, c = !1)
                }
                a.memory || (c = !1), b = !1, e && (f = c ? [] : "")
            },
            j = {
                add: function() {
                    return f && (c && !b && (h = f.length - 1, g.push(c)), function d(b) {
                        r.each(b, function(b, c) {
                            r.isFunction(c) ? a.unique && j.has(c) || f.push(c) : c && c.length && "string" !== r.type(c) && d(c)
                        })
                    }(arguments), c && !b && i()), this
                },
                remove: function() {
                    return r.each(arguments, function(a, b) {
                        var c;
                        while ((c = r.inArray(b, f, c)) > -1) f.splice(c, 1), c <= h && h--
                    }), this
                },
                has: function(a) {
                    return a ? r.inArray(a, f) > -1 : f.length > 0
                },
                empty: function() {
                    return f && (f = []), this
                },
                disable: function() {
                    return e = g = [], f = c = "", this
                },
                disabled: function() {
                    return !f
                },
                lock: function() {
                    return e = g = [], c || b || (f = c = ""), this
                },
                locked: function() {
                    return !!e
                },
                fireWith: function(a, c) {
                    return e || (c = c || [], c = [a, c.slice ? c.slice() : c], g.push(c), b || i()), this
                },
                fire: function() {
                    return j.fireWith(this, arguments), this
                },
                fired: function() {
                    return !!d
                }
            };
        return j
    };

    function N(a) {
        return a
    }

    function O(a) {
        throw a
    }

    function P(a, b, c, d) {
        var e;
        try {
            a && r.isFunction(e = a.promise) ? e.call(a).done(b).fail(c) : a && r.isFunction(e = a.then) ? e.call(a, b, c) : b.apply(void 0, [a].slice(d))
        } catch (a) {
            c.apply(void 0, [a])
        }
    }
    r.extend({
        Deferred: function(b) {
            var c = [
                    ["notify", "progress", r.Callbacks("memory"), r.Callbacks("memory"), 2],
                    ["resolve", "done", r.Callbacks("once memory"), r.Callbacks("once memory"), 0, "resolved"],
                    ["reject", "fail", r.Callbacks("once memory"), r.Callbacks("once memory"), 1, "rejected"]
                ],
                d = "pending",
                e = {
                    state: function() {
                        return d
                    },
                    always: function() {
                        return f.done(arguments).fail(arguments), this
                    },
                    "catch": function(a) {
                        return e.then(null, a)
                    },
                    pipe: function() {
                        var a = arguments;
                        return r.Deferred(function(b) {
                            r.each(c, function(c, d) {
                                var e = r.isFunction(a[d[4]]) && a[d[4]];
                                f[d[1]](function() {
                                    var a = e && e.apply(this, arguments);
                                    a && r.isFunction(a.promise) ? a.promise().progress(b.notify).done(b.resolve).fail(b.reject) : b[d[0] + "With"](this, e ? [a] : arguments)
                                })
                            }), a = null
                        }).promise()
                    },
                    then: function(b, d, e) {
                        var f = 0;

                        function g(b, c, d, e) {
                            return function() {
                                var h = this,
                                    i = arguments,
                                    j = function() {
                                        var a, j;
                                        if (!(b < f)) {
                                            if (a = d.apply(h, i), a === c.promise()) throw new TypeError("Thenable self-resolution");
                                            j = a && ("object" == typeof a || "function" == typeof a) && a.then, r.isFunction(j) ? e ? j.call(a, g(f, c, N, e), g(f, c, O, e)) : (f++, j.call(a, g(f, c, N, e), g(f, c, O, e), g(f, c, N, c.notifyWith))) : (d !== N && (h = void 0, i = [a]), (e || c.resolveWith)(h, i))
                                        }
                                    },
                                    k = e ? j : function() {
                                        try {
                                            j()
                                        } catch (a) {
                                            r.Deferred.exceptionHook && r.Deferred.exceptionHook(a, k.stackTrace), b + 1 >= f && (d !== O && (h = void 0, i = [a]), c.rejectWith(h, i))
                                        }
                                    };
                                b ? k() : (r.Deferred.getStackHook && (k.stackTrace = r.Deferred.getStackHook()), a.setTimeout(k))
                            }
                        }
                        return r.Deferred(function(a) {
                            c[0][3].add(g(0, a, r.isFunction(e) ? e : N, a.notifyWith)), c[1][3].add(g(0, a, r.isFunction(b) ? b : N)), c[2][3].add(g(0, a, r.isFunction(d) ? d : O))
                        }).promise()
                    },
                    promise: function(a) {
                        return null != a ? r.extend(a, e) : e
                    }
                },
                f = {};
            return r.each(c, function(a, b) {
                var g = b[2],
                    h = b[5];
                e[b[1]] = g.add, h && g.add(function() {
                    d = h
                }, c[3 - a][2].disable, c[0][2].lock), g.add(b[3].fire), f[b[0]] = function() {
                    return f[b[0] + "With"](this === f ? void 0 : this, arguments), this
                }, f[b[0] + "With"] = g.fireWith
            }), e.promise(f), b && b.call(f, f), f
        },
        when: function(a) {
            var b = arguments.length,
                c = b,
                d = Array(c),
                e = f.call(arguments),
                g = r.Deferred(),
                h = function(a) {
                    return function(c) {
                        d[a] = this, e[a] = arguments.length > 1 ? f.call(arguments) : c, --b || g.resolveWith(d, e)
                    }
                };
            if (b <= 1 && (P(a, g.done(h(c)).resolve, g.reject, !b), "pending" === g.state() || r.isFunction(e[c] && e[c].then))) return g.then();
            while (c--) P(e[c], h(c), g.reject);
            return g.promise()
        }
    });
    var Q = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
    r.Deferred.exceptionHook = function(b, c) {
        a.console && a.console.warn && b && Q.test(b.name) && a.console.warn("jQuery.Deferred exception: " + b.message, b.stack, c)
    }, r.readyException = function(b) {
        a.setTimeout(function() {
            throw b
        })
    };
    var R = r.Deferred();
    r.fn.ready = function(a) {
        return R.then(a)["catch"](function(a) {
            r.readyException(a)
        }), this
    }, r.extend({
        isReady: !1,
        readyWait: 1,
        ready: function(a) {
            (a === !0 ? --r.readyWait : r.isReady) || (r.isReady = !0, a !== !0 && --r.readyWait > 0 || R.resolveWith(d, [r]))
        }
    }), r.ready.then = R.then;

    function S() {
        d.removeEventListener("DOMContentLoaded", S),
            a.removeEventListener("load", S), r.ready()
    }
    "complete" === d.readyState || "loading" !== d.readyState && !d.documentElement.doScroll ? a.setTimeout(r.ready) : (d.addEventListener("DOMContentLoaded", S), a.addEventListener("load", S));
    var T = function(a, b, c, d, e, f, g) {
            var h = 0,
                i = a.length,
                j = null == c;
            if ("object" === r.type(c)) {
                e = !0;
                for (h in c) T(a, b, h, c[h], !0, f, g)
            } else if (void 0 !== d && (e = !0, r.isFunction(d) || (g = !0), j && (g ? (b.call(a, d), b = null) : (j = b, b = function(a, b, c) {
                    return j.call(r(a), c)
                })), b))
                for (; h < i; h++) b(a[h], c, g ? d : d.call(a[h], h, b(a[h], c)));
            return e ? a : j ? b.call(a) : i ? b(a[0], c) : f
        },
        U = function(a) {
            return 1 === a.nodeType || 9 === a.nodeType || !+a.nodeType
        };

    function V() {
        this.expando = r.expando + V.uid++
    }
    V.uid = 1, V.prototype = {
        cache: function(a) {
            var b = a[this.expando];
            return b || (b = {}, U(a) && (a.nodeType ? a[this.expando] = b : Object.defineProperty(a, this.expando, {
                value: b,
                configurable: !0
            }))), b
        },
        set: function(a, b, c) {
            var d, e = this.cache(a);
            if ("string" == typeof b) e[r.camelCase(b)] = c;
            else
                for (d in b) e[r.camelCase(d)] = b[d];
            return e
        },
        get: function(a, b) {
            return void 0 === b ? this.cache(a) : a[this.expando] && a[this.expando][r.camelCase(b)]
        },
        access: function(a, b, c) {
            return void 0 === b || b && "string" == typeof b && void 0 === c ? this.get(a, b) : (this.set(a, b, c), void 0 !== c ? c : b)
        },
        remove: function(a, b) {
            var c, d = a[this.expando];
            if (void 0 !== d) {
                if (void 0 !== b) {
                    Array.isArray(b) ? b = b.map(r.camelCase) : (b = r.camelCase(b), b = b in d ? [b] : b.match(L) || []), c = b.length;
                    while (c--) delete d[b[c]]
                }(void 0 === b || r.isEmptyObject(d)) && (a.nodeType ? a[this.expando] = void 0 : delete a[this.expando])
            }
        },
        hasData: function(a) {
            var b = a[this.expando];
            return void 0 !== b && !r.isEmptyObject(b)
        }
    };
    var W = new V,
        X = new V,
        Y = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
        Z = /[A-Z]/g;

    function $(a) {
        return "true" === a || "false" !== a && ("null" === a ? null : a === +a + "" ? +a : Y.test(a) ? JSON.parse(a) : a)
    }

    function _(a, b, c) {
        var d;
        if (void 0 === c && 1 === a.nodeType)
            if (d = "data-" + b.replace(Z, "-$&").toLowerCase(), c = a.getAttribute(d), "string" == typeof c) {
                try {
                    c = $(c)
                } catch (e) {}
                X.set(a, b, c)
            } else c = void 0;
        return c
    }
    r.extend({
        hasData: function(a) {
            return X.hasData(a) || W.hasData(a)
        },
        data: function(a, b, c) {
            return X.access(a, b, c)
        },
        removeData: function(a, b) {
            X.remove(a, b)
        },
        _data: function(a, b, c) {
            return W.access(a, b, c)
        },
        _removeData: function(a, b) {
            W.remove(a, b)
        }
    }), r.fn.extend({
        data: function(a, b) {
            var c, d, e, f = this[0],
                g = f && f.attributes;
            if (void 0 === a) {
                if (this.length && (e = X.get(f), 1 === f.nodeType && !W.get(f, "hasDataAttrs"))) {
                    c = g.length;
                    while (c--) g[c] && (d = g[c].name, 0 === d.indexOf("data-") && (d = r.camelCase(d.slice(5)), _(f, d, e[d])));
                    W.set(f, "hasDataAttrs", !0)
                }
                return e
            }
            return "object" == typeof a ? this.each(function() {
                X.set(this, a)
            }) : T(this, function(b) {
                var c;
                if (f && void 0 === b) {
                    if (c = X.get(f, a), void 0 !== c) return c;
                    if (c = _(f, a), void 0 !== c) return c
                } else this.each(function() {
                    X.set(this, a, b)
                })
            }, null, b, arguments.length > 1, null, !0)
        },
        removeData: function(a) {
            return this.each(function() {
                X.remove(this, a)
            })
        }
    }), r.extend({
        queue: function(a, b, c) {
            var d;
            if (a) return b = (b || "fx") + "queue", d = W.get(a, b), c && (!d || Array.isArray(c) ? d = W.access(a, b, r.makeArray(c)) : d.push(c)), d || []
        },
        dequeue: function(a, b) {
            b = b || "fx";
            var c = r.queue(a, b),
                d = c.length,
                e = c.shift(),
                f = r._queueHooks(a, b),
                g = function() {
                    r.dequeue(a, b)
                };
            "inprogress" === e && (e = c.shift(), d--), e && ("fx" === b && c.unshift("inprogress"), delete f.stop, e.call(a, g, f)), !d && f && f.empty.fire()
        },
        _queueHooks: function(a, b) {
            var c = b + "queueHooks";
            return W.get(a, c) || W.access(a, c, {
                empty: r.Callbacks("once memory").add(function() {
                    W.remove(a, [b + "queue", c])
                })
            })
        }
    }), r.fn.extend({
        queue: function(a, b) {
            var c = 2;
            return "string" != typeof a && (b = a, a = "fx", c--), arguments.length < c ? r.queue(this[0], a) : void 0 === b ? this : this.each(function() {
                var c = r.queue(this, a, b);
                r._queueHooks(this, a), "fx" === a && "inprogress" !== c[0] && r.dequeue(this, a)
            })
        },
        dequeue: function(a) {
            return this.each(function() {
                r.dequeue(this, a)
            })
        },
        clearQueue: function(a) {
            return this.queue(a || "fx", [])
        },
        promise: function(a, b) {
            var c, d = 1,
                e = r.Deferred(),
                f = this,
                g = this.length,
                h = function() {
                    --d || e.resolveWith(f, [f])
                };
            "string" != typeof a && (b = a, a = void 0), a = a || "fx";
            while (g--) c = W.get(f[g], a + "queueHooks"), c && c.empty && (d++, c.empty.add(h));
            return h(), e.promise(b)
        }
    });
    var aa = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,
        ba = new RegExp("^(?:([+-])=|)(" + aa + ")([a-z%]*)$", "i"),
        ca = ["Top", "Right", "Bottom", "Left"],
        da = function(a, b) {
            return a = b || a, "none" === a.style.display || "" === a.style.display && r.contains(a.ownerDocument, a) && "none" === r.css(a, "display")
        },
        ea = function(a, b, c, d) {
            var e, f, g = {};
            for (f in b) g[f] = a.style[f], a.style[f] = b[f];
            e = c.apply(a, d || []);
            for (f in b) a.style[f] = g[f];
            return e
        };

    function fa(a, b, c, d) {
        var e, f = 1,
            g = 20,
            h = d ? function() {
                return d.cur()
            } : function() {
                return r.css(a, b, "")
            },
            i = h(),
            j = c && c[3] || (r.cssNumber[b] ? "" : "px"),
            k = (r.cssNumber[b] || "px" !== j && +i) && ba.exec(r.css(a, b));
        if (k && k[3] !== j) {
            j = j || k[3], c = c || [], k = +i || 1;
            do f = f || ".5", k /= f, r.style(a, b, k + j); while (f !== (f = h() / i) && 1 !== f && --g)
        }
        return c && (k = +k || +i || 0, e = c[1] ? k + (c[1] + 1) * c[2] : +c[2], d && (d.unit = j, d.start = k, d.end = e)), e
    }
    var ga = {};

    function ha(a) {
        var b, c = a.ownerDocument,
            d = a.nodeName,
            e = ga[d];
        return e ? e : (b = c.body.appendChild(c.createElement(d)), e = r.css(b, "display"), b.parentNode.removeChild(b), "none" === e && (e = "block"), ga[d] = e, e)
    }

    function ia(a, b) {
        for (var c, d, e = [], f = 0, g = a.length; f < g; f++) d = a[f], d.style && (c = d.style.display, b ? ("none" === c && (e[f] = W.get(d, "display") || null, e[f] || (d.style.display = "")), "" === d.style.display && da(d) && (e[f] = ha(d))) : "none" !== c && (e[f] = "none", W.set(d, "display", c)));
        for (f = 0; f < g; f++) null != e[f] && (a[f].style.display = e[f]);
        return a
    }
    r.fn.extend({
        show: function() {
            return ia(this, !0)
        },
        hide: function() {
            return ia(this)
        },
        toggle: function(a) {
            return "boolean" == typeof a ? a ? this.show() : this.hide() : this.each(function() {
                da(this) ? r(this).show() : r(this).hide()
            })
        }
    });
    var ja = /^(?:checkbox|radio)$/i,
        ka = /<([a-z][^\/\0>\x20\t\r\n\f]+)/i,
        la = /^$|\/(?:java|ecma)script/i,
        ma = {
            option: [1, "<select multiple='multiple'>", "</select>"],
            thead: [1, "<table>", "</table>"],
            col: [2, "<table><colgroup>", "</colgroup></table>"],
            tr: [2, "<table><tbody>", "</tbody></table>"],
            td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
            _default: [0, "", ""]
        };
    ma.optgroup = ma.option, ma.tbody = ma.tfoot = ma.colgroup = ma.caption = ma.thead, ma.th = ma.td;

    function na(a, b) {
        var c;
        return c = "undefined" != typeof a.getElementsByTagName ? a.getElementsByTagName(b || "*") : "undefined" != typeof a.querySelectorAll ? a.querySelectorAll(b || "*") : [], void 0 === b || b && B(a, b) ? r.merge([a], c) : c
    }

    function oa(a, b) {
        for (var c = 0, d = a.length; c < d; c++) W.set(a[c], "globalEval", !b || W.get(b[c], "globalEval"))
    }
    var pa = /<|&#?\w+;/;

    function qa(a, b, c, d, e) {
        for (var f, g, h, i, j, k, l = b.createDocumentFragment(), m = [], n = 0, o = a.length; n < o; n++)
            if (f = a[n], f || 0 === f)
                if ("object" === r.type(f)) r.merge(m, f.nodeType ? [f] : f);
                else if (pa.test(f)) {
            g = g || l.appendChild(b.createElement("div")), h = (ka.exec(f) || ["", ""])[1].toLowerCase(), i = ma[h] || ma._default, g.innerHTML = i[1] + r.htmlPrefilter(f) + i[2], k = i[0];
            while (k--) g = g.lastChild;
            r.merge(m, g.childNodes), g = l.firstChild, g.textContent = ""
        } else m.push(b.createTextNode(f));
        l.textContent = "", n = 0;
        while (f = m[n++])
            if (d && r.inArray(f, d) > -1) e && e.push(f);
            else if (j = r.contains(f.ownerDocument, f), g = na(l.appendChild(f), "script"), j && oa(g), c) {
            k = 0;
            while (f = g[k++]) la.test(f.type || "") && c.push(f)
        }
        return l
    }! function() {
        var a = d.createDocumentFragment(),
            b = a.appendChild(d.createElement("div")),
            c = d.createElement("input");
        c.setAttribute("type", "radio"), c.setAttribute("checked", "checked"), c.setAttribute("name", "t"), b.appendChild(c), o.checkClone = b.cloneNode(!0).cloneNode(!0).lastChild.checked, b.innerHTML = "<textarea>x</textarea>", o.noCloneChecked = !!b.cloneNode(!0).lastChild.defaultValue
    }();
    var ra = d.documentElement,
        sa = /^key/,
        ta = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
        ua = /^([^.]*)(?:\.(.+)|)/;

    function va() {
        return !0
    }

    function wa() {
        return !1
    }

    function xa() {
        try {
            return d.activeElement
        } catch (a) {}
    }

    function ya(a, b, c, d, e, f) {
        var g, h;
        if ("object" == typeof b) {
            "string" != typeof c && (d = d || c, c = void 0);
            for (h in b) ya(a, h, c, d, b[h], f);
            return a
        }
        if (null == d && null == e ? (e = c, d = c = void 0) : null == e && ("string" == typeof c ? (e = d, d = void 0) : (e = d, d = c, c = void 0)), e === !1) e = wa;
        else if (!e) return a;
        return 1 === f && (g = e, e = function(a) {
            return r().off(a), g.apply(this, arguments)
        }, e.guid = g.guid || (g.guid = r.guid++)), a.each(function() {
            r.event.add(this, b, e, d, c)
        })
    }
    r.event = {
        global: {},
        add: function(a, b, c, d, e) {
            var f, g, h, i, j, k, l, m, n, o, p, q = W.get(a);
            if (q) {
                c.handler && (f = c, c = f.handler, e = f.selector), e && r.find.matchesSelector(ra, e), c.guid || (c.guid = r.guid++), (i = q.events) || (i = q.events = {}), (g = q.handle) || (g = q.handle = function(b) {
                    return "undefined" != typeof r && r.event.triggered !== b.type ? r.event.dispatch.apply(a, arguments) : void 0
                }), b = (b || "").match(L) || [""], j = b.length;
                while (j--) h = ua.exec(b[j]) || [], n = p = h[1], o = (h[2] || "").split(".").sort(), n && (l = r.event.special[n] || {}, n = (e ? l.delegateType : l.bindType) || n, l = r.event.special[n] || {}, k = r.extend({
                    type: n,
                    origType: p,
                    data: d,
                    handler: c,
                    guid: c.guid,
                    selector: e,
                    needsContext: e && r.expr.match.needsContext.test(e),
                    namespace: o.join(".")
                }, f), (m = i[n]) || (m = i[n] = [], m.delegateCount = 0, l.setup && l.setup.call(a, d, o, g) !== !1 || a.addEventListener && a.addEventListener(n, g)), l.add && (l.add.call(a, k), k.handler.guid || (k.handler.guid = c.guid)), e ? m.splice(m.delegateCount++, 0, k) : m.push(k), r.event.global[n] = !0)
            }
        },
        remove: function(a, b, c, d, e) {
            var f, g, h, i, j, k, l, m, n, o, p, q = W.hasData(a) && W.get(a);
            if (q && (i = q.events)) {
                b = (b || "").match(L) || [""], j = b.length;
                while (j--)
                    if (h = ua.exec(b[j]) || [], n = p = h[1], o = (h[2] || "").split(".").sort(), n) {
                        l = r.event.special[n] || {}, n = (d ? l.delegateType : l.bindType) || n, m = i[n] || [], h = h[2] && new RegExp("(^|\\.)" + o.join("\\.(?:.*\\.|)") + "(\\.|$)"), g = f = m.length;
                        while (f--) k = m[f], !e && p !== k.origType || c && c.guid !== k.guid || h && !h.test(k.namespace) || d && d !== k.selector && ("**" !== d || !k.selector) || (m.splice(f, 1), k.selector && m.delegateCount--, l.remove && l.remove.call(a, k));
                        g && !m.length && (l.teardown && l.teardown.call(a, o, q.handle) !== !1 || r.removeEvent(a, n, q.handle), delete i[n])
                    } else
                        for (n in i) r.event.remove(a, n + b[j], c, d, !0);
                r.isEmptyObject(i) && W.remove(a, "handle events")
            }
        },
        dispatch: function(a) {
            var b = r.event.fix(a),
                c, d, e, f, g, h, i = new Array(arguments.length),
                j = (W.get(this, "events") || {})[b.type] || [],
                k = r.event.special[b.type] || {};
            for (i[0] = b, c = 1; c < arguments.length; c++) i[c] = arguments[c];
            if (b.delegateTarget = this, !k.preDispatch || k.preDispatch.call(this, b) !== !1) {
                h = r.event.handlers.call(this, b, j), c = 0;
                while ((f = h[c++]) && !b.isPropagationStopped()) {
                    b.currentTarget = f.elem, d = 0;
                    while ((g = f.handlers[d++]) && !b.isImmediatePropagationStopped()) b.rnamespace && !b.rnamespace.test(g.namespace) || (b.handleObj = g, b.data = g.data, e = ((r.event.special[g.origType] || {}).handle || g.handler).apply(f.elem, i), void 0 !== e && (b.result = e) === !1 && (b.preventDefault(), b.stopPropagation()))
                }
                return k.postDispatch && k.postDispatch.call(this, b), b.result
            }
        },
        handlers: function(a, b) {
            var c, d, e, f, g, h = [],
                i = b.delegateCount,
                j = a.target;
            if (i && j.nodeType && !("click" === a.type && a.button >= 1))
                for (; j !== this; j = j.parentNode || this)
                    if (1 === j.nodeType && ("click" !== a.type || j.disabled !== !0)) {
                        for (f = [], g = {}, c = 0; c < i; c++) d = b[c], e = d.selector + " ", void 0 === g[e] && (g[e] = d.needsContext ? r(e, this).index(j) > -1 : r.find(e, this, null, [j]).length), g[e] && f.push(d);
                        f.length && h.push({
                            elem: j,
                            handlers: f
                        })
                    }
            return j = this, i < b.length && h.push({
                elem: j,
                handlers: b.slice(i)
            }), h
        },
        addProp: function(a, b) {
            Object.defineProperty(r.Event.prototype, a, {
                enumerable: !0,
                configurable: !0,
                get: r.isFunction(b) ? function() {
                    if (this.originalEvent) return b(this.originalEvent)
                } : function() {
                    if (this.originalEvent) return this.originalEvent[a]
                },
                set: function(b) {
                    Object.defineProperty(this, a, {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: b
                    })
                }
            })
        },
        fix: function(a) {
            return a[r.expando] ? a : new r.Event(a)
        },
        special: {
            load: {
                noBubble: !0
            },
            focus: {
                trigger: function() {
                    if (this !== xa() && this.focus) return this.focus(), !1
                },
                delegateType: "focusin"
            },
            blur: {
                trigger: function() {
                    if (this === xa() && this.blur) return this.blur(), !1
                },
                delegateType: "focusout"
            },
            click: {
                trigger: function() {
                    if ("checkbox" === this.type && this.click && B(this, "input")) return this.click(), !1
                },
                _default: function(a) {
                    return B(a.target, "a")
                }
            },
            beforeunload: {
                postDispatch: function(a) {
                    void 0 !== a.result && a.originalEvent && (a.originalEvent.returnValue = a.result)
                }
            }
        }
    }, r.removeEvent = function(a, b, c) {
        a.removeEventListener && a.removeEventListener(b, c)
    }, r.Event = function(a, b) {
        return this instanceof r.Event ? (a && a.type ? (this.originalEvent = a, this.type = a.type, this.isDefaultPrevented = a.defaultPrevented || void 0 === a.defaultPrevented && a.returnValue === !1 ? va : wa, this.target = a.target && 3 === a.target.nodeType ? a.target.parentNode : a.target, this.currentTarget = a.currentTarget, this.relatedTarget = a.relatedTarget) : this.type = a, b && r.extend(this, b), this.timeStamp = a && a.timeStamp || r.now(), void(this[r.expando] = !0)) : new r.Event(a, b)
    }, r.Event.prototype = {
        constructor: r.Event,
        isDefaultPrevented: wa,
        isPropagationStopped: wa,
        isImmediatePropagationStopped: wa,
        isSimulated: !1,
        preventDefault: function() {
            var a = this.originalEvent;
            this.isDefaultPrevented = va, a && !this.isSimulated && a.preventDefault()
        },
        stopPropagation: function() {
            var a = this.originalEvent;
            this.isPropagationStopped = va, a && !this.isSimulated && a.stopPropagation()
        },
        stopImmediatePropagation: function() {
            var a = this.originalEvent;
            this.isImmediatePropagationStopped = va, a && !this.isSimulated && a.stopImmediatePropagation(), this.stopPropagation()
        }
    }, r.each({
        altKey: !0,
        bubbles: !0,
        cancelable: !0,
        changedTouches: !0,
        ctrlKey: !0,
        detail: !0,
        eventPhase: !0,
        metaKey: !0,
        pageX: !0,
        pageY: !0,
        shiftKey: !0,
        view: !0,
        "char": !0,
        charCode: !0,
        key: !0,
        keyCode: !0,
        button: !0,
        buttons: !0,
        clientX: !0,
        clientY: !0,
        offsetX: !0,
        offsetY: !0,
        pointerId: !0,
        pointerType: !0,
        screenX: !0,
        screenY: !0,
        targetTouches: !0,
        toElement: !0,
        touches: !0,
        which: function(a) {
            var b = a.button;
            return null == a.which && sa.test(a.type) ? null != a.charCode ? a.charCode : a.keyCode : !a.which && void 0 !== b && ta.test(a.type) ? 1 & b ? 1 : 2 & b ? 3 : 4 & b ? 2 : 0 : a.which
        }
    }, r.event.addProp), r.each({
        mouseenter: "mouseover",
        mouseleave: "mouseout",
        pointerenter: "pointerover",
        pointerleave: "pointerout"
    }, function(a, b) {
        r.event.special[a] = {
            delegateType: b,
            bindType: b,
            handle: function(a) {
                var c, d = this,
                    e = a.relatedTarget,
                    f = a.handleObj;
                return e && (e === d || r.contains(d, e)) || (a.type = f.origType, c = f.handler.apply(this, arguments), a.type = b), c
            }
        }
    }), r.fn.extend({
        on: function(a, b, c, d) {
            return ya(this, a, b, c, d)
        },
        one: function(a, b, c, d) {
            return ya(this, a, b, c, d, 1)
        },
        off: function(a, b, c) {
            var d, e;
            if (a && a.preventDefault && a.handleObj) return d = a.handleObj, r(a.delegateTarget).off(d.namespace ? d.origType + "." + d.namespace : d.origType, d.selector, d.handler), this;
            if ("object" == typeof a) {
                for (e in a) this.off(e, b, a[e]);
                return this
            }
            return b !== !1 && "function" != typeof b || (c = b, b = void 0), c === !1 && (c = wa), this.each(function() {
                r.event.remove(this, a, c, b)
            })
        }
    });
    var za = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,
        Aa = /<script|<style|<link/i,
        Ba = /checked\s*(?:[^=]|=\s*.checked.)/i,
        Ca = /^true\/(.*)/,
        Da = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

    function Ea(a, b) {
        return B(a, "table") && B(11 !== b.nodeType ? b : b.firstChild, "tr") ? r(">tbody", a)[0] || a : a
    }

    function Fa(a) {
        return a.type = (null !== a.getAttribute("type")) + "/" + a.type, a
    }

    function Ga(a) {
        var b = Ca.exec(a.type);
        return b ? a.type = b[1] : a.removeAttribute("type"), a
    }

    function Ha(a, b) {
        var c, d, e, f, g, h, i, j;
        if (1 === b.nodeType) {
            if (W.hasData(a) && (f = W.access(a), g = W.set(b, f), j = f.events)) {
                delete g.handle, g.events = {};
                for (e in j)
                    for (c = 0, d = j[e].length; c < d; c++) r.event.add(b, e, j[e][c])
            }
            X.hasData(a) && (h = X.access(a), i = r.extend({}, h), X.set(b, i))
        }
    }

    function Ia(a, b) {
        var c = b.nodeName.toLowerCase();
        "input" === c && ja.test(a.type) ? b.checked = a.checked : "input" !== c && "textarea" !== c || (b.defaultValue = a.defaultValue)
    }

    function Ja(a, b, c, d) {
        b = g.apply([], b);
        var e, f, h, i, j, k, l = 0,
            m = a.length,
            n = m - 1,
            q = b[0],
            s = r.isFunction(q);
        if (s || m > 1 && "string" == typeof q && !o.checkClone && Ba.test(q)) return a.each(function(e) {
            var f = a.eq(e);
            s && (b[0] = q.call(this, e, f.html())), Ja(f, b, c, d)
        });
        if (m && (e = qa(b, a[0].ownerDocument, !1, a, d), f = e.firstChild, 1 === e.childNodes.length && (e = f), f || d)) {
            for (h = r.map(na(e, "script"), Fa), i = h.length; l < m; l++) j = e, l !== n && (j = r.clone(j, !0, !0), i && r.merge(h, na(j, "script"))), c.call(a[l], j, l);
            if (i)
                for (k = h[h.length - 1].ownerDocument, r.map(h, Ga), l = 0; l < i; l++) j = h[l], la.test(j.type || "") && !W.access(j, "globalEval") && r.contains(k, j) && (j.src ? r._evalUrl && r._evalUrl(j.src) : p(j.textContent.replace(Da, ""), k))
        }
        return a
    }

    function Ka(a, b, c) {
        for (var d, e = b ? r.filter(b, a) : a, f = 0; null != (d = e[f]); f++) c || 1 !== d.nodeType || r.cleanData(na(d)), d.parentNode && (c && r.contains(d.ownerDocument, d) && oa(na(d, "script")), d.parentNode.removeChild(d));
        return a
    }
    r.extend({
        htmlPrefilter: function(a) {
            return a.replace(za, "<$1></$2>")
        },
        clone: function(a, b, c) {
            var d, e, f, g, h = a.cloneNode(!0),
                i = r.contains(a.ownerDocument, a);
            if (!(o.noCloneChecked || 1 !== a.nodeType && 11 !== a.nodeType || r.isXMLDoc(a)))
                for (g = na(h), f = na(a), d = 0, e = f.length; d < e; d++) Ia(f[d], g[d]);
            if (b)
                if (c)
                    for (f = f || na(a), g = g || na(h), d = 0, e = f.length; d < e; d++) Ha(f[d], g[d]);
                else Ha(a, h);
            return g = na(h, "script"), g.length > 0 && oa(g, !i && na(a, "script")), h
        },
        cleanData: function(a) {
            for (var b, c, d, e = r.event.special, f = 0; void 0 !== (c = a[f]); f++)
                if (U(c)) {
                    if (b = c[W.expando]) {
                        if (b.events)
                            for (d in b.events) e[d] ? r.event.remove(c, d) : r.removeEvent(c, d, b.handle);
                        c[W.expando] = void 0
                    }
                    c[X.expando] && (c[X.expando] = void 0)
                }
        }
    }), r.fn.extend({
        detach: function(a) {
            return Ka(this, a, !0)
        },
        remove: function(a) {
            return Ka(this, a)
        },
        text: function(a) {
            return T(this, function(a) {
                return void 0 === a ? r.text(this) : this.empty().each(function() {
                    1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || (this.textContent = a)
                })
            }, null, a, arguments.length)
        },
        append: function() {
            return Ja(this, arguments, function(a) {
                if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
                    var b = Ea(this, a);
                    b.appendChild(a)
                }
            })
        },
        prepend: function() {
            return Ja(this, arguments, function(a) {
                if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
                    var b = Ea(this, a);
                    b.insertBefore(a, b.firstChild)
                }
            })
        },
        before: function() {
            return Ja(this, arguments, function(a) {
                this.parentNode && this.parentNode.insertBefore(a, this)
            })
        },
        after: function() {
            return Ja(this, arguments, function(a) {
                this.parentNode && this.parentNode.insertBefore(a, this.nextSibling)
            })
        },
        empty: function() {
            for (var a, b = 0; null != (a = this[b]); b++) 1 === a.nodeType && (r.cleanData(na(a, !1)), a.textContent = "");
            return this
        },
        clone: function(a, b) {
            return a = null != a && a, b = null == b ? a : b, this.map(function() {
                return r.clone(this, a, b)
            })
        },
        html: function(a) {
            return T(this, function(a) {
                var b = this[0] || {},
                    c = 0,
                    d = this.length;
                if (void 0 === a && 1 === b.nodeType) return b.innerHTML;
                if ("string" == typeof a && !Aa.test(a) && !ma[(ka.exec(a) || ["", ""])[1].toLowerCase()]) {
                    a = r.htmlPrefilter(a);
                    try {
                        for (; c < d; c++) b = this[c] || {}, 1 === b.nodeType && (r.cleanData(na(b, !1)), b.innerHTML = a);
                        b = 0
                    } catch (e) {}
                }
                b && this.empty().append(a)
            }, null, a, arguments.length)
        },
        replaceWith: function() {
            var a = [];
            return Ja(this, arguments, function(b) {
                var c = this.parentNode;
                r.inArray(this, a) < 0 && (r.cleanData(na(this)), c && c.replaceChild(b, this))
            }, a)
        }
    }), r.each({
        appendTo: "append",
        prependTo: "prepend",
        insertBefore: "before",
        insertAfter: "after",
        replaceAll: "replaceWith"
    }, function(a, b) {
        r.fn[a] = function(a) {
            for (var c, d = [], e = r(a), f = e.length - 1, g = 0; g <= f; g++) c = g === f ? this : this.clone(!0), r(e[g])[b](c), h.apply(d, c.get());
            return this.pushStack(d)
        }
    });
    var La = /^margin/,
        Ma = new RegExp("^(" + aa + ")(?!px)[a-z%]+$", "i"),
        Na = function(b) {
            var c = b.ownerDocument.defaultView;
            return c && c.opener || (c = a), c.getComputedStyle(b)
        };
    ! function() {
        function b() {
            if (i) {
                i.style.cssText = "box-sizing:border-box;position:relative;display:block;margin:auto;border:1px;padding:1px;top:1%;width:50%", i.innerHTML = "", ra.appendChild(h);
                var b = a.getComputedStyle(i);
                c = "1%" !== b.top, g = "2px" === b.marginLeft, e = "4px" === b.width, i.style.marginRight = "50%", f = "4px" === b.marginRight, ra.removeChild(h), i = null
            }
        }
        var c, e, f, g, h = d.createElement("div"),
            i = d.createElement("div");
        i.style && (i.style.backgroundClip = "content-box", i.cloneNode(!0).style.backgroundClip = "", o.clearCloneStyle = "content-box" === i.style.backgroundClip, h.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;padding:0;margin-top:1px;position:absolute", h.appendChild(i), r.extend(o, {
            pixelPosition: function() {
                return b(), c
            },
            boxSizingReliable: function() {
                return b(), e
            },
            pixelMarginRight: function() {
                return b(), f
            },
            reliableMarginLeft: function() {
                return b(), g
            }
        }))
    }();

    function Oa(a, b, c) {
        var d, e, f, g, h = a.style;
        return c = c || Na(a), c && (g = c.getPropertyValue(b) || c[b], "" !== g || r.contains(a.ownerDocument, a) || (g = r.style(a, b)), !o.pixelMarginRight() && Ma.test(g) && La.test(b) && (d = h.width, e = h.minWidth, f = h.maxWidth, h.minWidth = h.maxWidth = h.width = g, g = c.width, h.width = d, h.minWidth = e, h.maxWidth = f)), void 0 !== g ? g + "" : g
    }

    function Pa(a, b) {
        return {
            get: function() {
                return a() ? void delete this.get : (this.get = b).apply(this, arguments)
            }
        }
    }
    var Qa = /^(none|table(?!-c[ea]).+)/,
        Ra = /^--/,
        Sa = {
            position: "absolute",
            visibility: "hidden",
            display: "block"
        },
        Ta = {
            letterSpacing: "0",
            fontWeight: "400"
        },
        Ua = ["Webkit", "Moz", "ms"],
        Va = d.createElement("div").style;

    function Wa(a) {
        if (a in Va) return a;
        var b = a[0].toUpperCase() + a.slice(1),
            c = Ua.length;
        while (c--)
            if (a = Ua[c] + b, a in Va) return a
    }

    function Xa(a) {
        var b = r.cssProps[a];
        return b || (b = r.cssProps[a] = Wa(a) || a), b
    }

    function Ya(a, b, c) {
        var d = ba.exec(b);
        return d ? Math.max(0, d[2] - (c || 0)) + (d[3] || "px") : b
    }

    function Za(a, b, c, d, e) {
        var f, g = 0;
        for (f = c === (d ? "border" : "content") ? 4 : "width" === b ? 1 : 0; f < 4; f += 2) "margin" === c && (g += r.css(a, c + ca[f], !0, e)), d ? ("content" === c && (g -= r.css(a, "padding" + ca[f], !0, e)), "margin" !== c && (g -= r.css(a, "border" + ca[f] + "Width", !0, e))) : (g += r.css(a, "padding" + ca[f], !0, e), "padding" !== c && (g += r.css(a, "border" + ca[f] + "Width", !0, e)));
        return g
    }

    function $a(a, b, c) {
        var d, e = Na(a),
            f = Oa(a, b, e),
            g = "border-box" === r.css(a, "boxSizing", !1, e);
        return Ma.test(f) ? f : (d = g && (o.boxSizingReliable() || f === a.style[b]), "auto" === f && (f = a["offset" + b[0].toUpperCase() + b.slice(1)]), f = parseFloat(f) || 0, f + Za(a, b, c || (g ? "border" : "content"), d, e) + "px")
    }
    r.extend({
        cssHooks: {
            opacity: {
                get: function(a, b) {
                    if (b) {
                        var c = Oa(a, "opacity");
                        return "" === c ? "1" : c
                    }
                }
            }
        },
        cssNumber: {
            animationIterationCount: !0,
            columnCount: !0,
            fillOpacity: !0,
            flexGrow: !0,
            flexShrink: !0,
            fontWeight: !0,
            lineHeight: !0,
            opacity: !0,
            order: !0,
            orphans: !0,
            widows: !0,
            zIndex: !0,
            zoom: !0
        },
        cssProps: {
            "float": "cssFloat"
        },
        style: function(a, b, c, d) {
            if (a && 3 !== a.nodeType && 8 !== a.nodeType && a.style) {
                var e, f, g, h = r.camelCase(b),
                    i = Ra.test(b),
                    j = a.style;
                return i || (b = Xa(h)), g = r.cssHooks[b] || r.cssHooks[h], void 0 === c ? g && "get" in g && void 0 !== (e = g.get(a, !1, d)) ? e : j[b] : (f = typeof c, "string" === f && (e = ba.exec(c)) && e[1] && (c = fa(a, b, e), f = "number"), null != c && c === c && ("number" === f && (c += e && e[3] || (r.cssNumber[h] ? "" : "px")), o.clearCloneStyle || "" !== c || 0 !== b.indexOf("background") || (j[b] = "inherit"), g && "set" in g && void 0 === (c = g.set(a, c, d)) || (i ? j.setProperty(b, c) : j[b] = c)), void 0)
            }
        },
        css: function(a, b, c, d) {
            var e, f, g, h = r.camelCase(b),
                i = Ra.test(b);
            return i || (b = Xa(h)), g = r.cssHooks[b] || r.cssHooks[h], g && "get" in g && (e = g.get(a, !0, c)), void 0 === e && (e = Oa(a, b, d)), "normal" === e && b in Ta && (e = Ta[b]), "" === c || c ? (f = parseFloat(e), c === !0 || isFinite(f) ? f || 0 : e) : e
        }
    }), r.each(["height", "width"], function(a, b) {
        r.cssHooks[b] = {
            get: function(a, c, d) {
                if (c) return !Qa.test(r.css(a, "display")) || a.getClientRects().length && a.getBoundingClientRect().width ? $a(a, b, d) : ea(a, Sa, function() {
                    return $a(a, b, d)
                })
            },
            set: function(a, c, d) {
                var e, f = d && Na(a),
                    g = d && Za(a, b, d, "border-box" === r.css(a, "boxSizing", !1, f), f);
                return g && (e = ba.exec(c)) && "px" !== (e[3] || "px") && (a.style[b] = c, c = r.css(a, b)), Ya(a, c, g)
            }
        }
    }), r.cssHooks.marginLeft = Pa(o.reliableMarginLeft, function(a, b) {
        if (b) return (parseFloat(Oa(a, "marginLeft")) || a.getBoundingClientRect().left - ea(a, {
            marginLeft: 0
        }, function() {
            return a.getBoundingClientRect().left
        })) + "px"
    }), r.each({
        margin: "",
        padding: "",
        border: "Width"
    }, function(a, b) {
        r.cssHooks[a + b] = {
            expand: function(c) {
                for (var d = 0, e = {}, f = "string" == typeof c ? c.split(" ") : [c]; d < 4; d++) e[a + ca[d] + b] = f[d] || f[d - 2] || f[0];
                return e
            }
        }, La.test(a) || (r.cssHooks[a + b].set = Ya)
    }), r.fn.extend({
        css: function(a, b) {
            return T(this, function(a, b, c) {
                var d, e, f = {},
                    g = 0;
                if (Array.isArray(b)) {
                    for (d = Na(a), e = b.length; g < e; g++) f[b[g]] = r.css(a, b[g], !1, d);
                    return f
                }
                return void 0 !== c ? r.style(a, b, c) : r.css(a, b)
            }, a, b, arguments.length > 1)
        }
    });

    function _a(a, b, c, d, e) {
        return new _a.prototype.init(a, b, c, d, e)
    }
    r.Tween = _a, _a.prototype = {
        constructor: _a,
        init: function(a, b, c, d, e, f) {
            this.elem = a, this.prop = c, this.easing = e || r.easing._default, this.options = b, this.start = this.now = this.cur(), this.end = d, this.unit = f || (r.cssNumber[c] ? "" : "px")
        },
        cur: function() {
            var a = _a.propHooks[this.prop];
            return a && a.get ? a.get(this) : _a.propHooks._default.get(this)
        },
        run: function(a) {
            var b, c = _a.propHooks[this.prop];
            return this.options.duration ? this.pos = b = r.easing[this.easing](a, this.options.duration * a, 0, 1, this.options.duration) : this.pos = b = a, this.now = (this.end - this.start) * b + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), c && c.set ? c.set(this) : _a.propHooks._default.set(this), this
        }
    }, _a.prototype.init.prototype = _a.prototype, _a.propHooks = {
        _default: {
            get: function(a) {
                var b;
                return 1 !== a.elem.nodeType || null != a.elem[a.prop] && null == a.elem.style[a.prop] ? a.elem[a.prop] : (b = r.css(a.elem, a.prop, ""), b && "auto" !== b ? b : 0)
            },
            set: function(a) {
                r.fx.step[a.prop] ? r.fx.step[a.prop](a) : 1 !== a.elem.nodeType || null == a.elem.style[r.cssProps[a.prop]] && !r.cssHooks[a.prop] ? a.elem[a.prop] = a.now : r.style(a.elem, a.prop, a.now + a.unit)
            }
        }
    }, _a.propHooks.scrollTop = _a.propHooks.scrollLeft = {
        set: function(a) {
            a.elem.nodeType && a.elem.parentNode && (a.elem[a.prop] = a.now)
        }
    }, r.easing = {
        linear: function(a) {
            return a
        },
        swing: function(a) {
            return .5 - Math.cos(a * Math.PI) / 2
        },
        _default: "swing"
    }, r.fx = _a.prototype.init, r.fx.step = {};
    var ab, bb, cb = /^(?:toggle|show|hide)$/,
        db = /queueHooks$/;

    function eb() {
        bb && (d.hidden === !1 && a.requestAnimationFrame ? a.requestAnimationFrame(eb) : a.setTimeout(eb, r.fx.interval), r.fx.tick())
    }

    function fb() {
        return a.setTimeout(function() {
            ab = void 0
        }), ab = r.now()
    }

    function gb(a, b) {
        var c, d = 0,
            e = {
                height: a
            };
        for (b = b ? 1 : 0; d < 4; d += 2 - b) c = ca[d], e["margin" + c] = e["padding" + c] = a;
        return b && (e.opacity = e.width = a), e
    }

    function hb(a, b, c) {
        for (var d, e = (kb.tweeners[b] || []).concat(kb.tweeners["*"]), f = 0, g = e.length; f < g; f++)
            if (d = e[f].call(c, b, a)) return d
    }

    function ib(a, b, c) {
        var d, e, f, g, h, i, j, k, l = "width" in b || "height" in b,
            m = this,
            n = {},
            o = a.style,
            p = a.nodeType && da(a),
            q = W.get(a, "fxshow");
        c.queue || (g = r._queueHooks(a, "fx"), null == g.unqueued && (g.unqueued = 0, h = g.empty.fire, g.empty.fire = function() {
            g.unqueued || h()
        }), g.unqueued++, m.always(function() {
            m.always(function() {
                g.unqueued--, r.queue(a, "fx").length || g.empty.fire()
            })
        }));
        for (d in b)
            if (e = b[d], cb.test(e)) {
                if (delete b[d], f = f || "toggle" === e, e === (p ? "hide" : "show")) {
                    if ("show" !== e || !q || void 0 === q[d]) continue;
                    p = !0
                }
                n[d] = q && q[d] || r.style(a, d)
            }
        if (i = !r.isEmptyObject(b), i || !r.isEmptyObject(n)) {
            l && 1 === a.nodeType && (c.overflow = [o.overflow, o.overflowX, o.overflowY], j = q && q.display, null == j && (j = W.get(a, "display")), k = r.css(a, "display"), "none" === k && (j ? k = j : (ia([a], !0), j = a.style.display || j, k = r.css(a, "display"), ia([a]))), ("inline" === k || "inline-block" === k && null != j) && "none" === r.css(a, "float") && (i || (m.done(function() {
                o.display = j
            }), null == j && (k = o.display, j = "none" === k ? "" : k)), o.display = "inline-block")), c.overflow && (o.overflow = "hidden", m.always(function() {
                o.overflow = c.overflow[0], o.overflowX = c.overflow[1], o.overflowY = c.overflow[2]
            })), i = !1;
            for (d in n) i || (q ? "hidden" in q && (p = q.hidden) : q = W.access(a, "fxshow", {
                display: j
            }), f && (q.hidden = !p), p && ia([a], !0), m.done(function() {
                p || ia([a]), W.remove(a, "fxshow");
                for (d in n) r.style(a, d, n[d])
            })), i = hb(p ? q[d] : 0, d, m), d in q || (q[d] = i.start, p && (i.end = i.start, i.start = 0))
        }
    }

    function jb(a, b) {
        var c, d, e, f, g;
        for (c in a)
            if (d = r.camelCase(c), e = b[d], f = a[c], Array.isArray(f) && (e = f[1], f = a[c] = f[0]), c !== d && (a[d] = f, delete a[c]), g = r.cssHooks[d], g && "expand" in g) {
                f = g.expand(f), delete a[d];
                for (c in f) c in a || (a[c] = f[c], b[c] = e)
            } else b[d] = e
    }

    function kb(a, b, c) {
        var d, e, f = 0,
            g = kb.prefilters.length,
            h = r.Deferred().always(function() {
                delete i.elem
            }),
            i = function() {
                if (e) return !1;
                for (var b = ab || fb(), c = Math.max(0, j.startTime + j.duration - b), d = c / j.duration || 0, f = 1 - d, g = 0, i = j.tweens.length; g < i; g++) j.tweens[g].run(f);
                return h.notifyWith(a, [j, f, c]), f < 1 && i ? c : (i || h.notifyWith(a, [j, 1, 0]), h.resolveWith(a, [j]), !1)
            },
            j = h.promise({
                elem: a,
                props: r.extend({}, b),
                opts: r.extend(!0, {
                    specialEasing: {},
                    easing: r.easing._default
                }, c),
                originalProperties: b,
                originalOptions: c,
                startTime: ab || fb(),
                duration: c.duration,
                tweens: [],
                createTween: function(b, c) {
                    var d = r.Tween(a, j.opts, b, c, j.opts.specialEasing[b] || j.opts.easing);
                    return j.tweens.push(d), d
                },
                stop: function(b) {
                    var c = 0,
                        d = b ? j.tweens.length : 0;
                    if (e) return this;
                    for (e = !0; c < d; c++) j.tweens[c].run(1);
                    return b ? (h.notifyWith(a, [j, 1, 0]), h.resolveWith(a, [j, b])) : h.rejectWith(a, [j, b]), this
                }
            }),
            k = j.props;
        for (jb(k, j.opts.specialEasing); f < g; f++)
            if (d = kb.prefilters[f].call(j, a, k, j.opts)) return r.isFunction(d.stop) && (r._queueHooks(j.elem, j.opts.queue).stop = r.proxy(d.stop, d)), d;
        return r.map(k, hb, j), r.isFunction(j.opts.start) && j.opts.start.call(a, j), j.progress(j.opts.progress).done(j.opts.done, j.opts.complete).fail(j.opts.fail).always(j.opts.always), r.fx.timer(r.extend(i, {
            elem: a,
            anim: j,
            queue: j.opts.queue
        })), j
    }
    r.Animation = r.extend(kb, {
            tweeners: {
                "*": [function(a, b) {
                    var c = this.createTween(a, b);
                    return fa(c.elem, a, ba.exec(b), c), c
                }]
            },
            tweener: function(a, b) {
                r.isFunction(a) ? (b = a, a = ["*"]) : a = a.match(L);
                for (var c, d = 0, e = a.length; d < e; d++) c = a[d], kb.tweeners[c] = kb.tweeners[c] || [], kb.tweeners[c].unshift(b)
            },
            prefilters: [ib],
            prefilter: function(a, b) {
                b ? kb.prefilters.unshift(a) : kb.prefilters.push(a)
            }
        }), r.speed = function(a, b, c) {
            var d = a && "object" == typeof a ? r.extend({}, a) : {
                complete: c || !c && b || r.isFunction(a) && a,
                duration: a,
                easing: c && b || b && !r.isFunction(b) && b
            };
            return r.fx.off ? d.duration = 0 : "number" != typeof d.duration && (d.duration in r.fx.speeds ? d.duration = r.fx.speeds[d.duration] : d.duration = r.fx.speeds._default), null != d.queue && d.queue !== !0 || (d.queue = "fx"), d.old = d.complete, d.complete = function() {
                r.isFunction(d.old) && d.old.call(this), d.queue && r.dequeue(this, d.queue)
            }, d
        }, r.fn.extend({
            fadeTo: function(a, b, c, d) {
                return this.filter(da).css("opacity", 0).show().end().animate({
                    opacity: b
                }, a, c, d)
            },
            animate: function(a, b, c, d) {
                var e = r.isEmptyObject(a),
                    f = r.speed(b, c, d),
                    g = function() {
                        var b = kb(this, r.extend({}, a), f);
                        (e || W.get(this, "finish")) && b.stop(!0)
                    };
                return g.finish = g, e || f.queue === !1 ? this.each(g) : this.queue(f.queue, g)
            },
            stop: function(a, b, c) {
                var d = function(a) {
                    var b = a.stop;
                    delete a.stop, b(c)
                };
                return "string" != typeof a && (c = b, b = a, a = void 0), b && a !== !1 && this.queue(a || "fx", []), this.each(function() {
                    var b = !0,
                        e = null != a && a + "queueHooks",
                        f = r.timers,
                        g = W.get(this);
                    if (e) g[e] && g[e].stop && d(g[e]);
                    else
                        for (e in g) g[e] && g[e].stop && db.test(e) && d(g[e]);
                    for (e = f.length; e--;) f[e].elem !== this || null != a && f[e].queue !== a || (f[e].anim.stop(c), b = !1, f.splice(e, 1));
                    !b && c || r.dequeue(this, a)
                })
            },
            finish: function(a) {
                return a !== !1 && (a = a || "fx"), this.each(function() {
                    var b, c = W.get(this),
                        d = c[a + "queue"],
                        e = c[a + "queueHooks"],
                        f = r.timers,
                        g = d ? d.length : 0;
                    for (c.finish = !0, r.queue(this, a, []), e && e.stop && e.stop.call(this, !0), b = f.length; b--;) f[b].elem === this && f[b].queue === a && (f[b].anim.stop(!0), f.splice(b, 1));
                    for (b = 0; b < g; b++) d[b] && d[b].finish && d[b].finish.call(this);
                    delete c.finish
                })
            }
        }), r.each(["toggle", "show", "hide"], function(a, b) {
            var c = r.fn[b];
            r.fn[b] = function(a, d, e) {
                return null == a || "boolean" == typeof a ? c.apply(this, arguments) : this.animate(gb(b, !0), a, d, e)
            }
        }), r.each({
            slideDown: gb("show"),
            slideUp: gb("hide"),
            slideToggle: gb("toggle"),
            fadeIn: {
                opacity: "show"
            },
            fadeOut: {
                opacity: "hide"
            },
            fadeToggle: {
                opacity: "toggle"
            }
        }, function(a, b) {
            r.fn[a] = function(a, c, d) {
                return this.animate(b, a, c, d)
            }
        }), r.timers = [], r.fx.tick = function() {
            var a, b = 0,
                c = r.timers;
            for (ab = r.now(); b < c.length; b++) a = c[b], a() || c[b] !== a || c.splice(b--, 1);
            c.length || r.fx.stop(), ab = void 0
        }, r.fx.timer = function(a) {
            r.timers.push(a), r.fx.start()
        }, r.fx.interval = 13, r.fx.start = function() {
            bb || (bb = !0, eb())
        }, r.fx.stop = function() {
            bb = null
        }, r.fx.speeds = {
            slow: 600,
            fast: 200,
            _default: 400
        }, r.fn.delay = function(b, c) {
            return b = r.fx ? r.fx.speeds[b] || b : b, c = c || "fx", this.queue(c, function(c, d) {
                var e = a.setTimeout(c, b);
                d.stop = function() {
                    a.clearTimeout(e)
                }
            })
        },
        function() {
            var a = d.createElement("input"),
                b = d.createElement("select"),
                c = b.appendChild(d.createElement("option"));
            a.type = "checkbox", o.checkOn = "" !== a.value, o.optSelected = c.selected, a = d.createElement("input"), a.value = "t", a.type = "radio", o.radioValue = "t" === a.value
        }();
    var lb, mb = r.expr.attrHandle;
    r.fn.extend({
        attr: function(a, b) {
            return T(this, r.attr, a, b, arguments.length > 1)
        },
        removeAttr: function(a) {
            return this.each(function() {
                r.removeAttr(this, a)
            })
        }
    }), r.extend({
        attr: function(a, b, c) {
            var d, e, f = a.nodeType;
            if (3 !== f && 8 !== f && 2 !== f) return "undefined" == typeof a.getAttribute ? r.prop(a, b, c) : (1 === f && r.isXMLDoc(a) || (e = r.attrHooks[b.toLowerCase()] || (r.expr.match.bool.test(b) ? lb : void 0)), void 0 !== c ? null === c ? void r.removeAttr(a, b) : e && "set" in e && void 0 !== (d = e.set(a, c, b)) ? d : (a.setAttribute(b, c + ""), c) : e && "get" in e && null !== (d = e.get(a, b)) ? d : (d = r.find.attr(a, b),
                null == d ? void 0 : d))
        },
        attrHooks: {
            type: {
                set: function(a, b) {
                    if (!o.radioValue && "radio" === b && B(a, "input")) {
                        var c = a.value;
                        return a.setAttribute("type", b), c && (a.value = c), b
                    }
                }
            }
        },
        removeAttr: function(a, b) {
            var c, d = 0,
                e = b && b.match(L);
            if (e && 1 === a.nodeType)
                while (c = e[d++]) a.removeAttribute(c)
        }
    }), lb = {
        set: function(a, b, c) {
            return b === !1 ? r.removeAttr(a, c) : a.setAttribute(c, c), c
        }
    }, r.each(r.expr.match.bool.source.match(/\w+/g), function(a, b) {
        var c = mb[b] || r.find.attr;
        mb[b] = function(a, b, d) {
            var e, f, g = b.toLowerCase();
            return d || (f = mb[g], mb[g] = e, e = null != c(a, b, d) ? g : null, mb[g] = f), e
        }
    });
    var nb = /^(?:input|select|textarea|button)$/i,
        ob = /^(?:a|area)$/i;
    r.fn.extend({
        prop: function(a, b) {
            return T(this, r.prop, a, b, arguments.length > 1)
        },
        removeProp: function(a) {
            return this.each(function() {
                delete this[r.propFix[a] || a]
            })
        }
    }), r.extend({
        prop: function(a, b, c) {
            var d, e, f = a.nodeType;
            if (3 !== f && 8 !== f && 2 !== f) return 1 === f && r.isXMLDoc(a) || (b = r.propFix[b] || b, e = r.propHooks[b]), void 0 !== c ? e && "set" in e && void 0 !== (d = e.set(a, c, b)) ? d : a[b] = c : e && "get" in e && null !== (d = e.get(a, b)) ? d : a[b]
        },
        propHooks: {
            tabIndex: {
                get: function(a) {
                    var b = r.find.attr(a, "tabindex");
                    return b ? parseInt(b, 10) : nb.test(a.nodeName) || ob.test(a.nodeName) && a.href ? 0 : -1
                }
            }
        },
        propFix: {
            "for": "htmlFor",
            "class": "className"
        }
    }), o.optSelected || (r.propHooks.selected = {
        get: function(a) {
            var b = a.parentNode;
            return b && b.parentNode && b.parentNode.selectedIndex, null
        },
        set: function(a) {
            var b = a.parentNode;
            b && (b.selectedIndex, b.parentNode && b.parentNode.selectedIndex)
        }
    }), r.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function() {
        r.propFix[this.toLowerCase()] = this
    });

    function pb(a) {
        var b = a.match(L) || [];
        return b.join(" ")
    }

    function qb(a) {
        return a.getAttribute && a.getAttribute("class") || ""
    }
    r.fn.extend({
        addClass: function(a) {
            var b, c, d, e, f, g, h, i = 0;
            if (r.isFunction(a)) return this.each(function(b) {
                r(this).addClass(a.call(this, b, qb(this)))
            });
            if ("string" == typeof a && a) {
                b = a.match(L) || [];
                while (c = this[i++])
                    if (e = qb(c), d = 1 === c.nodeType && " " + pb(e) + " ") {
                        g = 0;
                        while (f = b[g++]) d.indexOf(" " + f + " ") < 0 && (d += f + " ");
                        h = pb(d), e !== h && c.setAttribute("class", h)
                    }
            }
            return this
        },
        removeClass: function(a) {
            var b, c, d, e, f, g, h, i = 0;
            if (r.isFunction(a)) return this.each(function(b) {
                r(this).removeClass(a.call(this, b, qb(this)))
            });
            if (!arguments.length) return this.attr("class", "");
            if ("string" == typeof a && a) {
                b = a.match(L) || [];
                while (c = this[i++])
                    if (e = qb(c), d = 1 === c.nodeType && " " + pb(e) + " ") {
                        g = 0;
                        while (f = b[g++])
                            while (d.indexOf(" " + f + " ") > -1) d = d.replace(" " + f + " ", " ");
                        h = pb(d), e !== h && c.setAttribute("class", h)
                    }
            }
            return this
        },
        toggleClass: function(a, b) {
            var c = typeof a;
            return "boolean" == typeof b && "string" === c ? b ? this.addClass(a) : this.removeClass(a) : r.isFunction(a) ? this.each(function(c) {
                r(this).toggleClass(a.call(this, c, qb(this), b), b)
            }) : this.each(function() {
                var b, d, e, f;
                if ("string" === c) {
                    d = 0, e = r(this), f = a.match(L) || [];
                    while (b = f[d++]) e.hasClass(b) ? e.removeClass(b) : e.addClass(b)
                } else void 0 !== a && "boolean" !== c || (b = qb(this), b && W.set(this, "__className__", b), this.setAttribute && this.setAttribute("class", b || a === !1 ? "" : W.get(this, "__className__") || ""))
            })
        },
        hasClass: function(a) {
            var b, c, d = 0;
            b = " " + a + " ";
            while (c = this[d++])
                if (1 === c.nodeType && (" " + pb(qb(c)) + " ").indexOf(b) > -1) return !0;
            return !1
        }
    });
    var rb = /\r/g;
    r.fn.extend({
        val: function(a) {
            var b, c, d, e = this[0]; {
                if (arguments.length) return d = r.isFunction(a), this.each(function(c) {
                    var e;
                    1 === this.nodeType && (e = d ? a.call(this, c, r(this).val()) : a, null == e ? e = "" : "number" == typeof e ? e += "" : Array.isArray(e) && (e = r.map(e, function(a) {
                        return null == a ? "" : a + ""
                    })), b = r.valHooks[this.type] || r.valHooks[this.nodeName.toLowerCase()], b && "set" in b && void 0 !== b.set(this, e, "value") || (this.value = e))
                });
                if (e) return b = r.valHooks[e.type] || r.valHooks[e.nodeName.toLowerCase()], b && "get" in b && void 0 !== (c = b.get(e, "value")) ? c : (c = e.value, "string" == typeof c ? c.replace(rb, "") : null == c ? "" : c)
            }
        }
    }), r.extend({
        valHooks: {
            option: {
                get: function(a) {
                    var b = r.find.attr(a, "value");
                    return null != b ? b : pb(r.text(a))
                }
            },
            select: {
                get: function(a) {
                    var b, c, d, e = a.options,
                        f = a.selectedIndex,
                        g = "select-one" === a.type,
                        h = g ? null : [],
                        i = g ? f + 1 : e.length;
                    for (d = f < 0 ? i : g ? f : 0; d < i; d++)
                        if (c = e[d], (c.selected || d === f) && !c.disabled && (!c.parentNode.disabled || !B(c.parentNode, "optgroup"))) {
                            if (b = r(c).val(), g) return b;
                            h.push(b)
                        }
                    return h
                },
                set: function(a, b) {
                    var c, d, e = a.options,
                        f = r.makeArray(b),
                        g = e.length;
                    while (g--) d = e[g], (d.selected = r.inArray(r.valHooks.option.get(d), f) > -1) && (c = !0);
                    return c || (a.selectedIndex = -1), f
                }
            }
        }
    }), r.each(["radio", "checkbox"], function() {
        r.valHooks[this] = {
            set: function(a, b) {
                if (Array.isArray(b)) return a.checked = r.inArray(r(a).val(), b) > -1
            }
        }, o.checkOn || (r.valHooks[this].get = function(a) {
            return null === a.getAttribute("value") ? "on" : a.value
        })
    });
    var sb = /^(?:focusinfocus|focusoutblur)$/;
    r.extend(r.event, {
        trigger: function(b, c, e, f) {
            var g, h, i, j, k, m, n, o = [e || d],
                p = l.call(b, "type") ? b.type : b,
                q = l.call(b, "namespace") ? b.namespace.split(".") : [];
            if (h = i = e = e || d, 3 !== e.nodeType && 8 !== e.nodeType && !sb.test(p + r.event.triggered) && (p.indexOf(".") > -1 && (q = p.split("."), p = q.shift(), q.sort()), k = p.indexOf(":") < 0 && "on" + p, b = b[r.expando] ? b : new r.Event(p, "object" == typeof b && b), b.isTrigger = f ? 2 : 3, b.namespace = q.join("."), b.rnamespace = b.namespace ? new RegExp("(^|\\.)" + q.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, b.result = void 0, b.target || (b.target = e), c = null == c ? [b] : r.makeArray(c, [b]), n = r.event.special[p] || {}, f || !n.trigger || n.trigger.apply(e, c) !== !1)) {
                if (!f && !n.noBubble && !r.isWindow(e)) {
                    for (j = n.delegateType || p, sb.test(j + p) || (h = h.parentNode); h; h = h.parentNode) o.push(h), i = h;
                    i === (e.ownerDocument || d) && o.push(i.defaultView || i.parentWindow || a)
                }
                g = 0;
                while ((h = o[g++]) && !b.isPropagationStopped()) b.type = g > 1 ? j : n.bindType || p, m = (W.get(h, "events") || {})[b.type] && W.get(h, "handle"), m && m.apply(h, c), m = k && h[k], m && m.apply && U(h) && (b.result = m.apply(h, c), b.result === !1 && b.preventDefault());
                return b.type = p, f || b.isDefaultPrevented() || n._default && n._default.apply(o.pop(), c) !== !1 || !U(e) || k && r.isFunction(e[p]) && !r.isWindow(e) && (i = e[k], i && (e[k] = null), r.event.triggered = p, e[p](), r.event.triggered = void 0, i && (e[k] = i)), b.result
            }
        },
        simulate: function(a, b, c) {
            var d = r.extend(new r.Event, c, {
                type: a,
                isSimulated: !0
            });
            r.event.trigger(d, null, b)
        }
    }), r.fn.extend({
        trigger: function(a, b) {
            return this.each(function() {
                r.event.trigger(a, b, this)
            })
        },
        triggerHandler: function(a, b) {
            var c = this[0];
            if (c) return r.event.trigger(a, b, c, !0)
        }
    }), r.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "), function(a, b) {
        r.fn[b] = function(a, c) {
            return arguments.length > 0 ? this.on(b, null, a, c) : this.trigger(b)
        }
    }), r.fn.extend({
        hover: function(a, b) {
            return this.mouseenter(a).mouseleave(b || a)
        }
    }), o.focusin = "onfocusin" in a, o.focusin || r.each({
        focus: "focusin",
        blur: "focusout"
    }, function(a, b) {
        var c = function(a) {
            r.event.simulate(b, a.target, r.event.fix(a))
        };
        r.event.special[b] = {
            setup: function() {
                var d = this.ownerDocument || this,
                    e = W.access(d, b);
                e || d.addEventListener(a, c, !0), W.access(d, b, (e || 0) + 1)
            },
            teardown: function() {
                var d = this.ownerDocument || this,
                    e = W.access(d, b) - 1;
                e ? W.access(d, b, e) : (d.removeEventListener(a, c, !0), W.remove(d, b))
            }
        }
    });
    var tb = a.location,
        ub = r.now(),
        vb = /\?/;
    r.parseXML = function(b) {
        var c;
        if (!b || "string" != typeof b) return null;
        try {
            c = (new a.DOMParser).parseFromString(b, "text/xml")
        } catch (d) {
            c = void 0
        }
        return c && !c.getElementsByTagName("parsererror").length || r.error("Invalid XML: " + b), c
    };
    var wb = /\[\]$/,
        xb = /\r?\n/g,
        yb = /^(?:submit|button|image|reset|file)$/i,
        zb = /^(?:input|select|textarea|keygen)/i;

    function Ab(a, b, c, d) {
        var e;
        if (Array.isArray(b)) r.each(b, function(b, e) {
            c || wb.test(a) ? d(a, e) : Ab(a + "[" + ("object" == typeof e && null != e ? b : "") + "]", e, c, d)
        });
        else if (c || "object" !== r.type(b)) d(a, b);
        else
            for (e in b) Ab(a + "[" + e + "]", b[e], c, d)
    }
    r.param = function(a, b) {
        var c, d = [],
            e = function(a, b) {
                var c = r.isFunction(b) ? b() : b;
                d[d.length] = encodeURIComponent(a) + "=" + encodeURIComponent(null == c ? "" : c)
            };
        if (Array.isArray(a) || a.jquery && !r.isPlainObject(a)) r.each(a, function() {
            e(this.name, this.value)
        });
        else
            for (c in a) Ab(c, a[c], b, e);
        return d.join("&")
    }, r.fn.extend({
        serialize: function() {
            return r.param(this.serializeArray())
        },
        serializeArray: function() {
            return this.map(function() {
                var a = r.prop(this, "elements");
                return a ? r.makeArray(a) : this
            }).filter(function() {
                var a = this.type;
                return this.name && !r(this).is(":disabled") && zb.test(this.nodeName) && !yb.test(a) && (this.checked || !ja.test(a))
            }).map(function(a, b) {
                var c = r(this).val();
                return null == c ? null : Array.isArray(c) ? r.map(c, function(a) {
                    return {
                        name: b.name,
                        value: a.replace(xb, "\r\n")
                    }
                }) : {
                    name: b.name,
                    value: c.replace(xb, "\r\n")
                }
            }).get()
        }
    });
    var Bb = /%20/g,
        Cb = /#.*$/,
        Db = /([?&])_=[^&]*/,
        Eb = /^(.*?):[ \t]*([^\r\n]*)$/gm,
        Fb = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
        Gb = /^(?:GET|HEAD)$/,
        Hb = /^\/\//,
        Ib = {},
        Jb = {},
        Kb = "*/".concat("*"),
        Lb = d.createElement("a");
    Lb.href = tb.href;

    function Mb(a) {
        return function(b, c) {
            "string" != typeof b && (c = b, b = "*");
            var d, e = 0,
                f = b.toLowerCase().match(L) || [];
            if (r.isFunction(c))
                while (d = f[e++]) "+" === d[0] ? (d = d.slice(1) || "*", (a[d] = a[d] || []).unshift(c)) : (a[d] = a[d] || []).push(c)
        }
    }

    function Nb(a, b, c, d) {
        var e = {},
            f = a === Jb;

        function g(h) {
            var i;
            return e[h] = !0, r.each(a[h] || [], function(a, h) {
                var j = h(b, c, d);
                return "string" != typeof j || f || e[j] ? f ? !(i = j) : void 0 : (b.dataTypes.unshift(j), g(j), !1)
            }), i
        }
        return g(b.dataTypes[0]) || !e["*"] && g("*")
    }

    function Ob(a, b) {
        var c, d, e = r.ajaxSettings.flatOptions || {};
        for (c in b) void 0 !== b[c] && ((e[c] ? a : d || (d = {}))[c] = b[c]);
        return d && r.extend(!0, a, d), a
    }

    function Pb(a, b, c) {
        var d, e, f, g, h = a.contents,
            i = a.dataTypes;
        while ("*" === i[0]) i.shift(), void 0 === d && (d = a.mimeType || b.getResponseHeader("Content-Type"));
        if (d)
            for (e in h)
                if (h[e] && h[e].test(d)) {
                    i.unshift(e);
                    break
                }
        if (i[0] in c) f = i[0];
        else {
            for (e in c) {
                if (!i[0] || a.converters[e + " " + i[0]]) {
                    f = e;
                    break
                }
                g || (g = e)
            }
            f = f || g
        }
        if (f) return f !== i[0] && i.unshift(f), c[f]
    }

    function Qb(a, b, c, d) {
        var e, f, g, h, i, j = {},
            k = a.dataTypes.slice();
        if (k[1])
            for (g in a.converters) j[g.toLowerCase()] = a.converters[g];
        f = k.shift();
        while (f)
            if (a.responseFields[f] && (c[a.responseFields[f]] = b), !i && d && a.dataFilter && (b = a.dataFilter(b, a.dataType)), i = f, f = k.shift())
                if ("*" === f) f = i;
                else if ("*" !== i && i !== f) {
            if (g = j[i + " " + f] || j["* " + f], !g)
                for (e in j)
                    if (h = e.split(" "), h[1] === f && (g = j[i + " " + h[0]] || j["* " + h[0]])) {
                        g === !0 ? g = j[e] : j[e] !== !0 && (f = h[0], k.unshift(h[1]));
                        break
                    }
            if (g !== !0)
                if (g && a["throws"]) b = g(b);
                else try {
                    b = g(b)
                } catch (l) {
                    return {
                        state: "parsererror",
                        error: g ? l : "No conversion from " + i + " to " + f
                    }
                }
        }
        return {
            state: "success",
            data: b
        }
    }
    r.extend({
        active: 0,
        lastModified: {},
        etag: {},
        ajaxSettings: {
            url: tb.href,
            type: "GET",
            isLocal: Fb.test(tb.protocol),
            global: !0,
            processData: !0,
            async: !0,
            contentType: "application/x-www-form-urlencoded; charset=UTF-8",
            accepts: {
                "*": Kb,
                text: "text/plain",
                html: "text/html",
                xml: "application/xml, text/xml",
                json: "application/json, text/javascript"
            },
            contents: {
                xml: /\bxml\b/,
                html: /\bhtml/,
                json: /\bjson\b/
            },
            responseFields: {
                xml: "responseXML",
                text: "responseText",
                json: "responseJSON"
            },
            converters: {
                "* text": String,
                "text html": !0,
                "text json": JSON.parse,
                "text xml": r.parseXML
            },
            flatOptions: {
                url: !0,
                context: !0
            }
        },
        ajaxSetup: function(a, b) {
            return b ? Ob(Ob(a, r.ajaxSettings), b) : Ob(r.ajaxSettings, a)
        },
        ajaxPrefilter: Mb(Ib),
        ajaxTransport: Mb(Jb),
        ajax: function(b, c) {
            "object" == typeof b && (c = b, b = void 0), c = c || {};
            var e, f, g, h, i, j, k, l, m, n, o = r.ajaxSetup({}, c),
                p = o.context || o,
                q = o.context && (p.nodeType || p.jquery) ? r(p) : r.event,
                s = r.Deferred(),
                t = r.Callbacks("once memory"),
                u = o.statusCode || {},
                v = {},
                w = {},
                x = "canceled",
                y = {
                    readyState: 0,
                    getResponseHeader: function(a) {
                        var b;
                        if (k) {
                            if (!h) {
                                h = {};
                                while (b = Eb.exec(g)) h[b[1].toLowerCase()] = b[2]
                            }
                            b = h[a.toLowerCase()]
                        }
                        return null == b ? null : b
                    },
                    getAllResponseHeaders: function() {
                        return k ? g : null
                    },
                    setRequestHeader: function(a, b) {
                        return null == k && (a = w[a.toLowerCase()] = w[a.toLowerCase()] || a, v[a] = b), this
                    },
                    overrideMimeType: function(a) {
                        return null == k && (o.mimeType = a), this
                    },
                    statusCode: function(a) {
                        var b;
                        if (a)
                            if (k) y.always(a[y.status]);
                            else
                                for (b in a) u[b] = [u[b], a[b]];
                        return this
                    },
                    abort: function(a) {
                        var b = a || x;
                        return e && e.abort(b), A(0, b), this
                    }
                };
            if (s.promise(y), o.url = ((b || o.url || tb.href) + "").replace(Hb, tb.protocol + "//"), o.type = c.method || c.type || o.method || o.type, o.dataTypes = (o.dataType || "*").toLowerCase().match(L) || [""], null == o.crossDomain) {
                j = d.createElement("a");
                try {
                    j.href = o.url, j.href = j.href, o.crossDomain = Lb.protocol + "//" + Lb.host != j.protocol + "//" + j.host
                } catch (z) {
                    o.crossDomain = !0
                }
            }
            if (o.data && o.processData && "string" != typeof o.data && (o.data = r.param(o.data, o.traditional)), Nb(Ib, o, c, y), k) return y;
            l = r.event && o.global, l && 0 === r.active++ && r.event.trigger("ajaxStart"), o.type = o.type.toUpperCase(), o.hasContent = !Gb.test(o.type), f = o.url.replace(Cb, ""), o.hasContent ? o.data && o.processData && 0 === (o.contentType || "").indexOf("application/x-www-form-urlencoded") && (o.data = o.data.replace(Bb, "+")) : (n = o.url.slice(f.length), o.data && (f += (vb.test(f) ? "&" : "?") + o.data, delete o.data), o.cache === !1 && (f = f.replace(Db, "$1"), n = (vb.test(f) ? "&" : "?") + "_=" + ub++ + n), o.url = f + n), o.ifModified && (r.lastModified[f] && y.setRequestHeader("If-Modified-Since", r.lastModified[f]), r.etag[f] && y.setRequestHeader("If-None-Match", r.etag[f])), (o.data && o.hasContent && o.contentType !== !1 || c.contentType) && y.setRequestHeader("Content-Type", o.contentType), y.setRequestHeader("Accept", o.dataTypes[0] && o.accepts[o.dataTypes[0]] ? o.accepts[o.dataTypes[0]] + ("*" !== o.dataTypes[0] ? ", " + Kb + "; q=0.01" : "") : o.accepts["*"]);
            for (m in o.headers) y.setRequestHeader(m, o.headers[m]);
            if (o.beforeSend && (o.beforeSend.call(p, y, o) === !1 || k)) return y.abort();
            if (x = "abort", t.add(o.complete), y.done(o.success), y.fail(o.error), e = Nb(Jb, o, c, y)) {
                if (y.readyState = 1, l && q.trigger("ajaxSend", [y, o]), k) return y;
                o.async && o.timeout > 0 && (i = a.setTimeout(function() {
                    y.abort("timeout")
                }, o.timeout));
                try {
                    k = !1, e.send(v, A)
                } catch (z) {
                    if (k) throw z;
                    A(-1, z)
                }
            } else A(-1, "No Transport");

            function A(b, c, d, h) {
                var j, m, n, v, w, x = c;
                k || (k = !0, i && a.clearTimeout(i), e = void 0, g = h || "", y.readyState = b > 0 ? 4 : 0, j = b >= 200 && b < 300 || 304 === b, d && (v = Pb(o, y, d)), v = Qb(o, v, y, j), j ? (o.ifModified && (w = y.getResponseHeader("Last-Modified"), w && (r.lastModified[f] = w), w = y.getResponseHeader("etag"), w && (r.etag[f] = w)), 204 === b || "HEAD" === o.type ? x = "nocontent" : 304 === b ? x = "notmodified" : (x = v.state, m = v.data, n = v.error, j = !n)) : (n = x, !b && x || (x = "error", b < 0 && (b = 0))), y.status = b, y.statusText = (c || x) + "", j ? s.resolveWith(p, [m, x, y]) : s.rejectWith(p, [y, x, n]), y.statusCode(u), u = void 0, l && q.trigger(j ? "ajaxSuccess" : "ajaxError", [y, o, j ? m : n]), t.fireWith(p, [y, x]), l && (q.trigger("ajaxComplete", [y, o]), --r.active || r.event.trigger("ajaxStop")))
            }
            return y
        },
        getJSON: function(a, b, c) {
            return r.get(a, b, c, "json")
        },
        getScript: function(a, b) {
            return r.get(a, void 0, b, "script")
        }
    }), r.each(["get", "post"], function(a, b) {
        r[b] = function(a, c, d, e) {
            return r.isFunction(c) && (e = e || d, d = c, c = void 0), r.ajax(r.extend({
                url: a,
                type: b,
                dataType: e,
                data: c,
                success: d
            }, r.isPlainObject(a) && a))
        }
    }), r._evalUrl = function(a) {
        return r.ajax({
            url: a,
            type: "GET",
            dataType: "script",
            cache: !0,
            async: !1,
            global: !1,
            "throws": !0
        })
    }, r.fn.extend({
        wrapAll: function(a) {
            var b;
            return this[0] && (r.isFunction(a) && (a = a.call(this[0])), b = r(a, this[0].ownerDocument).eq(0).clone(!0), this[0].parentNode && b.insertBefore(this[0]), b.map(function() {
                var a = this;
                while (a.firstElementChild) a = a.firstElementChild;
                return a
            }).append(this)), this
        },
        wrapInner: function(a) {
            return r.isFunction(a) ? this.each(function(b) {
                r(this).wrapInner(a.call(this, b))
            }) : this.each(function() {
                var b = r(this),
                    c = b.contents();
                c.length ? c.wrapAll(a) : b.append(a)
            })
        },
        wrap: function(a) {
            var b = r.isFunction(a);
            return this.each(function(c) {
                r(this).wrapAll(b ? a.call(this, c) : a)
            })
        },
        unwrap: function(a) {
            return this.parent(a).not("body").each(function() {
                r(this).replaceWith(this.childNodes)
            }), this
        }
    }), r.expr.pseudos.hidden = function(a) {
        return !r.expr.pseudos.visible(a)
    }, r.expr.pseudos.visible = function(a) {
        return !!(a.offsetWidth || a.offsetHeight || a.getClientRects().length)
    }, r.ajaxSettings.xhr = function() {
        try {
            return new a.XMLHttpRequest
        } catch (b) {}
    };
    var Rb = {
            0: 200,
            1223: 204
        },
        Sb = r.ajaxSettings.xhr();
    o.cors = !!Sb && "withCredentials" in Sb, o.ajax = Sb = !!Sb, r.ajaxTransport(function(b) {
        var c, d;
        if (o.cors || Sb && !b.crossDomain) return {
            send: function(e, f) {
                var g, h = b.xhr();
                if (h.open(b.type, b.url, b.async, b.username, b.password), b.xhrFields)
                    for (g in b.xhrFields) h[g] = b.xhrFields[g];
                b.mimeType && h.overrideMimeType && h.overrideMimeType(b.mimeType), b.crossDomain || e["X-Requested-With"] || (e["X-Requested-With"] = "XMLHttpRequest");
                for (g in e) h.setRequestHeader(g, e[g]);
                c = function(a) {
                    return function() {
                        c && (c = d = h.onload = h.onerror = h.onabort = h.onreadystatechange = null, "abort" === a ? h.abort() : "error" === a ? "number" != typeof h.status ? f(0, "error") : f(h.status, h.statusText) : f(Rb[h.status] || h.status, h.statusText, "text" !== (h.responseType || "text") || "string" != typeof h.responseText ? {
                            binary: h.response
                        } : {
                            text: h.responseText
                        }, h.getAllResponseHeaders()))
                    }
                }, h.onload = c(), d = h.onerror = c("error"), void 0 !== h.onabort ? h.onabort = d : h.onreadystatechange = function() {
                    4 === h.readyState && a.setTimeout(function() {
                        c && d()
                    })
                }, c = c("abort");
                try {
                    h.send(b.hasContent && b.data || null)
                } catch (i) {
                    if (c) throw i
                }
            },
            abort: function() {
                c && c()
            }
        }
    }), r.ajaxPrefilter(function(a) {
        a.crossDomain && (a.contents.script = !1)
    }), r.ajaxSetup({
        accepts: {
            script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
        },
        contents: {
            script: /\b(?:java|ecma)script\b/
        },
        converters: {
            "text script": function(a) {
                return r.globalEval(a), a
            }
        }
    }), r.ajaxPrefilter("script", function(a) {
        void 0 === a.cache && (a.cache = !1), a.crossDomain && (a.type = "GET")
    }), r.ajaxTransport("script", function(a) {
        if (a.crossDomain) {
            var b, c;
            return {
                send: function(e, f) {
                    b = r("<script>").prop({
                        charset: a.scriptCharset,
                        src: a.url
                    }).on("load error", c = function(a) {
                        b.remove(), c = null, a && f("error" === a.type ? 404 : 200, a.type)
                    }), d.head.appendChild(b[0])
                },
                abort: function() {
                    c && c()
                }
            }
        }
    });
    var Tb = [],
        Ub = /(=)\?(?=&|$)|\?\?/;
    r.ajaxSetup({
        jsonp: "callback",
        jsonpCallback: function() {
            var a = Tb.pop() || r.expando + "_" + ub++;
            return this[a] = !0, a
        }
    }), r.ajaxPrefilter("json jsonp", function(b, c, d) {
        var e, f, g, h = b.jsonp !== !1 && (Ub.test(b.url) ? "url" : "string" == typeof b.data && 0 === (b.contentType || "").indexOf("application/x-www-form-urlencoded") && Ub.test(b.data) && "data");
        if (h || "jsonp" === b.dataTypes[0]) return e = b.jsonpCallback = r.isFunction(b.jsonpCallback) ? b.jsonpCallback() : b.jsonpCallback, h ? b[h] = b[h].replace(Ub, "$1" + e) : b.jsonp !== !1 && (b.url += (vb.test(b.url) ? "&" : "?") + b.jsonp + "=" + e), b.converters["script json"] = function() {
            return g || r.error(e + " was not called"), g[0]
        }, b.dataTypes[0] = "json", f = a[e], a[e] = function() {
            g = arguments
        }, d.always(function() {
            void 0 === f ? r(a).removeProp(e) : a[e] = f, b[e] && (b.jsonpCallback = c.jsonpCallback, Tb.push(e)), g && r.isFunction(f) && f(g[0]), g = f = void 0
        }), "script"
    }), o.createHTMLDocument = function() {
        var a = d.implementation.createHTMLDocument("").body;
        return a.innerHTML = "<form></form><form></form>", 2 === a.childNodes.length
    }(), r.parseHTML = function(a, b, c) {
        if ("string" != typeof a) return [];
        "boolean" == typeof b && (c = b, b = !1);
        var e, f, g;
        return b || (o.createHTMLDocument ? (b = d.implementation.createHTMLDocument(""), e = b.createElement("base"), e.href = d.location.href, b.head.appendChild(e)) : b = d), f = C.exec(a), g = !c && [], f ? [b.createElement(f[1])] : (f = qa([a], b, g), g && g.length && r(g).remove(), r.merge([], f.childNodes))
    }, r.fn.load = function(a, b, c) {
        var d, e, f, g = this,
            h = a.indexOf(" ");
        return h > -1 && (d = pb(a.slice(h)), a = a.slice(0, h)), r.isFunction(b) ? (c = b, b = void 0) : b && "object" == typeof b && (e = "POST"), g.length > 0 && r.ajax({
            url: a,
            type: e || "GET",
            dataType: "html",
            data: b
        }).done(function(a) {
            f = arguments, g.html(d ? r("<div>").append(r.parseHTML(a)).find(d) : a)
        }).always(c && function(a, b) {
            g.each(function() {
                c.apply(this, f || [a.responseText, b, a])
            })
        }), this
    }, r.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function(a, b) {
        r.fn[b] = function(a) {
            return this.on(b, a)
        }
    }), r.expr.pseudos.animated = function(a) {
        return r.grep(r.timers, function(b) {
            return a === b.elem
        }).length
    }, r.offset = {
        setOffset: function(a, b, c) {
            var d, e, f, g, h, i, j, k = r.css(a, "position"),
                l = r(a),
                m = {};
            "static" === k && (a.style.position = "relative"), h = l.offset(), f = r.css(a, "top"), i = r.css(a, "left"), j = ("absolute" === k || "fixed" === k) && (f + i).indexOf("auto") > -1, j ? (d = l.position(), g = d.top, e = d.left) : (g = parseFloat(f) || 0, e = parseFloat(i) || 0), r.isFunction(b) && (b = b.call(a, c, r.extend({}, h))), null != b.top && (m.top = b.top - h.top + g), null != b.left && (m.left = b.left - h.left + e), "using" in b ? b.using.call(a, m) : l.css(m)
        }
    }, r.fn.extend({
        offset: function(a) {
            if (arguments.length) return void 0 === a ? this : this.each(function(b) {
                r.offset.setOffset(this, a, b)
            });
            var b, c, d, e, f = this[0];
            if (f) return f.getClientRects().length ? (d = f.getBoundingClientRect(), b = f.ownerDocument, c = b.documentElement, e = b.defaultView, {
                top: d.top + e.pageYOffset - c.clientTop,
                left: d.left + e.pageXOffset - c.clientLeft
            }) : {
                top: 0,
                left: 0
            }
        },
        position: function() {
            if (this[0]) {
                var a, b, c = this[0],
                    d = {
                        top: 0,
                        left: 0
                    };
                return "fixed" === r.css(c, "position") ? b = c.getBoundingClientRect() : (a = this.offsetParent(), b = this.offset(), B(a[0], "html") || (d = a.offset()), d = {
                    top: d.top + r.css(a[0], "borderTopWidth", !0),
                    left: d.left + r.css(a[0], "borderLeftWidth", !0)
                }), {
                    top: b.top - d.top - r.css(c, "marginTop", !0),
                    left: b.left - d.left - r.css(c, "marginLeft", !0)
                }
            }
        },
        offsetParent: function() {
            return this.map(function() {
                var a = this.offsetParent;
                while (a && "static" === r.css(a, "position")) a = a.offsetParent;
                return a || ra
            })
        }
    }), r.each({
        scrollLeft: "pageXOffset",
        scrollTop: "pageYOffset"
    }, function(a, b) {
        var c = "pageYOffset" === b;
        r.fn[a] = function(d) {
            return T(this, function(a, d, e) {
                var f;
                return r.isWindow(a) ? f = a : 9 === a.nodeType && (f = a.defaultView), void 0 === e ? f ? f[b] : a[d] : void(f ? f.scrollTo(c ? f.pageXOffset : e, c ? e : f.pageYOffset) : a[d] = e)
            }, a, d, arguments.length)
        }
    }), r.each(["top", "left"], function(a, b) {
        r.cssHooks[b] = Pa(o.pixelPosition, function(a, c) {
            if (c) return c = Oa(a, b), Ma.test(c) ? r(a).position()[b] + "px" : c
        })
    }), r.each({
        Height: "height",
        Width: "width"
    }, function(a, b) {
        r.each({
            padding: "inner" + a,
            content: b,
            "": "outer" + a
        }, function(c, d) {
            r.fn[d] = function(e, f) {
                var g = arguments.length && (c || "boolean" != typeof e),
                    h = c || (e === !0 || f === !0 ? "margin" : "border");
                return T(this, function(b, c, e) {
                    var f;
                    return r.isWindow(b) ? 0 === d.indexOf("outer") ? b["inner" + a] : b.document.documentElement["client" + a] : 9 === b.nodeType ? (f = b.documentElement, Math.max(b.body["scroll" + a], f["scroll" + a], b.body["offset" + a], f["offset" + a], f["client" + a])) : void 0 === e ? r.css(b, c, h) : r.style(b, c, e, h)
                }, b, g ? e : void 0, g)
            }
        })
    }), r.fn.extend({
        bind: function(a, b, c) {
            return this.on(a, null, b, c)
        },
        unbind: function(a, b) {
            return this.off(a, null, b)
        },
        delegate: function(a, b, c, d) {
            return this.on(b, a, c, d)
        },
        undelegate: function(a, b, c) {
            return 1 === arguments.length ? this.off(a, "**") : this.off(b, a || "**", c)
        }
    }), r.holdReady = function(a) {
        a ? r.readyWait++ : r.ready(!0)
    }, r.isArray = Array.isArray, r.parseJSON = JSON.parse, r.nodeName = B, "function" == typeof define && define.amd && define("jquery", [], function() {
        return r
    });
    var Vb = a.jQuery,
        Wb = a.$;
    return r.noConflict = function(b) {
        return a.$ === r && (a.$ = Wb), b && a.jQuery === r && (a.jQuery = Vb), r
    }, b || (a.jQuery = a.$ = r), r
});
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiIiwic291cmNlcyI6WyJqcXVlcnkubWluLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBqUXVlcnkgdjMuMi4xIHwgKGMpIEpTIEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9ycyB8IGpxdWVyeS5vcmcvbGljZW5zZSAqLyAhIGZ1bmN0aW9uKGEsIGIpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgXCJvYmplY3RcIiA9PSB0eXBlb2YgbW9kdWxlICYmIFwib2JqZWN0XCIgPT0gdHlwZW9mIG1vZHVsZS5leHBvcnRzID8gbW9kdWxlLmV4cG9ydHMgPSBhLmRvY3VtZW50ID8gYihhLCAhMCkgOiBmdW5jdGlvbihhKSB7XHJcbiAgICAgICAgaWYgKCFhLmRvY3VtZW50KSB0aHJvdyBuZXcgRXJyb3IoXCJqUXVlcnkgcmVxdWlyZXMgYSB3aW5kb3cgd2l0aCBhIGRvY3VtZW50XCIpO1xyXG4gICAgICAgIHJldHVybiBiKGEpXHJcbiAgICB9IDogYihhKVxyXG59KFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIHdpbmRvdyA/IHdpbmRvdyA6IHRoaXMsIGZ1bmN0aW9uKGEsIGIpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgdmFyIGMgPSBbXSxcclxuICAgICAgICBkID0gYS5kb2N1bWVudCxcclxuICAgICAgICBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mLFxyXG4gICAgICAgIGYgPSBjLnNsaWNlLFxyXG4gICAgICAgIGcgPSBjLmNvbmNhdCxcclxuICAgICAgICBoID0gYy5wdXNoLFxyXG4gICAgICAgIGkgPSBjLmluZGV4T2YsXHJcbiAgICAgICAgaiA9IHt9LFxyXG4gICAgICAgIGsgPSBqLnRvU3RyaW5nLFxyXG4gICAgICAgIGwgPSBqLmhhc093blByb3BlcnR5LFxyXG4gICAgICAgIG0gPSBsLnRvU3RyaW5nLFxyXG4gICAgICAgIG4gPSBtLmNhbGwoT2JqZWN0KSxcclxuICAgICAgICBvID0ge307XHJcblxyXG4gICAgZnVuY3Rpb24gcChhLCBiKSB7XHJcbiAgICAgICAgYiA9IGIgfHwgZDtcclxuICAgICAgICB2YXIgYyA9IGIuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcclxuICAgICAgICBjLnRleHQgPSBhLCBiLmhlYWQuYXBwZW5kQ2hpbGQoYykucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjKVxyXG4gICAgfVxyXG4gICAgdmFyIHEgPSBcIjMuMi4xXCIsXHJcbiAgICAgICAgciA9IGZ1bmN0aW9uKGEsIGIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyByLmZuLmluaXQoYSwgYilcclxuICAgICAgICB9LFxyXG4gICAgICAgIHMgPSAvXltcXHNcXHVGRUZGXFx4QTBdK3xbXFxzXFx1RkVGRlxceEEwXSskL2csXHJcbiAgICAgICAgdCA9IC9eLW1zLS8sXHJcbiAgICAgICAgdSA9IC8tKFthLXpdKS9nLFxyXG4gICAgICAgIHYgPSBmdW5jdGlvbihhLCBiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBiLnRvVXBwZXJDYXNlKClcclxuICAgICAgICB9O1xyXG4gICAgci5mbiA9IHIucHJvdG90eXBlID0ge1xyXG4gICAgICAgIGpxdWVyeTogcSxcclxuICAgICAgICBjb25zdHJ1Y3RvcjogcixcclxuICAgICAgICBsZW5ndGg6IDAsXHJcbiAgICAgICAgdG9BcnJheTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmLmNhbGwodGhpcylcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldDogZnVuY3Rpb24oYSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbCA9PSBhID8gZi5jYWxsKHRoaXMpIDogYSA8IDAgPyB0aGlzW2EgKyB0aGlzLmxlbmd0aF0gOiB0aGlzW2FdXHJcbiAgICAgICAgfSxcclxuICAgICAgICBwdXNoU3RhY2s6IGZ1bmN0aW9uKGEpIHtcclxuICAgICAgICAgICAgdmFyIGIgPSByLm1lcmdlKHRoaXMuY29uc3RydWN0b3IoKSwgYSk7XHJcbiAgICAgICAgICAgIHJldHVybiBiLnByZXZPYmplY3QgPSB0aGlzLCBiXHJcbiAgICAgICAgfSxcclxuICAgICAgICBlYWNoOiBmdW5jdGlvbihhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByLmVhY2godGhpcywgYSlcclxuICAgICAgICB9LFxyXG4gICAgICAgIG1hcDogZnVuY3Rpb24oYSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wdXNoU3RhY2soci5tYXAodGhpcywgZnVuY3Rpb24oYiwgYykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGEuY2FsbChiLCBjLCBiKVxyXG4gICAgICAgICAgICB9KSlcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNsaWNlOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKGYuYXBwbHkodGhpcywgYXJndW1lbnRzKSlcclxuICAgICAgICB9LFxyXG4gICAgICAgIGZpcnN0OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXEoMClcclxuICAgICAgICB9LFxyXG4gICAgICAgIGxhc3Q6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lcSgtMSlcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVxOiBmdW5jdGlvbihhKSB7XHJcbiAgICAgICAgICAgIHZhciBiID0gdGhpcy5sZW5ndGgsXHJcbiAgICAgICAgICAgICAgICBjID0gK2EgKyAoYSA8IDAgPyBiIDogMCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnB1c2hTdGFjayhjID49IDAgJiYgYyA8IGIgPyBbdGhpc1tjXV0gOiBbXSlcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVuZDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByZXZPYmplY3QgfHwgdGhpcy5jb25zdHJ1Y3RvcigpXHJcbiAgICAgICAgfSxcclxuICAgICAgICBwdXNoOiBoLFxyXG4gICAgICAgIHNvcnQ6IGMuc29ydCxcclxuICAgICAgICBzcGxpY2U6IGMuc3BsaWNlXHJcbiAgICB9LCByLmV4dGVuZCA9IHIuZm4uZXh0ZW5kID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIGEsIGIsIGMsIGQsIGUsIGYsIGcgPSBhcmd1bWVudHNbMF0gfHwge30sXHJcbiAgICAgICAgICAgIGggPSAxLFxyXG4gICAgICAgICAgICBpID0gYXJndW1lbnRzLmxlbmd0aCxcclxuICAgICAgICAgICAgaiA9ICExO1xyXG4gICAgICAgIGZvciAoXCJib29sZWFuXCIgPT0gdHlwZW9mIGcgJiYgKGogPSBnLCBnID0gYXJndW1lbnRzW2hdIHx8IHt9LCBoKyspLCBcIm9iamVjdFwiID09IHR5cGVvZiBnIHx8IHIuaXNGdW5jdGlvbihnKSB8fCAoZyA9IHt9KSwgaCA9PT0gaSAmJiAoZyA9IHRoaXMsIGgtLSk7IGggPCBpOyBoKyspXHJcbiAgICAgICAgICAgIGlmIChudWxsICE9IChhID0gYXJndW1lbnRzW2hdKSlcclxuICAgICAgICAgICAgICAgIGZvciAoYiBpbiBhKSBjID0gZ1tiXSwgZCA9IGFbYl0sIGcgIT09IGQgJiYgKGogJiYgZCAmJiAoci5pc1BsYWluT2JqZWN0KGQpIHx8IChlID0gQXJyYXkuaXNBcnJheShkKSkpID8gKGUgPyAoZSA9ICExLCBmID0gYyAmJiBBcnJheS5pc0FycmF5KGMpID8gYyA6IFtdKSA6IGYgPSBjICYmIHIuaXNQbGFpbk9iamVjdChjKSA/IGMgOiB7fSwgZ1tiXSA9IHIuZXh0ZW5kKGosIGYsIGQpKSA6IHZvaWQgMCAhPT0gZCAmJiAoZ1tiXSA9IGQpKTtcclxuICAgICAgICByZXR1cm4gZ1xyXG4gICAgfSwgci5leHRlbmQoe1xyXG4gICAgICAgIGV4cGFuZG86IFwialF1ZXJ5XCIgKyAocSArIE1hdGgucmFuZG9tKCkpLnJlcGxhY2UoL1xcRC9nLCBcIlwiKSxcclxuICAgICAgICBpc1JlYWR5OiAhMCxcclxuICAgICAgICBlcnJvcjogZnVuY3Rpb24oYSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYSlcclxuICAgICAgICB9LFxyXG4gICAgICAgIG5vb3A6IGZ1bmN0aW9uKCkge30sXHJcbiAgICAgICAgaXNGdW5jdGlvbjogZnVuY3Rpb24oYSkge1xyXG4gICAgICAgICAgICByZXR1cm4gXCJmdW5jdGlvblwiID09PSByLnR5cGUoYSlcclxuICAgICAgICB9LFxyXG4gICAgICAgIGlzV2luZG93OiBmdW5jdGlvbihhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsICE9IGEgJiYgYSA9PT0gYS53aW5kb3dcclxuICAgICAgICB9LFxyXG4gICAgICAgIGlzTnVtZXJpYzogZnVuY3Rpb24oYSkge1xyXG4gICAgICAgICAgICB2YXIgYiA9IHIudHlwZShhKTtcclxuICAgICAgICAgICAgcmV0dXJuIChcIm51bWJlclwiID09PSBiIHx8IFwic3RyaW5nXCIgPT09IGIpICYmICFpc05hTihhIC0gcGFyc2VGbG9hdChhKSlcclxuICAgICAgICB9LFxyXG4gICAgICAgIGlzUGxhaW5PYmplY3Q6IGZ1bmN0aW9uKGEpIHtcclxuICAgICAgICAgICAgdmFyIGIsIGM7XHJcbiAgICAgICAgICAgIHJldHVybiAhKCFhIHx8IFwiW29iamVjdCBPYmplY3RdXCIgIT09IGsuY2FsbChhKSkgJiYgKCEoYiA9IGUoYSkpIHx8IChjID0gbC5jYWxsKGIsIFwiY29uc3RydWN0b3JcIikgJiYgYi5jb25zdHJ1Y3RvciwgXCJmdW5jdGlvblwiID09IHR5cGVvZiBjICYmIG0uY2FsbChjKSA9PT0gbikpXHJcbiAgICAgICAgfSxcclxuICAgICAgICBpc0VtcHR5T2JqZWN0OiBmdW5jdGlvbihhKSB7XHJcbiAgICAgICAgICAgIHZhciBiO1xyXG4gICAgICAgICAgICBmb3IgKGIgaW4gYSkgcmV0dXJuICExO1xyXG4gICAgICAgICAgICByZXR1cm4gITBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHR5cGU6IGZ1bmN0aW9uKGEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGwgPT0gYSA/IGEgKyBcIlwiIDogXCJvYmplY3RcIiA9PSB0eXBlb2YgYSB8fCBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGEgPyBqW2suY2FsbChhKV0gfHwgXCJvYmplY3RcIiA6IHR5cGVvZiBhXHJcbiAgICAgICAgfSxcclxuICAgICAgICBnbG9iYWxFdmFsOiBmdW5jdGlvbihhKSB7XHJcbiAgICAgICAgICAgIHAoYSlcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNhbWVsQ2FzZTogZnVuY3Rpb24oYSkge1xyXG4gICAgICAgICAgICByZXR1cm4gYS5yZXBsYWNlKHQsIFwibXMtXCIpLnJlcGxhY2UodSwgdilcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVhY2g6IGZ1bmN0aW9uKGEsIGIpIHtcclxuICAgICAgICAgICAgdmFyIGMsIGQgPSAwO1xyXG4gICAgICAgICAgICBpZiAodyhhKSkge1xyXG4gICAgICAgICAgICAgICAgZm9yIChjID0gYS5sZW5ndGg7IGQgPCBjOyBkKyspXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGIuY2FsbChhW2RdLCBkLCBhW2RdKSA9PT0gITEpIGJyZWFrXHJcbiAgICAgICAgICAgIH0gZWxzZVxyXG4gICAgICAgICAgICAgICAgZm9yIChkIGluIGEpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGIuY2FsbChhW2RdLCBkLCBhW2RdKSA9PT0gITEpIGJyZWFrO1xyXG4gICAgICAgICAgICByZXR1cm4gYVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdHJpbTogZnVuY3Rpb24oYSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbCA9PSBhID8gXCJcIiA6IChhICsgXCJcIikucmVwbGFjZShzLCBcIlwiKVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbWFrZUFycmF5OiBmdW5jdGlvbihhLCBiKSB7XHJcbiAgICAgICAgICAgIHZhciBjID0gYiB8fCBbXTtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGwgIT0gYSAmJiAodyhPYmplY3QoYSkpID8gci5tZXJnZShjLCBcInN0cmluZ1wiID09IHR5cGVvZiBhID8gW2FdIDogYSkgOiBoLmNhbGwoYywgYSkpLCBjXHJcbiAgICAgICAgfSxcclxuICAgICAgICBpbkFycmF5OiBmdW5jdGlvbihhLCBiLCBjKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsID09IGIgPyAtMSA6IGkuY2FsbChiLCBhLCBjKVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbWVyZ2U6IGZ1bmN0aW9uKGEsIGIpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgYyA9ICtiLmxlbmd0aCwgZCA9IDAsIGUgPSBhLmxlbmd0aDsgZCA8IGM7IGQrKykgYVtlKytdID0gYltkXTtcclxuICAgICAgICAgICAgcmV0dXJuIGEubGVuZ3RoID0gZSwgYVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ3JlcDogZnVuY3Rpb24oYSwgYiwgYykge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBkLCBlID0gW10sIGYgPSAwLCBnID0gYS5sZW5ndGgsIGggPSAhYzsgZiA8IGc7IGYrKykgZCA9ICFiKGFbZl0sIGYpLCBkICE9PSBoICYmIGUucHVzaChhW2ZdKTtcclxuICAgICAgICAgICAgcmV0dXJuIGVcclxuICAgICAgICB9LFxyXG4gICAgICAgIG1hcDogZnVuY3Rpb24oYSwgYiwgYykge1xyXG4gICAgICAgICAgICB2YXIgZCwgZSwgZiA9IDAsXHJcbiAgICAgICAgICAgICAgICBoID0gW107XHJcbiAgICAgICAgICAgIGlmICh3KGEpKVxyXG4gICAgICAgICAgICAgICAgZm9yIChkID0gYS5sZW5ndGg7IGYgPCBkOyBmKyspIGUgPSBiKGFbZl0sIGYsIGMpLCBudWxsICE9IGUgJiYgaC5wdXNoKGUpO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICBmb3IgKGYgaW4gYSkgZSA9IGIoYVtmXSwgZiwgYyksIG51bGwgIT0gZSAmJiBoLnB1c2goZSk7XHJcbiAgICAgICAgICAgIHJldHVybiBnLmFwcGx5KFtdLCBoKVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ3VpZDogMSxcclxuICAgICAgICBwcm94eTogZnVuY3Rpb24oYSwgYikge1xyXG4gICAgICAgICAgICB2YXIgYywgZCwgZTtcclxuICAgICAgICAgICAgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIGIgJiYgKGMgPSBhW2JdLCBiID0gYSwgYSA9IGMpLCByLmlzRnVuY3Rpb24oYSkpIHJldHVybiBkID0gZi5jYWxsKGFyZ3VtZW50cywgMiksIGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhLmFwcGx5KGIgfHwgdGhpcywgZC5jb25jYXQoZi5jYWxsKGFyZ3VtZW50cykpKVxyXG4gICAgICAgICAgICB9LCBlLmd1aWQgPSBhLmd1aWQgPSBhLmd1aWQgfHwgci5ndWlkKyssIGVcclxuICAgICAgICB9LFxyXG4gICAgICAgIG5vdzogRGF0ZS5ub3csXHJcbiAgICAgICAgc3VwcG9ydDogb1xyXG4gICAgfSksIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIChyLmZuW1N5bWJvbC5pdGVyYXRvcl0gPSBjW1N5bWJvbC5pdGVyYXRvcl0pLCByLmVhY2goXCJCb29sZWFuIE51bWJlciBTdHJpbmcgRnVuY3Rpb24gQXJyYXkgRGF0ZSBSZWdFeHAgT2JqZWN0IEVycm9yIFN5bWJvbFwiLnNwbGl0KFwiIFwiKSwgZnVuY3Rpb24oYSwgYikge1xyXG4gICAgICAgIGpbXCJbb2JqZWN0IFwiICsgYiArIFwiXVwiXSA9IGIudG9Mb3dlckNhc2UoKVxyXG4gICAgfSk7XHJcblxyXG4gICAgZnVuY3Rpb24gdyhhKSB7XHJcbiAgICAgICAgdmFyIGIgPSAhIWEgJiYgXCJsZW5ndGhcIiBpbiBhICYmIGEubGVuZ3RoLFxyXG4gICAgICAgICAgICBjID0gci50eXBlKGEpO1xyXG4gICAgICAgIHJldHVybiBcImZ1bmN0aW9uXCIgIT09IGMgJiYgIXIuaXNXaW5kb3coYSkgJiYgKFwiYXJyYXlcIiA9PT0gYyB8fCAwID09PSBiIHx8IFwibnVtYmVyXCIgPT0gdHlwZW9mIGIgJiYgYiA+IDAgJiYgYiAtIDEgaW4gYSlcclxuICAgIH1cclxuICAgIHZhciB4ID0gZnVuY3Rpb24oYSkge1xyXG4gICAgICAgIHZhciBiLCBjLCBkLCBlLCBmLCBnLCBoLCBpLCBqLCBrLCBsLCBtLCBuLCBvLCBwLCBxLCByLCBzLCB0LCB1ID0gXCJzaXp6bGVcIiArIDEgKiBuZXcgRGF0ZSxcclxuICAgICAgICAgICAgdiA9IGEuZG9jdW1lbnQsXHJcbiAgICAgICAgICAgIHcgPSAwLFxyXG4gICAgICAgICAgICB4ID0gMCxcclxuICAgICAgICAgICAgeSA9IGhhKCksXHJcbiAgICAgICAgICAgIHogPSBoYSgpLFxyXG4gICAgICAgICAgICBBID0gaGEoKSxcclxuICAgICAgICAgICAgQiA9IGZ1bmN0aW9uKGEsIGIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhID09PSBiICYmIChsID0gITApLCAwXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIEMgPSB7fS5oYXNPd25Qcm9wZXJ0eSxcclxuICAgICAgICAgICAgRCA9IFtdLFxyXG4gICAgICAgICAgICBFID0gRC5wb3AsXHJcbiAgICAgICAgICAgIEYgPSBELnB1c2gsXHJcbiAgICAgICAgICAgIEcgPSBELnB1c2gsXHJcbiAgICAgICAgICAgIEggPSBELnNsaWNlLFxyXG4gICAgICAgICAgICBJID0gZnVuY3Rpb24oYSwgYikge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgYyA9IDAsIGQgPSBhLmxlbmd0aDsgYyA8IGQ7IGMrKylcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYVtjXSA9PT0gYikgcmV0dXJuIGM7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gLTFcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgSiA9IFwiY2hlY2tlZHxzZWxlY3RlZHxhc3luY3xhdXRvZm9jdXN8YXV0b3BsYXl8Y29udHJvbHN8ZGVmZXJ8ZGlzYWJsZWR8aGlkZGVufGlzbWFwfGxvb3B8bXVsdGlwbGV8b3BlbnxyZWFkb25seXxyZXF1aXJlZHxzY29wZWRcIixcclxuICAgICAgICAgICAgSyA9IFwiW1xcXFx4MjBcXFxcdFxcXFxyXFxcXG5cXFxcZl1cIixcclxuICAgICAgICAgICAgTCA9IFwiKD86XFxcXFxcXFwufFtcXFxcdy1dfFteXFwwLVxcXFx4YTBdKStcIixcclxuICAgICAgICAgICAgTSA9IFwiXFxcXFtcIiArIEsgKyBcIiooXCIgKyBMICsgXCIpKD86XCIgKyBLICsgXCIqKFsqXiR8IX5dPz0pXCIgKyBLICsgXCIqKD86JygoPzpcXFxcXFxcXC58W15cXFxcXFxcXCddKSopJ3xcXFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcIl0pKilcXFwifChcIiArIEwgKyBcIikpfClcIiArIEsgKyBcIipcXFxcXVwiLFxyXG4gICAgICAgICAgICBOID0gXCI6KFwiICsgTCArIFwiKSg/OlxcXFwoKCgnKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcJ10pKiknfFxcXCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFxcXFwiXSkqKVxcXCIpfCgoPzpcXFxcXFxcXC58W15cXFxcXFxcXCgpW1xcXFxdXXxcIiArIE0gKyBcIikqKXwuKilcXFxcKXwpXCIsXHJcbiAgICAgICAgICAgIE8gPSBuZXcgUmVnRXhwKEsgKyBcIitcIiwgXCJnXCIpLFxyXG4gICAgICAgICAgICBQID0gbmV3IFJlZ0V4cChcIl5cIiArIEsgKyBcIit8KCg/Ol58W15cXFxcXFxcXF0pKD86XFxcXFxcXFwuKSopXCIgKyBLICsgXCIrJFwiLCBcImdcIiksXHJcbiAgICAgICAgICAgIFEgPSBuZXcgUmVnRXhwKFwiXlwiICsgSyArIFwiKixcIiArIEsgKyBcIipcIiksXHJcbiAgICAgICAgICAgIFIgPSBuZXcgUmVnRXhwKFwiXlwiICsgSyArIFwiKihbPit+XXxcIiArIEsgKyBcIilcIiArIEsgKyBcIipcIiksXHJcbiAgICAgICAgICAgIFMgPSBuZXcgUmVnRXhwKFwiPVwiICsgSyArIFwiKihbXlxcXFxdJ1xcXCJdKj8pXCIgKyBLICsgXCIqXFxcXF1cIiwgXCJnXCIpLFxyXG4gICAgICAgICAgICBUID0gbmV3IFJlZ0V4cChOKSxcclxuICAgICAgICAgICAgVSA9IG5ldyBSZWdFeHAoXCJeXCIgKyBMICsgXCIkXCIpLFxyXG4gICAgICAgICAgICBWID0ge1xyXG4gICAgICAgICAgICAgICAgSUQ6IG5ldyBSZWdFeHAoXCJeIyhcIiArIEwgKyBcIilcIiksXHJcbiAgICAgICAgICAgICAgICBDTEFTUzogbmV3IFJlZ0V4cChcIl5cXFxcLihcIiArIEwgKyBcIilcIiksXHJcbiAgICAgICAgICAgICAgICBUQUc6IG5ldyBSZWdFeHAoXCJeKFwiICsgTCArIFwifFsqXSlcIiksXHJcbiAgICAgICAgICAgICAgICBBVFRSOiBuZXcgUmVnRXhwKFwiXlwiICsgTSksXHJcbiAgICAgICAgICAgICAgICBQU0VVRE86IG5ldyBSZWdFeHAoXCJeXCIgKyBOKSxcclxuICAgICAgICAgICAgICAgIENISUxEOiBuZXcgUmVnRXhwKFwiXjoob25seXxmaXJzdHxsYXN0fG50aHxudGgtbGFzdCktKGNoaWxkfG9mLXR5cGUpKD86XFxcXChcIiArIEsgKyBcIiooZXZlbnxvZGR8KChbKy1dfCkoXFxcXGQqKW58KVwiICsgSyArIFwiKig/OihbKy1dfClcIiArIEsgKyBcIiooXFxcXGQrKXwpKVwiICsgSyArIFwiKlxcXFwpfClcIiwgXCJpXCIpLFxyXG4gICAgICAgICAgICAgICAgYm9vbDogbmV3IFJlZ0V4cChcIl4oPzpcIiArIEogKyBcIikkXCIsIFwiaVwiKSxcclxuICAgICAgICAgICAgICAgIG5lZWRzQ29udGV4dDogbmV3IFJlZ0V4cChcIl5cIiArIEsgKyBcIipbPit+XXw6KGV2ZW58b2RkfGVxfGd0fGx0fG50aHxmaXJzdHxsYXN0KSg/OlxcXFwoXCIgKyBLICsgXCIqKCg/Oi1cXFxcZCk/XFxcXGQqKVwiICsgSyArIFwiKlxcXFwpfCkoPz1bXi1dfCQpXCIsIFwiaVwiKVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBXID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uKSQvaSxcclxuICAgICAgICAgICAgWCA9IC9eaFxcZCQvaSxcclxuICAgICAgICAgICAgWSA9IC9eW157XStcXHtcXHMqXFxbbmF0aXZlIFxcdy8sXHJcbiAgICAgICAgICAgIFogPSAvXig/OiMoW1xcdy1dKyl8KFxcdyspfFxcLihbXFx3LV0rKSkkLyxcclxuICAgICAgICAgICAgJCA9IC9bK35dLyxcclxuICAgICAgICAgICAgXyA9IG5ldyBSZWdFeHAoXCJcXFxcXFxcXChbXFxcXGRhLWZdezEsNn1cIiArIEsgKyBcIj98KFwiICsgSyArIFwiKXwuKVwiLCBcImlnXCIpLFxyXG4gICAgICAgICAgICBhYSA9IGZ1bmN0aW9uKGEsIGIsIGMpIHtcclxuICAgICAgICAgICAgICAgIHZhciBkID0gXCIweFwiICsgYiAtIDY1NTM2O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGQgIT09IGQgfHwgYyA/IGIgOiBkIDwgMCA/IFN0cmluZy5mcm9tQ2hhckNvZGUoZCArIDY1NTM2KSA6IFN0cmluZy5mcm9tQ2hhckNvZGUoZCA+PiAxMCB8IDU1Mjk2LCAxMDIzICYgZCB8IDU2MzIwKVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBiYSA9IC8oW1xcMC1cXHgxZlxceDdmXXxeLT9cXGQpfF4tJHxbXlxcMC1cXHgxZlxceDdmLVxcdUZGRkZcXHctXS9nLFxyXG4gICAgICAgICAgICBjYSA9IGZ1bmN0aW9uKGEsIGIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBiID8gXCJcXDBcIiA9PT0gYSA/IFwiXFx1ZmZmZFwiIDogYS5zbGljZSgwLCAtMSkgKyBcIlxcXFxcIiArIGEuY2hhckNvZGVBdChhLmxlbmd0aCAtIDEpLnRvU3RyaW5nKDE2KSArIFwiIFwiIDogXCJcXFxcXCIgKyBhXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGRhID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICBtKClcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZWEgPSB0YShmdW5jdGlvbihhKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYS5kaXNhYmxlZCA9PT0gITAgJiYgKFwiZm9ybVwiIGluIGEgfHwgXCJsYWJlbFwiIGluIGEpXHJcbiAgICAgICAgICAgIH0sIHtcclxuICAgICAgICAgICAgICAgIGRpcjogXCJwYXJlbnROb2RlXCIsXHJcbiAgICAgICAgICAgICAgICBuZXh0OiBcImxlZ2VuZFwiXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIEcuYXBwbHkoRCA9IEguY2FsbCh2LmNoaWxkTm9kZXMpLCB2LmNoaWxkTm9kZXMpLCBEW3YuY2hpbGROb2Rlcy5sZW5ndGhdLm5vZGVUeXBlXHJcbiAgICAgICAgfSBjYXRjaCAoZmEpIHtcclxuICAgICAgICAgICAgRyA9IHtcclxuICAgICAgICAgICAgICAgIGFwcGx5OiBELmxlbmd0aCA/IGZ1bmN0aW9uKGEsIGIpIHtcclxuICAgICAgICAgICAgICAgICAgICBGLmFwcGx5KGEsIEguY2FsbChiKSlcclxuICAgICAgICAgICAgICAgIH0gOiBmdW5jdGlvbihhLCBiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGMgPSBhLmxlbmd0aCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGFbYysrXSA9IGJbZCsrXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYS5sZW5ndGggPSBjIC0gMVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBnYShhLCBiLCBkLCBlKSB7XHJcbiAgICAgICAgICAgIHZhciBmLCBoLCBqLCBrLCBsLCBvLCByLCBzID0gYiAmJiBiLm93bmVyRG9jdW1lbnQsXHJcbiAgICAgICAgICAgICAgICB3ID0gYiA/IGIubm9kZVR5cGUgOiA5O1xyXG4gICAgICAgICAgICBpZiAoZCA9IGQgfHwgW10sIFwic3RyaW5nXCIgIT0gdHlwZW9mIGEgfHwgIWEgfHwgMSAhPT0gdyAmJiA5ICE9PSB3ICYmIDExICE9PSB3KSByZXR1cm4gZDtcclxuICAgICAgICAgICAgaWYgKCFlICYmICgoYiA/IGIub3duZXJEb2N1bWVudCB8fCBiIDogdikgIT09IG4gJiYgbShiKSwgYiA9IGIgfHwgbiwgcCkpIHtcclxuICAgICAgICAgICAgICAgIGlmICgxMSAhPT0gdyAmJiAobCA9IFouZXhlYyhhKSkpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGYgPSBsWzFdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICg5ID09PSB3KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShqID0gYi5nZXRFbGVtZW50QnlJZChmKSkpIHJldHVybiBkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGouaWQgPT09IGYpIHJldHVybiBkLnB1c2goaiksIGRcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzICYmIChqID0gcy5nZXRFbGVtZW50QnlJZChmKSkgJiYgdChiLCBqKSAmJiBqLmlkID09PSBmKSByZXR1cm4gZC5wdXNoKGopLCBkXHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxbMl0pIHJldHVybiBHLmFwcGx5KGQsIGIuZ2V0RWxlbWVudHNCeVRhZ05hbWUoYSkpLCBkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGYgPSBsWzNdKSAmJiBjLmdldEVsZW1lbnRzQnlDbGFzc05hbWUgJiYgYi5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKSByZXR1cm4gRy5hcHBseShkLCBiLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoZikpLCBkXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGMucXNhICYmICFBW2EgKyBcIiBcIl0gJiYgKCFxIHx8ICFxLnRlc3QoYSkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKDEgIT09IHcpIHMgPSBiLCByID0gYTtcclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChcIm9iamVjdFwiICE9PSBiLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgKGsgPSBiLmdldEF0dHJpYnV0ZShcImlkXCIpKSA/IGsgPSBrLnJlcGxhY2UoYmEsIGNhKTogYi5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBrID0gdSksIG8gPSBnKGEpLCBoID0gby5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChoLS0pIG9baF0gPSBcIiNcIiArIGsgKyBcIiBcIiArIHNhKG9baF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByID0gby5qb2luKFwiLFwiKSwgcyA9ICQudGVzdChhKSAmJiBxYShiLnBhcmVudE5vZGUpIHx8IGJcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHIpIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBHLmFwcGx5KGQsIHMucXVlcnlTZWxlY3RvckFsbChyKSksIGRcclxuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoICh4KSB7fSBmaW5hbGx5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgayA9PT0gdSAmJiBiLnJlbW92ZUF0dHJpYnV0ZShcImlkXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBpKGEucmVwbGFjZShQLCBcIiQxXCIpLCBiLCBkLCBlKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gaGEoKSB7XHJcbiAgICAgICAgICAgIHZhciBhID0gW107XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBiKGMsIGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhLnB1c2goYyArIFwiIFwiKSA+IGQuY2FjaGVMZW5ndGggJiYgZGVsZXRlIGJbYS5zaGlmdCgpXSwgYltjICsgXCIgXCJdID0gZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBiXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBpYShhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhW3VdID0gITAsIGFcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGphKGEpIHtcclxuICAgICAgICAgICAgdmFyIGIgPSBuLmNyZWF0ZUVsZW1lbnQoXCJmaWVsZHNldFwiKTtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAhIWEoYilcclxuICAgICAgICAgICAgfSBjYXRjaCAoYykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICExXHJcbiAgICAgICAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgICAgICAgICBiLnBhcmVudE5vZGUgJiYgYi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGIpLCBiID0gbnVsbFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBrYShhLCBiKSB7XHJcbiAgICAgICAgICAgIHZhciBjID0gYS5zcGxpdChcInxcIiksXHJcbiAgICAgICAgICAgICAgICBlID0gYy5sZW5ndGg7XHJcbiAgICAgICAgICAgIHdoaWxlIChlLS0pIGQuYXR0ckhhbmRsZVtjW2VdXSA9IGJcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGxhKGEsIGIpIHtcclxuICAgICAgICAgICAgdmFyIGMgPSBiICYmIGEsXHJcbiAgICAgICAgICAgICAgICBkID0gYyAmJiAxID09PSBhLm5vZGVUeXBlICYmIDEgPT09IGIubm9kZVR5cGUgJiYgYS5zb3VyY2VJbmRleCAtIGIuc291cmNlSW5kZXg7XHJcbiAgICAgICAgICAgIGlmIChkKSByZXR1cm4gZDtcclxuICAgICAgICAgICAgaWYgKGMpXHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoYyA9IGMubmV4dFNpYmxpbmcpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMgPT09IGIpIHJldHVybiAtMTtcclxuICAgICAgICAgICAgcmV0dXJuIGEgPyAxIDogLTFcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIG1hKGEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGIpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjID0gYi5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiaW5wdXRcIiA9PT0gYyAmJiBiLnR5cGUgPT09IGFcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gbmEoYSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oYikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGMgPSBiLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKFwiaW5wdXRcIiA9PT0gYyB8fCBcImJ1dHRvblwiID09PSBjKSAmJiBiLnR5cGUgPT09IGFcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gb2EoYSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oYikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiZm9ybVwiIGluIGIgPyBiLnBhcmVudE5vZGUgJiYgYi5kaXNhYmxlZCA9PT0gITEgPyBcImxhYmVsXCIgaW4gYiA/IFwibGFiZWxcIiBpbiBiLnBhcmVudE5vZGUgPyBiLnBhcmVudE5vZGUuZGlzYWJsZWQgPT09IGEgOiBiLmRpc2FibGVkID09PSBhIDogYi5pc0Rpc2FibGVkID09PSBhIHx8IGIuaXNEaXNhYmxlZCAhPT0gIWEgJiYgZWEoYikgPT09IGEgOiBiLmRpc2FibGVkID09PSBhIDogXCJsYWJlbFwiIGluIGIgJiYgYi5kaXNhYmxlZCA9PT0gYVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBwYShhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpYShmdW5jdGlvbihiKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYiA9ICtiLCBpYShmdW5jdGlvbihjLCBkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGUsIGYgPSBhKFtdLCBjLmxlbmd0aCwgYiksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGcgPSBmLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoZy0tKSBjW2UgPSBmW2ddXSAmJiAoY1tlXSA9ICEoZFtlXSA9IGNbZV0pKVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHFhKGEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGEgJiYgXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgYS5nZXRFbGVtZW50c0J5VGFnTmFtZSAmJiBhXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGMgPSBnYS5zdXBwb3J0ID0ge30sIGYgPSBnYS5pc1hNTCA9IGZ1bmN0aW9uKGEpIHtcclxuICAgICAgICAgICAgdmFyIGIgPSBhICYmIChhLm93bmVyRG9jdW1lbnQgfHwgYSkuZG9jdW1lbnRFbGVtZW50O1xyXG4gICAgICAgICAgICByZXR1cm4gISFiICYmIFwiSFRNTFwiICE9PSBiLm5vZGVOYW1lXHJcbiAgICAgICAgfSwgbSA9IGdhLnNldERvY3VtZW50ID0gZnVuY3Rpb24oYSkge1xyXG4gICAgICAgICAgICB2YXIgYiwgZSwgZyA9IGEgPyBhLm93bmVyRG9jdW1lbnQgfHwgYSA6IHY7XHJcbiAgICAgICAgICAgIHJldHVybiBnICE9PSBuICYmIDkgPT09IGcubm9kZVR5cGUgJiYgZy5kb2N1bWVudEVsZW1lbnQgPyAobiA9IGcsIG8gPSBuLmRvY3VtZW50RWxlbWVudCwgcCA9ICFmKG4pLCB2ICE9PSBuICYmIChlID0gbi5kZWZhdWx0VmlldykgJiYgZS50b3AgIT09IGUgJiYgKGUuYWRkRXZlbnRMaXN0ZW5lciA/IGUuYWRkRXZlbnRMaXN0ZW5lcihcInVubG9hZFwiLCBkYSwgITEpIDogZS5hdHRhY2hFdmVudCAmJiBlLmF0dGFjaEV2ZW50KFwib251bmxvYWRcIiwgZGEpKSwgYy5hdHRyaWJ1dGVzID0gamEoZnVuY3Rpb24oYSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGEuY2xhc3NOYW1lID0gXCJpXCIsICFhLmdldEF0dHJpYnV0ZShcImNsYXNzTmFtZVwiKVxyXG4gICAgICAgICAgICB9KSwgYy5nZXRFbGVtZW50c0J5VGFnTmFtZSA9IGphKGZ1bmN0aW9uKGEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhLmFwcGVuZENoaWxkKG4uY3JlYXRlQ29tbWVudChcIlwiKSksICFhLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiKlwiKS5sZW5ndGhcclxuICAgICAgICAgICAgfSksIGMuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSA9IFkudGVzdChuLmdldEVsZW1lbnRzQnlDbGFzc05hbWUpLCBjLmdldEJ5SWQgPSBqYShmdW5jdGlvbihhKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gby5hcHBlbmRDaGlsZChhKS5pZCA9IHUsICFuLmdldEVsZW1lbnRzQnlOYW1lIHx8ICFuLmdldEVsZW1lbnRzQnlOYW1lKHUpLmxlbmd0aFxyXG4gICAgICAgICAgICB9KSwgYy5nZXRCeUlkID8gKGQuZmlsdGVyLklEID0gZnVuY3Rpb24oYSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGIgPSBhLnJlcGxhY2UoXywgYWEpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGEpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYS5nZXRBdHRyaWJ1dGUoXCJpZFwiKSA9PT0gYlxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LCBkLmZpbmQuSUQgPSBmdW5jdGlvbihhLCBiKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgYi5nZXRFbGVtZW50QnlJZCAmJiBwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGMgPSBiLmdldEVsZW1lbnRCeUlkKGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjID8gW2NdIDogW11cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSkgOiAoZC5maWx0ZXIuSUQgPSBmdW5jdGlvbihhKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYiA9IGEucmVwbGFjZShfLCBhYSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oYSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjID0gXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgYS5nZXRBdHRyaWJ1dGVOb2RlICYmIGEuZ2V0QXR0cmlidXRlTm9kZShcImlkXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjICYmIGMudmFsdWUgPT09IGJcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgZC5maW5kLklEID0gZnVuY3Rpb24oYSwgYikge1xyXG4gICAgICAgICAgICAgICAgaWYgKFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIGIuZ2V0RWxlbWVudEJ5SWQgJiYgcCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjLCBkLCBlLCBmID0gYi5nZXRFbGVtZW50QnlJZChhKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYyA9IGYuZ2V0QXR0cmlidXRlTm9kZShcImlkXCIpLCBjICYmIGMudmFsdWUgPT09IGEpIHJldHVybiBbZl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGUgPSBiLmdldEVsZW1lbnRzQnlOYW1lKGEpLCBkID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGYgPSBlW2QrK10pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYyA9IGYuZ2V0QXR0cmlidXRlTm9kZShcImlkXCIpLCBjICYmIGMudmFsdWUgPT09IGEpIHJldHVybiBbZl1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pLCBkLmZpbmQuVEFHID0gYy5nZXRFbGVtZW50c0J5VGFnTmFtZSA/IGZ1bmN0aW9uKGEsIGIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBiLmdldEVsZW1lbnRzQnlUYWdOYW1lID8gYi5nZXRFbGVtZW50c0J5VGFnTmFtZShhKSA6IGMucXNhID8gYi5xdWVyeVNlbGVjdG9yQWxsKGEpIDogdm9pZCAwXHJcbiAgICAgICAgICAgIH0gOiBmdW5jdGlvbihhLCBiKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYywgZCA9IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgIGUgPSAwLFxyXG4gICAgICAgICAgICAgICAgICAgIGYgPSBiLmdldEVsZW1lbnRzQnlUYWdOYW1lKGEpO1xyXG4gICAgICAgICAgICAgICAgaWYgKFwiKlwiID09PSBhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGMgPSBmW2UrK10pIDEgPT09IGMubm9kZVR5cGUgJiYgZC5wdXNoKGMpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZlxyXG4gICAgICAgICAgICB9LCBkLmZpbmQuQ0xBU1MgPSBjLmdldEVsZW1lbnRzQnlDbGFzc05hbWUgJiYgZnVuY3Rpb24oYSwgYikge1xyXG4gICAgICAgICAgICAgICAgaWYgKFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIGIuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAmJiBwKSByZXR1cm4gYi5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKGEpXHJcbiAgICAgICAgICAgIH0sIHIgPSBbXSwgcSA9IFtdLCAoYy5xc2EgPSBZLnRlc3Qobi5xdWVyeVNlbGVjdG9yQWxsKSkgJiYgKGphKGZ1bmN0aW9uKGEpIHtcclxuICAgICAgICAgICAgICAgIG8uYXBwZW5kQ2hpbGQoYSkuaW5uZXJIVE1MID0gXCI8YSBpZD0nXCIgKyB1ICsgXCInPjwvYT48c2VsZWN0IGlkPSdcIiArIHUgKyBcIi1cXHJcXFxcJyBtc2FsbG93Y2FwdHVyZT0nJz48b3B0aW9uIHNlbGVjdGVkPScnPjwvb3B0aW9uPjwvc2VsZWN0PlwiLCBhLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbbXNhbGxvd2NhcHR1cmVePScnXVwiKS5sZW5ndGggJiYgcS5wdXNoKFwiWypeJF09XCIgKyBLICsgXCIqKD86Jyd8XFxcIlxcXCIpXCIpLCBhLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbc2VsZWN0ZWRdXCIpLmxlbmd0aCB8fCBxLnB1c2goXCJcXFxcW1wiICsgSyArIFwiKig/OnZhbHVlfFwiICsgSiArIFwiKVwiKSwgYS5xdWVyeVNlbGVjdG9yQWxsKFwiW2lkfj1cIiArIHUgKyBcIi1dXCIpLmxlbmd0aCB8fCBxLnB1c2goXCJ+PVwiKSwgYS5xdWVyeVNlbGVjdG9yQWxsKFwiOmNoZWNrZWRcIikubGVuZ3RoIHx8IHEucHVzaChcIjpjaGVja2VkXCIpLCBhLnF1ZXJ5U2VsZWN0b3JBbGwoXCJhI1wiICsgdSArIFwiKypcIikubGVuZ3RoIHx8IHEucHVzaChcIi4jLitbK35dXCIpXHJcbiAgICAgICAgICAgIH0pLCBqYShmdW5jdGlvbihhKSB7XHJcbiAgICAgICAgICAgICAgICBhLmlubmVySFRNTCA9IFwiPGEgaHJlZj0nJyBkaXNhYmxlZD0nZGlzYWJsZWQnPjwvYT48c2VsZWN0IGRpc2FibGVkPSdkaXNhYmxlZCc+PG9wdGlvbi8+PC9zZWxlY3Q+XCI7XHJcbiAgICAgICAgICAgICAgICB2YXIgYiA9IG4uY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xyXG4gICAgICAgICAgICAgICAgYi5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsIFwiaGlkZGVuXCIpLCBhLmFwcGVuZENoaWxkKGIpLnNldEF0dHJpYnV0ZShcIm5hbWVcIiwgXCJEXCIpLCBhLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbbmFtZT1kXVwiKS5sZW5ndGggJiYgcS5wdXNoKFwibmFtZVwiICsgSyArIFwiKlsqXiR8IX5dPz1cIiksIDIgIT09IGEucXVlcnlTZWxlY3RvckFsbChcIjplbmFibGVkXCIpLmxlbmd0aCAmJiBxLnB1c2goXCI6ZW5hYmxlZFwiLCBcIjpkaXNhYmxlZFwiKSwgby5hcHBlbmRDaGlsZChhKS5kaXNhYmxlZCA9ICEwLCAyICE9PSBhLnF1ZXJ5U2VsZWN0b3JBbGwoXCI6ZGlzYWJsZWRcIikubGVuZ3RoICYmIHEucHVzaChcIjplbmFibGVkXCIsIFwiOmRpc2FibGVkXCIpLCBhLnF1ZXJ5U2VsZWN0b3JBbGwoXCIqLDp4XCIpLCBxLnB1c2goXCIsLio6XCIpXHJcbiAgICAgICAgICAgIH0pKSwgKGMubWF0Y2hlc1NlbGVjdG9yID0gWS50ZXN0KHMgPSBvLm1hdGNoZXMgfHwgby53ZWJraXRNYXRjaGVzU2VsZWN0b3IgfHwgby5tb3pNYXRjaGVzU2VsZWN0b3IgfHwgby5vTWF0Y2hlc1NlbGVjdG9yIHx8IG8ubXNNYXRjaGVzU2VsZWN0b3IpKSAmJiBqYShmdW5jdGlvbihhKSB7XHJcbiAgICAgICAgICAgICAgICBjLmRpc2Nvbm5lY3RlZE1hdGNoID0gcy5jYWxsKGEsIFwiKlwiKSwgcy5jYWxsKGEsIFwiW3MhPScnXTp4XCIpLCByLnB1c2goXCIhPVwiLCBOKVxyXG4gICAgICAgICAgICB9KSwgcSA9IHEubGVuZ3RoICYmIG5ldyBSZWdFeHAocS5qb2luKFwifFwiKSksIHIgPSByLmxlbmd0aCAmJiBuZXcgUmVnRXhwKHIuam9pbihcInxcIikpLCBiID0gWS50ZXN0KG8uY29tcGFyZURvY3VtZW50UG9zaXRpb24pLCB0ID0gYiB8fCBZLnRlc3Qoby5jb250YWlucykgPyBmdW5jdGlvbihhLCBiKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYyA9IDkgPT09IGEubm9kZVR5cGUgPyBhLmRvY3VtZW50RWxlbWVudCA6IGEsXHJcbiAgICAgICAgICAgICAgICAgICAgZCA9IGIgJiYgYi5wYXJlbnROb2RlO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGEgPT09IGQgfHwgISghZCB8fCAxICE9PSBkLm5vZGVUeXBlIHx8ICEoYy5jb250YWlucyA/IGMuY29udGFpbnMoZCkgOiBhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uICYmIDE2ICYgYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihkKSkpXHJcbiAgICAgICAgICAgIH0gOiBmdW5jdGlvbihhLCBiKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYilcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoYiA9IGIucGFyZW50Tm9kZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGIgPT09IGEpIHJldHVybiAhMDtcclxuICAgICAgICAgICAgICAgIHJldHVybiAhMVxyXG4gICAgICAgICAgICB9LCBCID0gYiA/IGZ1bmN0aW9uKGEsIGIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChhID09PSBiKSByZXR1cm4gbCA9ICEwLCAwO1xyXG4gICAgICAgICAgICAgICAgdmFyIGQgPSAhYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiAtICFiLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGQgPyBkIDogKGQgPSAoYS5vd25lckRvY3VtZW50IHx8IGEpID09PSAoYi5vd25lckRvY3VtZW50IHx8IGIpID8gYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihiKSA6IDEsIDEgJiBkIHx8ICFjLnNvcnREZXRhY2hlZCAmJiBiLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGEpID09PSBkID8gYSA9PT0gbiB8fCBhLm93bmVyRG9jdW1lbnQgPT09IHYgJiYgdCh2LCBhKSA/IC0xIDogYiA9PT0gbiB8fCBiLm93bmVyRG9jdW1lbnQgPT09IHYgJiYgdCh2LCBiKSA/IDEgOiBrID8gSShrLCBhKSAtIEkoaywgYikgOiAwIDogNCAmIGQgPyAtMSA6IDEpXHJcbiAgICAgICAgICAgIH0gOiBmdW5jdGlvbihhLCBiKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYSA9PT0gYikgcmV0dXJuIGwgPSAhMCwgMDtcclxuICAgICAgICAgICAgICAgIHZhciBjLCBkID0gMCxcclxuICAgICAgICAgICAgICAgICAgICBlID0gYS5wYXJlbnROb2RlLFxyXG4gICAgICAgICAgICAgICAgICAgIGYgPSBiLnBhcmVudE5vZGUsXHJcbiAgICAgICAgICAgICAgICAgICAgZyA9IFthXSxcclxuICAgICAgICAgICAgICAgICAgICBoID0gW2JdO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFlIHx8ICFmKSByZXR1cm4gYSA9PT0gbiA/IC0xIDogYiA9PT0gbiA/IDEgOiBlID8gLTEgOiBmID8gMSA6IGsgPyBJKGssIGEpIC0gSShrLCBiKSA6IDA7XHJcbiAgICAgICAgICAgICAgICBpZiAoZSA9PT0gZikgcmV0dXJuIGxhKGEsIGIpO1xyXG4gICAgICAgICAgICAgICAgYyA9IGE7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoYyA9IGMucGFyZW50Tm9kZSkgZy51bnNoaWZ0KGMpO1xyXG4gICAgICAgICAgICAgICAgYyA9IGI7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoYyA9IGMucGFyZW50Tm9kZSkgaC51bnNoaWZ0KGMpO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGdbZF0gPT09IGhbZF0pIGQrKztcclxuICAgICAgICAgICAgICAgIHJldHVybiBkID8gbGEoZ1tkXSwgaFtkXSkgOiBnW2RdID09PSB2ID8gLTEgOiBoW2RdID09PSB2ID8gMSA6IDBcclxuICAgICAgICAgICAgfSwgbikgOiBuXHJcbiAgICAgICAgfSwgZ2EubWF0Y2hlcyA9IGZ1bmN0aW9uKGEsIGIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGdhKGEsIG51bGwsIG51bGwsIGIpXHJcbiAgICAgICAgfSwgZ2EubWF0Y2hlc1NlbGVjdG9yID0gZnVuY3Rpb24oYSwgYikge1xyXG4gICAgICAgICAgICBpZiAoKGEub3duZXJEb2N1bWVudCB8fCBhKSAhPT0gbiAmJiBtKGEpLCBiID0gYi5yZXBsYWNlKFMsIFwiPSckMSddXCIpLCBjLm1hdGNoZXNTZWxlY3RvciAmJiBwICYmICFBW2IgKyBcIiBcIl0gJiYgKCFyIHx8ICFyLnRlc3QoYikpICYmICghcSB8fCAhcS50ZXN0KGIpKSkgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHZhciBkID0gcy5jYWxsKGEsIGIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGQgfHwgYy5kaXNjb25uZWN0ZWRNYXRjaCB8fCBhLmRvY3VtZW50ICYmIDExICE9PSBhLmRvY3VtZW50Lm5vZGVUeXBlKSByZXR1cm4gZFxyXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7fVxyXG4gICAgICAgICAgICByZXR1cm4gZ2EoYiwgbiwgbnVsbCwgW2FdKS5sZW5ndGggPiAwXHJcbiAgICAgICAgfSwgZ2EuY29udGFpbnMgPSBmdW5jdGlvbihhLCBiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoYS5vd25lckRvY3VtZW50IHx8IGEpICE9PSBuICYmIG0oYSksIHQoYSwgYilcclxuICAgICAgICB9LCBnYS5hdHRyID0gZnVuY3Rpb24oYSwgYikge1xyXG4gICAgICAgICAgICAoYS5vd25lckRvY3VtZW50IHx8IGEpICE9PSBuICYmIG0oYSk7XHJcbiAgICAgICAgICAgIHZhciBlID0gZC5hdHRySGFuZGxlW2IudG9Mb3dlckNhc2UoKV0sXHJcbiAgICAgICAgICAgICAgICBmID0gZSAmJiBDLmNhbGwoZC5hdHRySGFuZGxlLCBiLnRvTG93ZXJDYXNlKCkpID8gZShhLCBiLCAhcCkgOiB2b2lkIDA7XHJcbiAgICAgICAgICAgIHJldHVybiB2b2lkIDAgIT09IGYgPyBmIDogYy5hdHRyaWJ1dGVzIHx8ICFwID8gYS5nZXRBdHRyaWJ1dGUoYikgOiAoZiA9IGEuZ2V0QXR0cmlidXRlTm9kZShiKSkgJiYgZi5zcGVjaWZpZWQgPyBmLnZhbHVlIDogbnVsbFxyXG4gICAgICAgIH0sIGdhLmVzY2FwZSA9IGZ1bmN0aW9uKGEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIChhICsgXCJcIikucmVwbGFjZShiYSwgY2EpXHJcbiAgICAgICAgfSwgZ2EuZXJyb3IgPSBmdW5jdGlvbihhKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlN5bnRheCBlcnJvciwgdW5yZWNvZ25pemVkIGV4cHJlc3Npb246IFwiICsgYSlcclxuICAgICAgICB9LCBnYS51bmlxdWVTb3J0ID0gZnVuY3Rpb24oYSkge1xyXG4gICAgICAgICAgICB2YXIgYiwgZCA9IFtdLFxyXG4gICAgICAgICAgICAgICAgZSA9IDAsXHJcbiAgICAgICAgICAgICAgICBmID0gMDtcclxuICAgICAgICAgICAgaWYgKGwgPSAhYy5kZXRlY3REdXBsaWNhdGVzLCBrID0gIWMuc29ydFN0YWJsZSAmJiBhLnNsaWNlKDApLCBhLnNvcnQoQiksIGwpIHtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChiID0gYVtmKytdKSBiID09PSBhW2ZdICYmIChlID0gZC5wdXNoKGYpKTtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChlLS0pIGEuc3BsaWNlKGRbZV0sIDEpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGsgPSBudWxsLCBhXHJcbiAgICAgICAgfSwgZSA9IGdhLmdldFRleHQgPSBmdW5jdGlvbihhKSB7XHJcbiAgICAgICAgICAgIHZhciBiLCBjID0gXCJcIixcclxuICAgICAgICAgICAgICAgIGQgPSAwLFxyXG4gICAgICAgICAgICAgICAgZiA9IGEubm9kZVR5cGU7XHJcbiAgICAgICAgICAgIGlmIChmKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoMSA9PT0gZiB8fCA5ID09PSBmIHx8IDExID09PSBmKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIGEudGV4dENvbnRlbnQpIHJldHVybiBhLnRleHRDb250ZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoYSA9IGEuZmlyc3RDaGlsZDsgYTsgYSA9IGEubmV4dFNpYmxpbmcpIGMgKz0gZShhKVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICgzID09PSBmIHx8IDQgPT09IGYpIHJldHVybiBhLm5vZGVWYWx1ZVxyXG4gICAgICAgICAgICB9IGVsc2VcclxuICAgICAgICAgICAgICAgIHdoaWxlIChiID0gYVtkKytdKSBjICs9IGUoYik7XHJcbiAgICAgICAgICAgIHJldHVybiBjXHJcbiAgICAgICAgfSwgZCA9IGdhLnNlbGVjdG9ycyA9IHtcclxuICAgICAgICAgICAgY2FjaGVMZW5ndGg6IDUwLFxyXG4gICAgICAgICAgICBjcmVhdGVQc2V1ZG86IGlhLFxyXG4gICAgICAgICAgICBtYXRjaDogVixcclxuICAgICAgICAgICAgYXR0ckhhbmRsZToge30sXHJcbiAgICAgICAgICAgIGZpbmQ6IHt9LFxyXG4gICAgICAgICAgICByZWxhdGl2ZToge1xyXG4gICAgICAgICAgICAgICAgXCI+XCI6IHtcclxuICAgICAgICAgICAgICAgICAgICBkaXI6IFwicGFyZW50Tm9kZVwiLFxyXG4gICAgICAgICAgICAgICAgICAgIGZpcnN0OiAhMFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIFwiIFwiOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlyOiBcInBhcmVudE5vZGVcIlxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIFwiK1wiOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlyOiBcInByZXZpb3VzU2libGluZ1wiLFxyXG4gICAgICAgICAgICAgICAgICAgIGZpcnN0OiAhMFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIFwiflwiOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlyOiBcInByZXZpb3VzU2libGluZ1wiXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHByZUZpbHRlcjoge1xyXG4gICAgICAgICAgICAgICAgQVRUUjogZnVuY3Rpb24oYSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhWzFdID0gYVsxXS5yZXBsYWNlKF8sIGFhKSwgYVszXSA9IChhWzNdIHx8IGFbNF0gfHwgYVs1XSB8fCBcIlwiKS5yZXBsYWNlKF8sIGFhKSwgXCJ+PVwiID09PSBhWzJdICYmIChhWzNdID0gXCIgXCIgKyBhWzNdICsgXCIgXCIpLCBhLnNsaWNlKDAsIDQpXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgQ0hJTEQ6IGZ1bmN0aW9uKGEpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYVsxXSA9IGFbMV0udG9Mb3dlckNhc2UoKSwgXCJudGhcIiA9PT0gYVsxXS5zbGljZSgwLCAzKSA/IChhWzNdIHx8IGdhLmVycm9yKGFbMF0pLCBhWzRdID0gKyhhWzRdID8gYVs1XSArIChhWzZdIHx8IDEpIDogMiAqIChcImV2ZW5cIiA9PT0gYVszXSB8fCBcIm9kZFwiID09PSBhWzNdKSksIGFbNV0gPSArKGFbN10gKyBhWzhdIHx8IFwib2RkXCIgPT09IGFbM10pKSA6IGFbM10gJiYgZ2EuZXJyb3IoYVswXSksIGFcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBQU0VVRE86IGZ1bmN0aW9uKGEpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYiwgYyA9ICFhWzZdICYmIGFbMl07XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFYuQ0hJTEQudGVzdChhWzBdKSA/IG51bGwgOiAoYVszXSA/IGFbMl0gPSBhWzRdIHx8IGFbNV0gfHwgXCJcIiA6IGMgJiYgVC50ZXN0KGMpICYmIChiID0gZyhjLCAhMCkpICYmIChiID0gYy5pbmRleE9mKFwiKVwiLCBjLmxlbmd0aCAtIGIpIC0gYy5sZW5ndGgpICYmIChhWzBdID0gYVswXS5zbGljZSgwLCBiKSwgYVsyXSA9IGMuc2xpY2UoMCwgYikpLCBhLnNsaWNlKDAsIDMpKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBmaWx0ZXI6IHtcclxuICAgICAgICAgICAgICAgIFRBRzogZnVuY3Rpb24oYSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBiID0gYS5yZXBsYWNlKF8sIGFhKS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIipcIiA9PT0gYSA/IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gITBcclxuICAgICAgICAgICAgICAgICAgICB9IDogZnVuY3Rpb24oYSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYS5ub2RlTmFtZSAmJiBhLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IGJcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgQ0xBU1M6IGZ1bmN0aW9uKGEpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYiA9IHlbYSArIFwiIFwiXTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYiB8fCAoYiA9IG5ldyBSZWdFeHAoXCIoXnxcIiArIEsgKyBcIilcIiArIGEgKyBcIihcIiArIEsgKyBcInwkKVwiKSkgJiYgeShhLCBmdW5jdGlvbihhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBiLnRlc3QoXCJzdHJpbmdcIiA9PSB0eXBlb2YgYS5jbGFzc05hbWUgJiYgYS5jbGFzc05hbWUgfHwgXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgYS5nZXRBdHRyaWJ1dGUgJiYgYS5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKSB8fCBcIlwiKVxyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgQVRUUjogZnVuY3Rpb24oYSwgYiwgYykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlID0gZ2EuYXR0cihkLCBhKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGwgPT0gZSA/IFwiIT1cIiA9PT0gYiA6ICFiIHx8IChlICs9IFwiXCIsIFwiPVwiID09PSBiID8gZSA9PT0gYyA6IFwiIT1cIiA9PT0gYiA/IGUgIT09IGMgOiBcIl49XCIgPT09IGIgPyBjICYmIDAgPT09IGUuaW5kZXhPZihjKSA6IFwiKj1cIiA9PT0gYiA/IGMgJiYgZS5pbmRleE9mKGMpID4gLTEgOiBcIiQ9XCIgPT09IGIgPyBjICYmIGUuc2xpY2UoLWMubGVuZ3RoKSA9PT0gYyA6IFwifj1cIiA9PT0gYiA/IChcIiBcIiArIGUucmVwbGFjZShPLCBcIiBcIikgKyBcIiBcIikuaW5kZXhPZihjKSA+IC0xIDogXCJ8PVwiID09PSBiICYmIChlID09PSBjIHx8IGUuc2xpY2UoMCwgYy5sZW5ndGggKyAxKSA9PT0gYyArIFwiLVwiKSlcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgQ0hJTEQ6IGZ1bmN0aW9uKGEsIGIsIGMsIGQsIGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZiA9IFwibnRoXCIgIT09IGEuc2xpY2UoMCwgMyksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGcgPSBcImxhc3RcIiAhPT0gYS5zbGljZSgtNCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGggPSBcIm9mLXR5cGVcIiA9PT0gYjtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMSA9PT0gZCAmJiAwID09PSBlID8gZnVuY3Rpb24oYSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gISFhLnBhcmVudE5vZGVcclxuICAgICAgICAgICAgICAgICAgICB9IDogZnVuY3Rpb24oYiwgYywgaSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaiwgaywgbCwgbSwgbiwgbywgcCA9IGYgIT09IGcgPyBcIm5leHRTaWJsaW5nXCIgOiBcInByZXZpb3VzU2libGluZ1wiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcSA9IGIucGFyZW50Tm9kZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIgPSBoICYmIGIubm9kZU5hbWUudG9Mb3dlckNhc2UoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMgPSAhaSAmJiAhaCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQgPSAhMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbSA9IGI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChtID0gbVtwXSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoID8gbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSByIDogMSA9PT0gbS5ub2RlVHlwZSkgcmV0dXJuICExO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvID0gcCA9IFwib25seVwiID09PSBhICYmICFvICYmIFwibmV4dFNpYmxpbmdcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gITBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvID0gW2cgPyBxLmZpcnN0Q2hpbGQgOiBxLmxhc3RDaGlsZF0sIGcgJiYgcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0gPSBxLCBsID0gbVt1XSB8fCAobVt1XSA9IHt9KSwgayA9IGxbbS51bmlxdWVJRF0gfHwgKGxbbS51bmlxdWVJRF0gPSB7fSksIGogPSBrW2FdIHx8IFtdLCBuID0galswXSA9PT0gdyAmJiBqWzFdLCB0ID0gbiAmJiBqWzJdLCBtID0gbiAmJiBxLmNoaWxkTm9kZXNbbl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKG0gPSArK24gJiYgbSAmJiBtW3BdIHx8ICh0ID0gbiA9IDApIHx8IG8ucG9wKCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgxID09PSBtLm5vZGVUeXBlICYmICsrdCAmJiBtID09PSBiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrW2FdID0gW3csIG4sIHRdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzICYmIChtID0gYiwgbCA9IG1bdV0gfHwgKG1bdV0gPSB7fSksIGsgPSBsW20udW5pcXVlSURdIHx8IChsW20udW5pcXVlSURdID0ge30pLCBqID0ga1thXSB8fCBbXSwgbiA9IGpbMF0gPT09IHcgJiYgalsxXSwgdCA9IG4pLCB0ID09PSAhMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAobSA9ICsrbiAmJiBtICYmIG1bcF0gfHwgKHQgPSBuID0gMCkgfHwgby5wb3AoKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChoID8gbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSByIDogMSA9PT0gbS5ub2RlVHlwZSkgJiYgKyt0ICYmIChzICYmIChsID0gbVt1XSB8fCAobVt1XSA9IHt9KSwgayA9IGxbbS51bmlxdWVJRF0gfHwgKGxbbS51bmlxdWVJRF0gPSB7fSksIGtbYV0gPSBbdywgdF0pLCBtID09PSBiKSkgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdCAtPSBlLCB0ID09PSBkIHx8IHQgJSBkID09PSAwICYmIHQgLyBkID49IDBcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBQU0VVRE86IGZ1bmN0aW9uKGEsIGIpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYywgZSA9IGQucHNldWRvc1thXSB8fCBkLnNldEZpbHRlcnNbYS50b0xvd2VyQ2FzZSgpXSB8fCBnYS5lcnJvcihcInVuc3VwcG9ydGVkIHBzZXVkbzogXCIgKyBhKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZVt1XSA/IGUoYikgOiBlLmxlbmd0aCA+IDEgPyAoYyA9IFthLCBhLCBcIlwiLCBiXSwgZC5zZXRGaWx0ZXJzLmhhc093blByb3BlcnR5KGEudG9Mb3dlckNhc2UoKSkgPyBpYShmdW5jdGlvbihhLCBjKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkLCBmID0gZShhLCBiKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGcgPSBmLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGctLSkgZCA9IEkoYSwgZltnXSksIGFbZF0gPSAhKGNbZF0gPSBmW2ddKVxyXG4gICAgICAgICAgICAgICAgICAgIH0pIDogZnVuY3Rpb24oYSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZShhLCAwLCBjKVxyXG4gICAgICAgICAgICAgICAgICAgIH0pIDogZVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBwc2V1ZG9zOiB7XHJcbiAgICAgICAgICAgICAgICBub3Q6IGlhKGZ1bmN0aW9uKGEpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYiA9IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjID0gW10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGQgPSBoKGEucmVwbGFjZShQLCBcIiQxXCIpKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZFt1XSA/IGlhKGZ1bmN0aW9uKGEsIGIsIGMsIGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGYsIGcgPSBkKGEsIG51bGwsIGUsIFtdKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGggPSBhLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGgtLSkoZiA9IGdbaF0pICYmIChhW2hdID0gIShiW2hdID0gZikpXHJcbiAgICAgICAgICAgICAgICAgICAgfSkgOiBmdW5jdGlvbihhLCBlLCBmKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBiWzBdID0gYSwgZChiLCBudWxsLCBmLCBjKSwgYlswXSA9IG51bGwsICFjLnBvcCgpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgICAgICBoYXM6IGlhKGZ1bmN0aW9uKGEpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oYikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2EoYSwgYikubGVuZ3RoID4gMFxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICAgICAgY29udGFpbnM6IGlhKGZ1bmN0aW9uKGEpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYSA9IGEucmVwbGFjZShfLCBhYSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKGIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoYi50ZXh0Q29udGVudCB8fCBiLmlubmVyVGV4dCB8fCBlKGIpKS5pbmRleE9mKGEpID4gLTFcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgICAgICBsYW5nOiBpYShmdW5jdGlvbihhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFUudGVzdChhIHx8IFwiXCIpIHx8IGdhLmVycm9yKFwidW5zdXBwb3J0ZWQgbGFuZzogXCIgKyBhKSwgYSA9IGEucmVwbGFjZShfLCBhYSkudG9Mb3dlckNhc2UoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oYikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjID0gcCA/IGIubGFuZyA6IGIuZ2V0QXR0cmlidXRlKFwieG1sOmxhbmdcIikgfHwgYi5nZXRBdHRyaWJ1dGUoXCJsYW5nXCIpKSByZXR1cm4gYyA9IGMudG9Mb3dlckNhc2UoKSwgYyA9PT0gYSB8fCAwID09PSBjLmluZGV4T2YoYSArIFwiLVwiKTsgd2hpbGUgKChiID0gYi5wYXJlbnROb2RlKSAmJiAxID09PSBiLm5vZGVUeXBlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhMVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgICAgIHRhcmdldDogZnVuY3Rpb24oYikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjID0gYS5sb2NhdGlvbiAmJiBhLmxvY2F0aW9uLmhhc2g7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGMgJiYgYy5zbGljZSgxKSA9PT0gYi5pZFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHJvb3Q6IGZ1bmN0aW9uKGEpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYSA9PT0gb1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGZvY3VzOiBmdW5jdGlvbihhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEgPT09IG4uYWN0aXZlRWxlbWVudCAmJiAoIW4uaGFzRm9jdXMgfHwgbi5oYXNGb2N1cygpKSAmJiAhIShhLnR5cGUgfHwgYS5ocmVmIHx8IH5hLnRhYkluZGV4KVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGVuYWJsZWQ6IG9hKCExKSxcclxuICAgICAgICAgICAgICAgIGRpc2FibGVkOiBvYSghMCksXHJcbiAgICAgICAgICAgICAgICBjaGVja2VkOiBmdW5jdGlvbihhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGIgPSBhLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiaW5wdXRcIiA9PT0gYiAmJiAhIWEuY2hlY2tlZCB8fCBcIm9wdGlvblwiID09PSBiICYmICEhYS5zZWxlY3RlZFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHNlbGVjdGVkOiBmdW5jdGlvbihhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEucGFyZW50Tm9kZSAmJiBhLnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleCwgYS5zZWxlY3RlZCA9PT0gITBcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBlbXB0eTogZnVuY3Rpb24oYSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoYSA9IGEuZmlyc3RDaGlsZDsgYTsgYSA9IGEubmV4dFNpYmxpbmcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhLm5vZGVUeXBlIDwgNikgcmV0dXJuICExO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhMFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHBhcmVudDogZnVuY3Rpb24oYSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhZC5wc2V1ZG9zLmVtcHR5KGEpXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgaGVhZGVyOiBmdW5jdGlvbihhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFgudGVzdChhLm5vZGVOYW1lKVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGlucHV0OiBmdW5jdGlvbihhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFcudGVzdChhLm5vZGVOYW1lKVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGJ1dHRvbjogZnVuY3Rpb24oYSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBiID0gYS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImlucHV0XCIgPT09IGIgJiYgXCJidXR0b25cIiA9PT0gYS50eXBlIHx8IFwiYnV0dG9uXCIgPT09IGJcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB0ZXh0OiBmdW5jdGlvbihhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGI7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiaW5wdXRcIiA9PT0gYS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICYmIFwidGV4dFwiID09PSBhLnR5cGUgJiYgKG51bGwgPT0gKGIgPSBhLmdldEF0dHJpYnV0ZShcInR5cGVcIikpIHx8IFwidGV4dFwiID09PSBiLnRvTG93ZXJDYXNlKCkpXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZmlyc3Q6IHBhKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMF1cclxuICAgICAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICAgICAgbGFzdDogcGEoZnVuY3Rpb24oYSwgYikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbYiAtIDFdXHJcbiAgICAgICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgICAgIGVxOiBwYShmdW5jdGlvbihhLCBiLCBjKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtjIDwgMCA/IGMgKyBiIDogY11cclxuICAgICAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICAgICAgZXZlbjogcGEoZnVuY3Rpb24oYSwgYikge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgYjsgYyArPSAyKSBhLnB1c2goYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFcclxuICAgICAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICAgICAgb2RkOiBwYShmdW5jdGlvbihhLCBiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgYyA9IDE7IGMgPCBiOyBjICs9IDIpIGEucHVzaChjKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYVxyXG4gICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgICAgICBsdDogcGEoZnVuY3Rpb24oYSwgYiwgYykge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGQgPSBjIDwgMCA/IGMgKyBiIDogYzsgLS1kID49IDA7KSBhLnB1c2goZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFcclxuICAgICAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICAgICAgZ3Q6IHBhKGZ1bmN0aW9uKGEsIGIsIGMpIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBkID0gYyA8IDAgPyBjICsgYiA6IGM7ICsrZCA8IGI7KSBhLnB1c2goZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCBkLnBzZXVkb3MubnRoID0gZC5wc2V1ZG9zLmVxO1xyXG4gICAgICAgIGZvciAoYiBpbiB7XHJcbiAgICAgICAgICAgICAgICByYWRpbzogITAsXHJcbiAgICAgICAgICAgICAgICBjaGVja2JveDogITAsXHJcbiAgICAgICAgICAgICAgICBmaWxlOiAhMCxcclxuICAgICAgICAgICAgICAgIHBhc3N3b3JkOiAhMCxcclxuICAgICAgICAgICAgICAgIGltYWdlOiAhMFxyXG4gICAgICAgICAgICB9KSBkLnBzZXVkb3NbYl0gPSBtYShiKTtcclxuICAgICAgICBmb3IgKGIgaW4ge1xyXG4gICAgICAgICAgICAgICAgc3VibWl0OiAhMCxcclxuICAgICAgICAgICAgICAgIHJlc2V0OiAhMFxyXG4gICAgICAgICAgICB9KSBkLnBzZXVkb3NbYl0gPSBuYShiKTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gcmEoKSB7fVxyXG4gICAgICAgIHJhLnByb3RvdHlwZSA9IGQuZmlsdGVycyA9IGQucHNldWRvcywgZC5zZXRGaWx0ZXJzID0gbmV3IHJhLCBnID0gZ2EudG9rZW5pemUgPSBmdW5jdGlvbihhLCBiKSB7XHJcbiAgICAgICAgICAgIHZhciBjLCBlLCBmLCBnLCBoLCBpLCBqLCBrID0gelthICsgXCIgXCJdO1xyXG4gICAgICAgICAgICBpZiAoaykgcmV0dXJuIGIgPyAwIDogay5zbGljZSgwKTtcclxuICAgICAgICAgICAgaCA9IGEsIGkgPSBbXSwgaiA9IGQucHJlRmlsdGVyO1xyXG4gICAgICAgICAgICB3aGlsZSAoaCkge1xyXG4gICAgICAgICAgICAgICAgYyAmJiAhKGUgPSBRLmV4ZWMoaCkpIHx8IChlICYmIChoID0gaC5zbGljZShlWzBdLmxlbmd0aCkgfHwgaCksIGkucHVzaChmID0gW10pKSwgYyA9ICExLCAoZSA9IFIuZXhlYyhoKSkgJiYgKGMgPSBlLnNoaWZ0KCksIGYucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGMsXHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogZVswXS5yZXBsYWNlKFAsIFwiIFwiKVxyXG4gICAgICAgICAgICAgICAgfSksIGggPSBoLnNsaWNlKGMubGVuZ3RoKSk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGcgaW4gZC5maWx0ZXIpICEoZSA9IFZbZ10uZXhlYyhoKSkgfHwgaltnXSAmJiAhKGUgPSBqW2ddKGUpKSB8fCAoYyA9IGUuc2hpZnQoKSwgZi5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogYyxcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBnLFxyXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZXM6IGVcclxuICAgICAgICAgICAgICAgIH0pLCBoID0gaC5zbGljZShjLmxlbmd0aCkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFjKSBicmVha1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBiID8gaC5sZW5ndGggOiBoID8gZ2EuZXJyb3IoYSkgOiB6KGEsIGkpLnNsaWNlKDApXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gc2EoYSkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBiID0gMCwgYyA9IGEubGVuZ3RoLCBkID0gXCJcIjsgYiA8IGM7IGIrKykgZCArPSBhW2JdLnZhbHVlO1xyXG4gICAgICAgICAgICByZXR1cm4gZFxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gdGEoYSwgYiwgYykge1xyXG4gICAgICAgICAgICB2YXIgZCA9IGIuZGlyLFxyXG4gICAgICAgICAgICAgICAgZSA9IGIubmV4dCxcclxuICAgICAgICAgICAgICAgIGYgPSBlIHx8IGQsXHJcbiAgICAgICAgICAgICAgICBnID0gYyAmJiBcInBhcmVudE5vZGVcIiA9PT0gZixcclxuICAgICAgICAgICAgICAgIGggPSB4Kys7XHJcbiAgICAgICAgICAgIHJldHVybiBiLmZpcnN0ID8gZnVuY3Rpb24oYiwgYywgZSkge1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGIgPSBiW2RdKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICgxID09PSBiLm5vZGVUeXBlIHx8IGcpIHJldHVybiBhKGIsIGMsIGUpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICExXHJcbiAgICAgICAgICAgIH0gOiBmdW5jdGlvbihiLCBjLCBpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaiwgaywgbCwgbSA9IFt3LCBoXTtcclxuICAgICAgICAgICAgICAgIGlmIChpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGIgPSBiW2RdKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKDEgPT09IGIubm9kZVR5cGUgfHwgZykgJiYgYShiLCBjLCBpKSkgcmV0dXJuICEwXHJcbiAgICAgICAgICAgICAgICB9IGVsc2VcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoYiA9IGJbZF0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgxID09PSBiLm5vZGVUeXBlIHx8IGcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobCA9IGJbdV0gfHwgKGJbdV0gPSB7fSksIGsgPSBsW2IudW5pcXVlSURdIHx8IChsW2IudW5pcXVlSURdID0ge30pLCBlICYmIGUgPT09IGIubm9kZU5hbWUudG9Mb3dlckNhc2UoKSkgYiA9IGJbZF0gfHwgYjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoaiA9IGtbZl0pICYmIGpbMF0gPT09IHcgJiYgalsxXSA9PT0gaCkgcmV0dXJuIG1bMl0gPSBqWzJdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrW2ZdID0gbSwgbVsyXSA9IGEoYiwgYywgaSkpIHJldHVybiAhMFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSByZXR1cm4gITFcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gdWEoYSkge1xyXG4gICAgICAgICAgICByZXR1cm4gYS5sZW5ndGggPiAxID8gZnVuY3Rpb24oYiwgYywgZCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGUgPSBhLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChlLS0pXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhW2VdKGIsIGMsIGQpKSByZXR1cm4gITE7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gITBcclxuICAgICAgICAgICAgfSA6IGFbMF1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHZhKGEsIGIsIGMpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgZCA9IDAsIGUgPSBiLmxlbmd0aDsgZCA8IGU7IGQrKykgZ2EoYSwgYltkXSwgYyk7XHJcbiAgICAgICAgICAgIHJldHVybiBjXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiB3YShhLCBiLCBjLCBkLCBlKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGYsIGcgPSBbXSwgaCA9IDAsIGkgPSBhLmxlbmd0aCwgaiA9IG51bGwgIT0gYjsgaCA8IGk7IGgrKykoZiA9IGFbaF0pICYmIChjICYmICFjKGYsIGQsIGUpIHx8IChnLnB1c2goZiksIGogJiYgYi5wdXNoKGgpKSk7XHJcbiAgICAgICAgICAgIHJldHVybiBnXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiB4YShhLCBiLCBjLCBkLCBlLCBmKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkICYmICFkW3VdICYmIChkID0geGEoZCkpLCBlICYmICFlW3VdICYmIChlID0geGEoZSwgZikpLCBpYShmdW5jdGlvbihmLCBnLCBoLCBpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaiwgaywgbCwgbSA9IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgIG4gPSBbXSxcclxuICAgICAgICAgICAgICAgICAgICBvID0gZy5sZW5ndGgsXHJcbiAgICAgICAgICAgICAgICAgICAgcCA9IGYgfHwgdmEoYiB8fCBcIipcIiwgaC5ub2RlVHlwZSA/IFtoXSA6IGgsIFtdKSxcclxuICAgICAgICAgICAgICAgICAgICBxID0gIWEgfHwgIWYgJiYgYiA/IHAgOiB3YShwLCBtLCBhLCBoLCBpKSxcclxuICAgICAgICAgICAgICAgICAgICByID0gYyA/IGUgfHwgKGYgPyBhIDogbyB8fCBkKSA/IFtdIDogZyA6IHE7XHJcbiAgICAgICAgICAgICAgICBpZiAoYyAmJiBjKHEsIHIsIGgsIGkpLCBkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaiA9IHdhKHIsIG4pLCBkKGosIFtdLCBoLCBpKSwgayA9IGoubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChrLS0pKGwgPSBqW2tdKSAmJiAocltuW2tdXSA9ICEocVtuW2tdXSA9IGwpKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGYpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZSB8fCBhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqID0gW10sIGsgPSByLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChrLS0pKGwgPSByW2tdKSAmJiBqLnB1c2gocVtrXSA9IGwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZShudWxsLCByID0gW10sIGosIGkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgayA9IHIubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoay0tKShsID0gcltrXSkgJiYgKGogPSBlID8gSShmLCBsKSA6IG1ba10pID4gLTEgJiYgKGZbal0gPSAhKGdbal0gPSBsKSlcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgciA9IHdhKHIgPT09IGcgPyByLnNwbGljZShvLCByLmxlbmd0aCkgOiByKSwgZSA/IGUobnVsbCwgZywgciwgaSkgOiBHLmFwcGx5KGcsIHIpXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiB5YShhKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGIsIGMsIGUsIGYgPSBhLmxlbmd0aCwgZyA9IGQucmVsYXRpdmVbYVswXS50eXBlXSwgaCA9IGcgfHwgZC5yZWxhdGl2ZVtcIiBcIl0sIGkgPSBnID8gMSA6IDAsIGsgPSB0YShmdW5jdGlvbihhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEgPT09IGJcclxuICAgICAgICAgICAgICAgIH0sIGgsICEwKSwgbCA9IHRhKGZ1bmN0aW9uKGEpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSShiLCBhKSA+IC0xXHJcbiAgICAgICAgICAgICAgICB9LCBoLCAhMCksIG0gPSBbZnVuY3Rpb24oYSwgYywgZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlID0gIWcgJiYgKGQgfHwgYyAhPT0gaikgfHwgKChiID0gYykubm9kZVR5cGUgPyBrKGEsIGMsIGQpIDogbChhLCBjLCBkKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGIgPSBudWxsLCBlXHJcbiAgICAgICAgICAgICAgICB9XTsgaSA8IGY7IGkrKylcclxuICAgICAgICAgICAgICAgIGlmIChjID0gZC5yZWxhdGl2ZVthW2ldLnR5cGVdKSBtID0gW3RhKHVhKG0pLCBjKV07XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYyA9IGQuZmlsdGVyW2FbaV0udHlwZV0uYXBwbHkobnVsbCwgYVtpXS5tYXRjaGVzKSwgY1t1XSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGUgPSArK2k7IGUgPCBmOyBlKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZC5yZWxhdGl2ZVthW2VdLnR5cGVdKSBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHhhKGkgPiAxICYmIHVhKG0pLCBpID4gMSAmJiBzYShhLnNsaWNlKDAsIGkgLSAxKS5jb25jYXQoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IFwiIFwiID09PSBhW2kgLSAyXS50eXBlID8gXCIqXCIgOiBcIlwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKS5yZXBsYWNlKFAsIFwiJDFcIiksIGMsIGkgPCBlICYmIHlhKGEuc2xpY2UoaSwgZSkpLCBlIDwgZiAmJiB5YShhID0gYS5zbGljZShlKSksIGUgPCBmICYmIHNhKGEpKVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBtLnB1c2goYylcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHVhKG0pXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiB6YShhLCBiKSB7XHJcbiAgICAgICAgICAgIHZhciBjID0gYi5sZW5ndGggPiAwLFxyXG4gICAgICAgICAgICAgICAgZSA9IGEubGVuZ3RoID4gMCxcclxuICAgICAgICAgICAgICAgIGYgPSBmdW5jdGlvbihmLCBnLCBoLCBpLCBrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGwsIG8sIHEsIHIgPSAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzID0gXCIwXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHQgPSBmICYmIFtdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1ID0gW10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHYgPSBqLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gZiB8fCBlICYmIGQuZmluZC5UQUcoXCIqXCIsIGspLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gdyArPSBudWxsID09IHYgPyAxIDogTWF0aC5yYW5kb20oKSB8fCAuMSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgeiA9IHgubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoayAmJiAoaiA9IGcgPT09IG4gfHwgZyB8fCBrKTsgcyAhPT0geiAmJiBudWxsICE9IChsID0geFtzXSk7IHMrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZSAmJiBsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvID0gMCwgZyB8fCBsLm93bmVyRG9jdW1lbnQgPT09IG4gfHwgKG0obCksIGggPSAhcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAocSA9IGFbbysrXSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocShsLCBnIHx8IG4sIGgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkucHVzaChsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrICYmICh3ID0geSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjICYmICgobCA9ICFxICYmIGwpICYmIHItLSwgZiAmJiB0LnB1c2gobCkpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyICs9IHMsIGMgJiYgcyAhPT0gcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHEgPSBiW28rK10pIHEodCwgdSwgZywgaCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAociA+IDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHMtLSkgdFtzXSB8fCB1W3NdIHx8ICh1W3NdID0gRS5jYWxsKGkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHUgPSB3YSh1KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIEcuYXBwbHkoaSwgdSksIGsgJiYgIWYgJiYgdS5sZW5ndGggPiAwICYmIHIgKyBiLmxlbmd0aCA+IDEgJiYgZ2EudW5pcXVlU29ydChpKVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gayAmJiAodyA9IHksIGogPSB2KSwgdFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIGMgPyBpYShmKSA6IGZcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGggPSBnYS5jb21waWxlID0gZnVuY3Rpb24oYSwgYikge1xyXG4gICAgICAgICAgICB2YXIgYywgZCA9IFtdLFxyXG4gICAgICAgICAgICAgICAgZSA9IFtdLFxyXG4gICAgICAgICAgICAgICAgZiA9IEFbYSArIFwiIFwiXTtcclxuICAgICAgICAgICAgaWYgKCFmKSB7XHJcbiAgICAgICAgICAgICAgICBiIHx8IChiID0gZyhhKSksIGMgPSBiLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChjLS0pIGYgPSB5YShiW2NdKSwgZlt1XSA/IGQucHVzaChmKSA6IGUucHVzaChmKTtcclxuICAgICAgICAgICAgICAgIGYgPSBBKGEsIHphKGUsIGQpKSwgZi5zZWxlY3RvciA9IGFcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZlxyXG4gICAgICAgIH0sIGkgPSBnYS5zZWxlY3QgPSBmdW5jdGlvbihhLCBiLCBjLCBlKSB7XHJcbiAgICAgICAgICAgIHZhciBmLCBpLCBqLCBrLCBsLCBtID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBhICYmIGEsXHJcbiAgICAgICAgICAgICAgICBuID0gIWUgJiYgZyhhID0gbS5zZWxlY3RvciB8fCBhKTtcclxuICAgICAgICAgICAgaWYgKGMgPSBjIHx8IFtdLCAxID09PSBuLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGkgPSBuWzBdID0gblswXS5zbGljZSgwKSwgaS5sZW5ndGggPiAyICYmIFwiSURcIiA9PT0gKGogPSBpWzBdKS50eXBlICYmIDkgPT09IGIubm9kZVR5cGUgJiYgcCAmJiBkLnJlbGF0aXZlW2lbMV0udHlwZV0pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYiA9IChkLmZpbmQuSUQoai5tYXRjaGVzWzBdLnJlcGxhY2UoXywgYWEpLCBiKSB8fCBbXSlbMF0sICFiKSByZXR1cm4gYztcclxuICAgICAgICAgICAgICAgICAgICBtICYmIChiID0gYi5wYXJlbnROb2RlKSwgYSA9IGEuc2xpY2UoaS5zaGlmdCgpLnZhbHVlLmxlbmd0aClcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGYgPSBWLm5lZWRzQ29udGV4dC50ZXN0KGEpID8gMCA6IGkubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGYtLSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChqID0gaVtmXSwgZC5yZWxhdGl2ZVtrID0gai50eXBlXSkgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChsID0gZC5maW5kW2tdKSAmJiAoZSA9IGwoai5tYXRjaGVzWzBdLnJlcGxhY2UoXywgYWEpLCAkLnRlc3QoaVswXS50eXBlKSAmJiBxYShiLnBhcmVudE5vZGUpIHx8IGIpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaS5zcGxpY2UoZiwgMSksIGEgPSBlLmxlbmd0aCAmJiBzYShpKSwgIWEpIHJldHVybiBHLmFwcGx5KGMsIGUpLCBjO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVha1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gKG0gfHwgaChhLCBuKSkoZSwgYiwgIXAsIGMsICFiIHx8ICQudGVzdChhKSAmJiBxYShiLnBhcmVudE5vZGUpIHx8IGIpLCBjXHJcbiAgICAgICAgfSwgYy5zb3J0U3RhYmxlID0gdS5zcGxpdChcIlwiKS5zb3J0KEIpLmpvaW4oXCJcIikgPT09IHUsIGMuZGV0ZWN0RHVwbGljYXRlcyA9ICEhbCwgbSgpLCBjLnNvcnREZXRhY2hlZCA9IGphKGZ1bmN0aW9uKGEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDEgJiBhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKG4uY3JlYXRlRWxlbWVudChcImZpZWxkc2V0XCIpKVxyXG4gICAgICAgIH0pLCBqYShmdW5jdGlvbihhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhLmlubmVySFRNTCA9IFwiPGEgaHJlZj0nIyc+PC9hPlwiLCBcIiNcIiA9PT0gYS5maXJzdENoaWxkLmdldEF0dHJpYnV0ZShcImhyZWZcIilcclxuICAgICAgICB9KSB8fCBrYShcInR5cGV8aHJlZnxoZWlnaHR8d2lkdGhcIiwgZnVuY3Rpb24oYSwgYiwgYykge1xyXG4gICAgICAgICAgICBpZiAoIWMpIHJldHVybiBhLmdldEF0dHJpYnV0ZShiLCBcInR5cGVcIiA9PT0gYi50b0xvd2VyQ2FzZSgpID8gMSA6IDIpXHJcbiAgICAgICAgfSksIGMuYXR0cmlidXRlcyAmJiBqYShmdW5jdGlvbihhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhLmlubmVySFRNTCA9IFwiPGlucHV0Lz5cIiwgYS5maXJzdENoaWxkLnNldEF0dHJpYnV0ZShcInZhbHVlXCIsIFwiXCIpLCBcIlwiID09PSBhLmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKFwidmFsdWVcIilcclxuICAgICAgICB9KSB8fCBrYShcInZhbHVlXCIsIGZ1bmN0aW9uKGEsIGIsIGMpIHtcclxuICAgICAgICAgICAgaWYgKCFjICYmIFwiaW5wdXRcIiA9PT0gYS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKSByZXR1cm4gYS5kZWZhdWx0VmFsdWVcclxuICAgICAgICB9KSwgamEoZnVuY3Rpb24oYSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbCA9PSBhLmdldEF0dHJpYnV0ZShcImRpc2FibGVkXCIpXHJcbiAgICAgICAgfSkgfHwga2EoSiwgZnVuY3Rpb24oYSwgYiwgYykge1xyXG4gICAgICAgICAgICB2YXIgZDtcclxuICAgICAgICAgICAgaWYgKCFjKSByZXR1cm4gYVtiXSA9PT0gITAgPyBiLnRvTG93ZXJDYXNlKCkgOiAoZCA9IGEuZ2V0QXR0cmlidXRlTm9kZShiKSkgJiYgZC5zcGVjaWZpZWQgPyBkLnZhbHVlIDogbnVsbFxyXG4gICAgICAgIH0pLCBnYVxyXG4gICAgfShhKTtcclxuICAgIHIuZmluZCA9IHgsIHIuZXhwciA9IHguc2VsZWN0b3JzLCByLmV4cHJbXCI6XCJdID0gci5leHByLnBzZXVkb3MsIHIudW5pcXVlU29ydCA9IHIudW5pcXVlID0geC51bmlxdWVTb3J0LCByLnRleHQgPSB4LmdldFRleHQsIHIuaXNYTUxEb2MgPSB4LmlzWE1MLCByLmNvbnRhaW5zID0geC5jb250YWlucywgci5lc2NhcGVTZWxlY3RvciA9IHguZXNjYXBlO1xyXG4gICAgdmFyIHkgPSBmdW5jdGlvbihhLCBiLCBjKSB7XHJcbiAgICAgICAgICAgIHZhciBkID0gW10sXHJcbiAgICAgICAgICAgICAgICBlID0gdm9pZCAwICE9PSBjO1xyXG4gICAgICAgICAgICB3aGlsZSAoKGEgPSBhW2JdKSAmJiA5ICE9PSBhLm5vZGVUeXBlKVxyXG4gICAgICAgICAgICAgICAgaWYgKDEgPT09IGEubm9kZVR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZSAmJiByKGEpLmlzKGMpKSBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBkLnB1c2goYSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGRcclxuICAgICAgICB9LFxyXG4gICAgICAgIHogPSBmdW5jdGlvbihhLCBiKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGMgPSBbXTsgYTsgYSA9IGEubmV4dFNpYmxpbmcpIDEgPT09IGEubm9kZVR5cGUgJiYgYSAhPT0gYiAmJiBjLnB1c2goYSk7XHJcbiAgICAgICAgICAgIHJldHVybiBjXHJcbiAgICAgICAgfSxcclxuICAgICAgICBBID0gci5leHByLm1hdGNoLm5lZWRzQ29udGV4dDtcclxuXHJcbiAgICBmdW5jdGlvbiBCKGEsIGIpIHtcclxuICAgICAgICByZXR1cm4gYS5ub2RlTmFtZSAmJiBhLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IGIudG9Mb3dlckNhc2UoKVxyXG4gICAgfVxyXG4gICAgdmFyIEMgPSAvXjwoW2Etel1bXlxcL1xcMD46XFx4MjBcXHRcXHJcXG5cXGZdKilbXFx4MjBcXHRcXHJcXG5cXGZdKlxcLz8+KD86PFxcL1xcMT58KSQvaSxcclxuICAgICAgICBEID0gL14uW146I1xcW1xcLixdKiQvO1xyXG5cclxuICAgIGZ1bmN0aW9uIEUoYSwgYiwgYykge1xyXG4gICAgICAgIHJldHVybiByLmlzRnVuY3Rpb24oYikgPyByLmdyZXAoYSwgZnVuY3Rpb24oYSwgZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gISFiLmNhbGwoYSwgZCwgYSkgIT09IGNcclxuICAgICAgICB9KSA6IGIubm9kZVR5cGUgPyByLmdyZXAoYSwgZnVuY3Rpb24oYSkge1xyXG4gICAgICAgICAgICByZXR1cm4gYSA9PT0gYiAhPT0gY1xyXG4gICAgICAgIH0pIDogXCJzdHJpbmdcIiAhPSB0eXBlb2YgYiA/IHIuZ3JlcChhLCBmdW5jdGlvbihhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpLmNhbGwoYiwgYSkgPiAtMSAhPT0gY1xyXG4gICAgICAgIH0pIDogRC50ZXN0KGIpID8gci5maWx0ZXIoYiwgYSwgYykgOiAoYiA9IHIuZmlsdGVyKGIsIGEpLCByLmdyZXAoYSwgZnVuY3Rpb24oYSkge1xyXG4gICAgICAgICAgICByZXR1cm4gaS5jYWxsKGIsIGEpID4gLTEgIT09IGMgJiYgMSA9PT0gYS5ub2RlVHlwZVxyXG4gICAgICAgIH0pKVxyXG4gICAgfVxyXG4gICAgci5maWx0ZXIgPSBmdW5jdGlvbihhLCBiLCBjKSB7XHJcbiAgICAgICAgdmFyIGQgPSBiWzBdO1xyXG4gICAgICAgIHJldHVybiBjICYmIChhID0gXCI6bm90KFwiICsgYSArIFwiKVwiKSwgMSA9PT0gYi5sZW5ndGggJiYgMSA9PT0gZC5ub2RlVHlwZSA/IHIuZmluZC5tYXRjaGVzU2VsZWN0b3IoZCwgYSkgPyBbZF0gOiBbXSA6IHIuZmluZC5tYXRjaGVzKGEsIHIuZ3JlcChiLCBmdW5jdGlvbihhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAxID09PSBhLm5vZGVUeXBlXHJcbiAgICAgICAgfSkpXHJcbiAgICB9LCByLmZuLmV4dGVuZCh7XHJcbiAgICAgICAgZmluZDogZnVuY3Rpb24oYSkge1xyXG4gICAgICAgICAgICB2YXIgYiwgYywgZCA9IHRoaXMubGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgZSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGlmIChcInN0cmluZ1wiICE9IHR5cGVvZiBhKSByZXR1cm4gdGhpcy5wdXNoU3RhY2socihhKS5maWx0ZXIoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGIgPSAwOyBiIDwgZDsgYisrKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyLmNvbnRhaW5zKGVbYl0sIHRoaXMpKSByZXR1cm4gITBcclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICBmb3IgKGMgPSB0aGlzLnB1c2hTdGFjayhbXSksIGIgPSAwOyBiIDwgZDsgYisrKSByLmZpbmQoYSwgZVtiXSwgYyk7XHJcbiAgICAgICAgICAgIHJldHVybiBkID4gMSA/IHIudW5pcXVlU29ydChjKSA6IGNcclxuICAgICAgICB9LFxyXG4gICAgICAgIGZpbHRlcjogZnVuY3Rpb24oYSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wdXNoU3RhY2soRSh0aGlzLCBhIHx8IFtdLCAhMSkpXHJcbiAgICAgICAgfSxcclxuICAgICAgICBub3Q6IGZ1bmN0aW9uKGEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKEUodGhpcywgYSB8fCBbXSwgITApKVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaXM6IGZ1bmN0aW9uKGEpIHtcclxuICAgICAgICAgICAgcmV0dXJuICEhRSh0aGlzLCBcInN0cmluZ1wiID09IHR5cGVvZiBhICYmIEEudGVzdChhKSA/IHIoYSkgOiBhIHx8IFtdLCAhMSkubGVuZ3RoXHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICB2YXIgRiwgRyA9IC9eKD86XFxzKig8W1xcd1xcV10rPilbXj5dKnwjKFtcXHctXSspKSQvLFxyXG4gICAgICAgIEggPSByLmZuLmluaXQgPSBmdW5jdGlvbihhLCBiLCBjKSB7XHJcbiAgICAgICAgICAgIHZhciBlLCBmO1xyXG4gICAgICAgICAgICBpZiAoIWEpIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICBpZiAoYyA9IGMgfHwgRiwgXCJzdHJpbmdcIiA9PSB0eXBlb2YgYSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGUgPSBcIjxcIiA9PT0gYVswXSAmJiBcIj5cIiA9PT0gYVthLmxlbmd0aCAtIDFdICYmIGEubGVuZ3RoID49IDMgPyBbbnVsbCwgYSwgbnVsbF0gOiBHLmV4ZWMoYSksICFlIHx8ICFlWzFdICYmIGIpIHJldHVybiAhYiB8fCBiLmpxdWVyeSA/IChiIHx8IGMpLmZpbmQoYSkgOiB0aGlzLmNvbnN0cnVjdG9yKGIpLmZpbmQoYSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZVsxXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChiID0gYiBpbnN0YW5jZW9mIHIgPyBiWzBdIDogYiwgci5tZXJnZSh0aGlzLCByLnBhcnNlSFRNTChlWzFdLCBiICYmIGIubm9kZVR5cGUgPyBiLm93bmVyRG9jdW1lbnQgfHwgYiA6IGQsICEwKSksIEMudGVzdChlWzFdKSAmJiByLmlzUGxhaW5PYmplY3QoYikpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoZSBpbiBiKSByLmlzRnVuY3Rpb24odGhpc1tlXSkgPyB0aGlzW2VdKGJbZV0pIDogdGhpcy5hdHRyKGUsIGJbZV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZiA9IGQuZ2V0RWxlbWVudEJ5SWQoZVsyXSksIGYgJiYgKHRoaXNbMF0gPSBmLCB0aGlzLmxlbmd0aCA9IDEpLCB0aGlzXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGEubm9kZVR5cGUgPyAodGhpc1swXSA9IGEsIHRoaXMubGVuZ3RoID0gMSwgdGhpcykgOiByLmlzRnVuY3Rpb24oYSkgPyB2b2lkIDAgIT09IGMucmVhZHkgPyBjLnJlYWR5KGEpIDogYShyKSA6IHIubWFrZUFycmF5KGEsIHRoaXMpXHJcbiAgICAgICAgfTtcclxuICAgIEgucHJvdG90eXBlID0gci5mbiwgRiA9IHIoZCk7XHJcbiAgICB2YXIgSSA9IC9eKD86cGFyZW50c3xwcmV2KD86VW50aWx8QWxsKSkvLFxyXG4gICAgICAgIEogPSB7XHJcbiAgICAgICAgICAgIGNoaWxkcmVuOiAhMCxcclxuICAgICAgICAgICAgY29udGVudHM6ICEwLFxyXG4gICAgICAgICAgICBuZXh0OiAhMCxcclxuICAgICAgICAgICAgcHJldjogITBcclxuICAgICAgICB9O1xyXG4gICAgci5mbi5leHRlbmQoe1xyXG4gICAgICAgIGhhczogZnVuY3Rpb24oYSkge1xyXG4gICAgICAgICAgICB2YXIgYiA9IHIoYSwgdGhpcyksXHJcbiAgICAgICAgICAgICAgICBjID0gYi5sZW5ndGg7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbHRlcihmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGEgPSAwOyBhIDwgYzsgYSsrKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyLmNvbnRhaW5zKHRoaXMsIGJbYV0pKSByZXR1cm4gITBcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNsb3Nlc3Q6IGZ1bmN0aW9uKGEsIGIpIHtcclxuICAgICAgICAgICAgdmFyIGMsIGQgPSAwLFxyXG4gICAgICAgICAgICAgICAgZSA9IHRoaXMubGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgZiA9IFtdLFxyXG4gICAgICAgICAgICAgICAgZyA9IFwic3RyaW5nXCIgIT0gdHlwZW9mIGEgJiYgcihhKTtcclxuICAgICAgICAgICAgaWYgKCFBLnRlc3QoYSkpXHJcbiAgICAgICAgICAgICAgICBmb3IgKDsgZCA8IGU7IGQrKylcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGMgPSB0aGlzW2RdOyBjICYmIGMgIT09IGI7IGMgPSBjLnBhcmVudE5vZGUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjLm5vZGVUeXBlIDwgMTEgJiYgKGcgPyBnLmluZGV4KGMpID4gLTEgOiAxID09PSBjLm5vZGVUeXBlICYmIHIuZmluZC5tYXRjaGVzU2VsZWN0b3IoYywgYSkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmLnB1c2goYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVha1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnB1c2hTdGFjayhmLmxlbmd0aCA+IDEgPyByLnVuaXF1ZVNvcnQoZikgOiBmKVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaW5kZXg6IGZ1bmN0aW9uKGEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGEgPyBcInN0cmluZ1wiID09IHR5cGVvZiBhID8gaS5jYWxsKHIoYSksIHRoaXNbMF0pIDogaS5jYWxsKHRoaXMsIGEuanF1ZXJ5ID8gYVswXSA6IGEpIDogdGhpc1swXSAmJiB0aGlzWzBdLnBhcmVudE5vZGUgPyB0aGlzLmZpcnN0KCkucHJldkFsbCgpLmxlbmd0aCA6IC0xXHJcbiAgICAgICAgfSxcclxuICAgICAgICBhZGQ6IGZ1bmN0aW9uKGEsIGIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKHIudW5pcXVlU29ydChyLm1lcmdlKHRoaXMuZ2V0KCksIHIoYSwgYikpKSlcclxuICAgICAgICB9LFxyXG4gICAgICAgIGFkZEJhY2s6IGZ1bmN0aW9uKGEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkKG51bGwgPT0gYSA/IHRoaXMucHJldk9iamVjdCA6IHRoaXMucHJldk9iamVjdC5maWx0ZXIoYSkpXHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgZnVuY3Rpb24gSyhhLCBiKSB7XHJcbiAgICAgICAgd2hpbGUgKChhID0gYVtiXSkgJiYgMSAhPT0gYS5ub2RlVHlwZSk7XHJcbiAgICAgICAgcmV0dXJuIGFcclxuICAgIH1cclxuICAgIHIuZWFjaCh7XHJcbiAgICAgICAgcGFyZW50OiBmdW5jdGlvbihhKSB7XHJcbiAgICAgICAgICAgIHZhciBiID0gYS5wYXJlbnROb2RlO1xyXG4gICAgICAgICAgICByZXR1cm4gYiAmJiAxMSAhPT0gYi5ub2RlVHlwZSA/IGIgOiBudWxsXHJcbiAgICAgICAgfSxcclxuICAgICAgICBwYXJlbnRzOiBmdW5jdGlvbihhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB5KGEsIFwicGFyZW50Tm9kZVwiKVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcGFyZW50c1VudGlsOiBmdW5jdGlvbihhLCBiLCBjKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB5KGEsIFwicGFyZW50Tm9kZVwiLCBjKVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbmV4dDogZnVuY3Rpb24oYSkge1xyXG4gICAgICAgICAgICByZXR1cm4gSyhhLCBcIm5leHRTaWJsaW5nXCIpXHJcbiAgICAgICAgfSxcclxuICAgICAgICBwcmV2OiBmdW5jdGlvbihhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBLKGEsIFwicHJldmlvdXNTaWJsaW5nXCIpXHJcbiAgICAgICAgfSxcclxuICAgICAgICBuZXh0QWxsOiBmdW5jdGlvbihhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB5KGEsIFwibmV4dFNpYmxpbmdcIilcclxuICAgICAgICB9LFxyXG4gICAgICAgIHByZXZBbGw6IGZ1bmN0aW9uKGEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHkoYSwgXCJwcmV2aW91c1NpYmxpbmdcIilcclxuICAgICAgICB9LFxyXG4gICAgICAgIG5leHRVbnRpbDogZnVuY3Rpb24oYSwgYiwgYykge1xyXG4gICAgICAgICAgICByZXR1cm4geShhLCBcIm5leHRTaWJsaW5nXCIsIGMpXHJcbiAgICAgICAgfSxcclxuICAgICAgICBwcmV2VW50aWw6IGZ1bmN0aW9uKGEsIGIsIGMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHkoYSwgXCJwcmV2aW91c1NpYmxpbmdcIiwgYylcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNpYmxpbmdzOiBmdW5jdGlvbihhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB6KChhLnBhcmVudE5vZGUgfHwge30pLmZpcnN0Q2hpbGQsIGEpXHJcbiAgICAgICAgfSxcclxuICAgICAgICBjaGlsZHJlbjogZnVuY3Rpb24oYSkge1xyXG4gICAgICAgICAgICByZXR1cm4geihhLmZpcnN0Q2hpbGQpXHJcbiAgICAgICAgfSxcclxuICAgICAgICBjb250ZW50czogZnVuY3Rpb24oYSkge1xyXG4gICAgICAgICAgICByZXR1cm4gQihhLCBcImlmcmFtZVwiKSA/IGEuY29udGVudERvY3VtZW50IDogKEIoYSwgXCJ0ZW1wbGF0ZVwiKSAmJiAoYSA9IGEuY29udGVudCB8fCBhKSwgci5tZXJnZShbXSwgYS5jaGlsZE5vZGVzKSlcclxuICAgICAgICB9XHJcbiAgICB9LCBmdW5jdGlvbihhLCBiKSB7XHJcbiAgICAgICAgci5mblthXSA9IGZ1bmN0aW9uKGMsIGQpIHtcclxuICAgICAgICAgICAgdmFyIGUgPSByLm1hcCh0aGlzLCBiLCBjKTtcclxuICAgICAgICAgICAgcmV0dXJuIFwiVW50aWxcIiAhPT0gYS5zbGljZSgtNSkgJiYgKGQgPSBjKSwgZCAmJiBcInN0cmluZ1wiID09IHR5cGVvZiBkICYmIChlID0gci5maWx0ZXIoZCwgZSkpLCB0aGlzLmxlbmd0aCA+IDEgJiYgKEpbYV0gfHwgci51bmlxdWVTb3J0KGUpLCBJLnRlc3QoYSkgJiYgZS5yZXZlcnNlKCkpLCB0aGlzLnB1c2hTdGFjayhlKVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgdmFyIEwgPSAvW15cXHgyMFxcdFxcclxcblxcZl0rL2c7XHJcblxyXG4gICAgZnVuY3Rpb24gTShhKSB7XHJcbiAgICAgICAgdmFyIGIgPSB7fTtcclxuICAgICAgICByZXR1cm4gci5lYWNoKGEubWF0Y2goTCkgfHwgW10sIGZ1bmN0aW9uKGEsIGMpIHtcclxuICAgICAgICAgICAgYltjXSA9ICEwXHJcbiAgICAgICAgfSksIGJcclxuICAgIH1cclxuICAgIHIuQ2FsbGJhY2tzID0gZnVuY3Rpb24oYSkge1xyXG4gICAgICAgIGEgPSBcInN0cmluZ1wiID09IHR5cGVvZiBhID8gTShhKSA6IHIuZXh0ZW5kKHt9LCBhKTtcclxuICAgICAgICB2YXIgYiwgYywgZCwgZSwgZiA9IFtdLFxyXG4gICAgICAgICAgICBnID0gW10sXHJcbiAgICAgICAgICAgIGggPSAtMSxcclxuICAgICAgICAgICAgaSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgZm9yIChlID0gZSB8fCBhLm9uY2UsIGQgPSBiID0gITA7IGcubGVuZ3RoOyBoID0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICBjID0gZy5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICgrK2ggPCBmLmxlbmd0aCkgZltoXS5hcHBseShjWzBdLCBjWzFdKSA9PT0gITEgJiYgYS5zdG9wT25GYWxzZSAmJiAoaCA9IGYubGVuZ3RoLCBjID0gITEpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBhLm1lbW9yeSB8fCAoYyA9ICExKSwgYiA9ICExLCBlICYmIChmID0gYyA/IFtdIDogXCJcIilcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgaiA9IHtcclxuICAgICAgICAgICAgICAgIGFkZDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGYgJiYgKGMgJiYgIWIgJiYgKGggPSBmLmxlbmd0aCAtIDEsIGcucHVzaChjKSksIGZ1bmN0aW9uIGQoYikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByLmVhY2goYiwgZnVuY3Rpb24oYiwgYykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgci5pc0Z1bmN0aW9uKGMpID8gYS51bmlxdWUgJiYgai5oYXMoYykgfHwgZi5wdXNoKGMpIDogYyAmJiBjLmxlbmd0aCAmJiBcInN0cmluZ1wiICE9PSByLnR5cGUoYykgJiYgZChjKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIH0oYXJndW1lbnRzKSwgYyAmJiAhYiAmJiBpKCkpLCB0aGlzXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gci5lYWNoKGFyZ3VtZW50cywgZnVuY3Rpb24oYSwgYikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYztcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKChjID0gci5pbkFycmF5KGIsIGYsIGMpKSA+IC0xKSBmLnNwbGljZShjLCAxKSwgYyA8PSBoICYmIGgtLVxyXG4gICAgICAgICAgICAgICAgICAgIH0pLCB0aGlzXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgaGFzOiBmdW5jdGlvbihhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEgPyByLmluQXJyYXkoYSwgZikgPiAtMSA6IGYubGVuZ3RoID4gMFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGVtcHR5OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZiAmJiAoZiA9IFtdKSwgdGhpc1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGRpc2FibGU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlID0gZyA9IFtdLCBmID0gYyA9IFwiXCIsIHRoaXNcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBkaXNhYmxlZDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFmXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgbG9jazogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUgPSBnID0gW10sIGMgfHwgYiB8fCAoZiA9IGMgPSBcIlwiKSwgdGhpc1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGxvY2tlZDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEhZVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGZpcmVXaXRoOiBmdW5jdGlvbihhLCBjKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUgfHwgKGMgPSBjIHx8IFtdLCBjID0gW2EsIGMuc2xpY2UgPyBjLnNsaWNlKCkgOiBjXSwgZy5wdXNoKGMpLCBiIHx8IGkoKSksIHRoaXNcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBmaXJlOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gai5maXJlV2l0aCh0aGlzLCBhcmd1bWVudHMpLCB0aGlzXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZmlyZWQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhIWRcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4galxyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBOKGEpIHtcclxuICAgICAgICByZXR1cm4gYVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIE8oYSkge1xyXG4gICAgICAgIHRocm93IGFcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBQKGEsIGIsIGMsIGQpIHtcclxuICAgICAgICB2YXIgZTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBhICYmIHIuaXNGdW5jdGlvbihlID0gYS5wcm9taXNlKSA/IGUuY2FsbChhKS5kb25lKGIpLmZhaWwoYykgOiBhICYmIHIuaXNGdW5jdGlvbihlID0gYS50aGVuKSA/IGUuY2FsbChhLCBiLCBjKSA6IGIuYXBwbHkodm9pZCAwLCBbYV0uc2xpY2UoZCkpXHJcbiAgICAgICAgfSBjYXRjaCAoYSkge1xyXG4gICAgICAgICAgICBjLmFwcGx5KHZvaWQgMCwgW2FdKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHIuZXh0ZW5kKHtcclxuICAgICAgICBEZWZlcnJlZDogZnVuY3Rpb24oYikge1xyXG4gICAgICAgICAgICB2YXIgYyA9IFtcclxuICAgICAgICAgICAgICAgICAgICBbXCJub3RpZnlcIiwgXCJwcm9ncmVzc1wiLCByLkNhbGxiYWNrcyhcIm1lbW9yeVwiKSwgci5DYWxsYmFja3MoXCJtZW1vcnlcIiksIDJdLFxyXG4gICAgICAgICAgICAgICAgICAgIFtcInJlc29sdmVcIiwgXCJkb25lXCIsIHIuQ2FsbGJhY2tzKFwib25jZSBtZW1vcnlcIiksIHIuQ2FsbGJhY2tzKFwib25jZSBtZW1vcnlcIiksIDAsIFwicmVzb2x2ZWRcIl0sXHJcbiAgICAgICAgICAgICAgICAgICAgW1wicmVqZWN0XCIsIFwiZmFpbFwiLCByLkNhbGxiYWNrcyhcIm9uY2UgbWVtb3J5XCIpLCByLkNhbGxiYWNrcyhcIm9uY2UgbWVtb3J5XCIpLCAxLCBcInJlamVjdGVkXCJdXHJcbiAgICAgICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICAgICAgZCA9IFwicGVuZGluZ1wiLFxyXG4gICAgICAgICAgICAgICAgZSA9IHtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0ZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBhbHdheXM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZi5kb25lKGFyZ3VtZW50cykuZmFpbChhcmd1bWVudHMpLCB0aGlzXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBcImNhdGNoXCI6IGZ1bmN0aW9uKGEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUudGhlbihudWxsLCBhKVxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgcGlwZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhID0gYXJndW1lbnRzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gci5EZWZlcnJlZChmdW5jdGlvbihiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByLmVhY2goYywgZnVuY3Rpb24oYywgZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlID0gci5pc0Z1bmN0aW9uKGFbZFs0XV0pICYmIGFbZFs0XV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZltkWzFdXShmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBlICYmIGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYSAmJiByLmlzRnVuY3Rpb24oYS5wcm9taXNlKSA/IGEucHJvbWlzZSgpLnByb2dyZXNzKGIubm90aWZ5KS5kb25lKGIucmVzb2x2ZSkuZmFpbChiLnJlamVjdCkgOiBiW2RbMF0gKyBcIldpdGhcIl0odGhpcywgZSA/IFthXSA6IGFyZ3VtZW50cylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksIGEgPSBudWxsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLnByb21pc2UoKVxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgdGhlbjogZnVuY3Rpb24oYiwgZCwgZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZiA9IDA7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBnKGIsIGMsIGQsIGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaCA9IHRoaXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBhcmd1bWVudHMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGogPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhLCBqO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoYiA8IGYpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGEgPSBkLmFwcGx5KGgsIGkpLCBhID09PSBjLnByb21pc2UoKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoZW5hYmxlIHNlbGYtcmVzb2x1dGlvblwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqID0gYSAmJiAoXCJvYmplY3RcIiA9PSB0eXBlb2YgYSB8fCBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGEpICYmIGEudGhlbiwgci5pc0Z1bmN0aW9uKGopID8gZSA/IGouY2FsbChhLCBnKGYsIGMsIE4sIGUpLCBnKGYsIGMsIE8sIGUpKSA6IChmKyssIGouY2FsbChhLCBnKGYsIGMsIE4sIGUpLCBnKGYsIGMsIE8sIGUpLCBnKGYsIGMsIE4sIGMubm90aWZ5V2l0aCkpKSA6IChkICE9PSBOICYmIChoID0gdm9pZCAwLCBpID0gW2FdKSwgKGUgfHwgYy5yZXNvbHZlV2l0aCkoaCwgaSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGsgPSBlID8gaiA6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByLkRlZmVycmVkLmV4Y2VwdGlvbkhvb2sgJiYgci5EZWZlcnJlZC5leGNlcHRpb25Ib29rKGEsIGsuc3RhY2tUcmFjZSksIGIgKyAxID49IGYgJiYgKGQgIT09IE8gJiYgKGggPSB2b2lkIDAsIGkgPSBbYV0pLCBjLnJlamVjdFdpdGgoaCwgaSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYiA/IGsoKSA6IChyLkRlZmVycmVkLmdldFN0YWNrSG9vayAmJiAoay5zdGFja1RyYWNlID0gci5EZWZlcnJlZC5nZXRTdGFja0hvb2soKSksIGEuc2V0VGltZW91dChrKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gci5EZWZlcnJlZChmdW5jdGlvbihhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjWzBdWzNdLmFkZChnKDAsIGEsIHIuaXNGdW5jdGlvbihlKSA/IGUgOiBOLCBhLm5vdGlmeVdpdGgpKSwgY1sxXVszXS5hZGQoZygwLCBhLCByLmlzRnVuY3Rpb24oYikgPyBiIDogTikpLCBjWzJdWzNdLmFkZChnKDAsIGEsIHIuaXNGdW5jdGlvbihkKSA/IGQgOiBPKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSkucHJvbWlzZSgpXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBwcm9taXNlOiBmdW5jdGlvbihhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsICE9IGEgPyByLmV4dGVuZChhLCBlKSA6IGVcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZiA9IHt9O1xyXG4gICAgICAgICAgICByZXR1cm4gci5lYWNoKGMsIGZ1bmN0aW9uKGEsIGIpIHtcclxuICAgICAgICAgICAgICAgIHZhciBnID0gYlsyXSxcclxuICAgICAgICAgICAgICAgICAgICBoID0gYls1XTtcclxuICAgICAgICAgICAgICAgIGVbYlsxXV0gPSBnLmFkZCwgaCAmJiBnLmFkZChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICBkID0gaFxyXG4gICAgICAgICAgICAgICAgfSwgY1szIC0gYV1bMl0uZGlzYWJsZSwgY1swXVsyXS5sb2NrKSwgZy5hZGQoYlszXS5maXJlKSwgZltiWzBdXSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmW2JbMF0gKyBcIldpdGhcIl0odGhpcyA9PT0gZiA/IHZvaWQgMCA6IHRoaXMsIGFyZ3VtZW50cyksIHRoaXNcclxuICAgICAgICAgICAgICAgIH0sIGZbYlswXSArIFwiV2l0aFwiXSA9IGcuZmlyZVdpdGhcclxuICAgICAgICAgICAgfSksIGUucHJvbWlzZShmKSwgYiAmJiBiLmNhbGwoZiwgZiksIGZcclxuICAgICAgICB9LFxyXG4gICAgICAgIHdoZW46IGZ1bmN0aW9uKGEpIHtcclxuICAgICAgICAgICAgdmFyIGIgPSBhcmd1bWVudHMubGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgYyA9IGIsXHJcbiAgICAgICAgICAgICAgICBkID0gQXJyYXkoYyksXHJcbiAgICAgICAgICAgICAgICBlID0gZi5jYWxsKGFyZ3VtZW50cyksXHJcbiAgICAgICAgICAgICAgICBnID0gci5EZWZlcnJlZCgpLFxyXG4gICAgICAgICAgICAgICAgaCA9IGZ1bmN0aW9uKGEpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oYykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkW2FdID0gdGhpcywgZVthXSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gZi5jYWxsKGFyZ3VtZW50cykgOiBjLCAtLWIgfHwgZy5yZXNvbHZlV2l0aChkLCBlKVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGlmIChiIDw9IDEgJiYgKFAoYSwgZy5kb25lKGgoYykpLnJlc29sdmUsIGcucmVqZWN0LCAhYiksIFwicGVuZGluZ1wiID09PSBnLnN0YXRlKCkgfHwgci5pc0Z1bmN0aW9uKGVbY10gJiYgZVtjXS50aGVuKSkpIHJldHVybiBnLnRoZW4oKTtcclxuICAgICAgICAgICAgd2hpbGUgKGMtLSkgUChlW2NdLCBoKGMpLCBnLnJlamVjdCk7XHJcbiAgICAgICAgICAgIHJldHVybiBnLnByb21pc2UoKVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgdmFyIFEgPSAvXihFdmFsfEludGVybmFsfFJhbmdlfFJlZmVyZW5jZXxTeW50YXh8VHlwZXxVUkkpRXJyb3IkLztcclxuICAgIHIuRGVmZXJyZWQuZXhjZXB0aW9uSG9vayA9IGZ1bmN0aW9uKGIsIGMpIHtcclxuICAgICAgICBhLmNvbnNvbGUgJiYgYS5jb25zb2xlLndhcm4gJiYgYiAmJiBRLnRlc3QoYi5uYW1lKSAmJiBhLmNvbnNvbGUud2FybihcImpRdWVyeS5EZWZlcnJlZCBleGNlcHRpb246IFwiICsgYi5tZXNzYWdlLCBiLnN0YWNrLCBjKVxyXG4gICAgfSwgci5yZWFkeUV4Y2VwdGlvbiA9IGZ1bmN0aW9uKGIpIHtcclxuICAgICAgICBhLnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRocm93IGJcclxuICAgICAgICB9KVxyXG4gICAgfTtcclxuICAgIHZhciBSID0gci5EZWZlcnJlZCgpO1xyXG4gICAgci5mbi5yZWFkeSA9IGZ1bmN0aW9uKGEpIHtcclxuICAgICAgICByZXR1cm4gUi50aGVuKGEpW1wiY2F0Y2hcIl0oZnVuY3Rpb24oYSkge1xyXG4gICAgICAgICAgICByLnJlYWR5RXhjZXB0aW9uKGEpXHJcbiAgICAgICAgfSksIHRoaXNcclxuICAgIH0sIHIuZXh0ZW5kKHtcclxuICAgICAgICBpc1JlYWR5OiAhMSxcclxuICAgICAgICByZWFkeVdhaXQ6IDEsXHJcbiAgICAgICAgcmVhZHk6IGZ1bmN0aW9uKGEpIHtcclxuICAgICAgICAgICAgKGEgPT09ICEwID8gLS1yLnJlYWR5V2FpdCA6IHIuaXNSZWFkeSkgfHwgKHIuaXNSZWFkeSA9ICEwLCBhICE9PSAhMCAmJiAtLXIucmVhZHlXYWl0ID4gMCB8fCBSLnJlc29sdmVXaXRoKGQsIFtyXSkpXHJcbiAgICAgICAgfVxyXG4gICAgfSksIHIucmVhZHkudGhlbiA9IFIudGhlbjtcclxuXHJcbiAgICBmdW5jdGlvbiBTKCkge1xyXG4gICAgICAgIGQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgUyksXHJcbiAgICAgICAgICAgIGEucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgUyksIHIucmVhZHkoKVxyXG4gICAgfVxyXG4gICAgXCJjb21wbGV0ZVwiID09PSBkLnJlYWR5U3RhdGUgfHwgXCJsb2FkaW5nXCIgIT09IGQucmVhZHlTdGF0ZSAmJiAhZC5kb2N1bWVudEVsZW1lbnQuZG9TY3JvbGwgPyBhLnNldFRpbWVvdXQoci5yZWFkeSkgOiAoZC5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLCBTKSwgYS5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCBTKSk7XHJcbiAgICB2YXIgVCA9IGZ1bmN0aW9uKGEsIGIsIGMsIGQsIGUsIGYsIGcpIHtcclxuICAgICAgICAgICAgdmFyIGggPSAwLFxyXG4gICAgICAgICAgICAgICAgaSA9IGEubGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgaiA9IG51bGwgPT0gYztcclxuICAgICAgICAgICAgaWYgKFwib2JqZWN0XCIgPT09IHIudHlwZShjKSkge1xyXG4gICAgICAgICAgICAgICAgZSA9ICEwO1xyXG4gICAgICAgICAgICAgICAgZm9yIChoIGluIGMpIFQoYSwgYiwgaCwgY1toXSwgITAsIGYsIGcpXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodm9pZCAwICE9PSBkICYmIChlID0gITAsIHIuaXNGdW5jdGlvbihkKSB8fCAoZyA9ICEwKSwgaiAmJiAoZyA/IChiLmNhbGwoYSwgZCksIGIgPSBudWxsKSA6IChqID0gYiwgYiA9IGZ1bmN0aW9uKGEsIGIsIGMpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gai5jYWxsKHIoYSksIGMpXHJcbiAgICAgICAgICAgICAgICB9KSksIGIpKVxyXG4gICAgICAgICAgICAgICAgZm9yICg7IGggPCBpOyBoKyspIGIoYVtoXSwgYywgZyA/IGQgOiBkLmNhbGwoYVtoXSwgaCwgYihhW2hdLCBjKSkpO1xyXG4gICAgICAgICAgICByZXR1cm4gZSA/IGEgOiBqID8gYi5jYWxsKGEpIDogaSA/IGIoYVswXSwgYykgOiBmXHJcbiAgICAgICAgfSxcclxuICAgICAgICBVID0gZnVuY3Rpb24oYSkge1xyXG4gICAgICAgICAgICByZXR1cm4gMSA9PT0gYS5ub2RlVHlwZSB8fCA5ID09PSBhLm5vZGVUeXBlIHx8ICErYS5ub2RlVHlwZVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gVigpIHtcclxuICAgICAgICB0aGlzLmV4cGFuZG8gPSByLmV4cGFuZG8gKyBWLnVpZCsrXHJcbiAgICB9XHJcbiAgICBWLnVpZCA9IDEsIFYucHJvdG90eXBlID0ge1xyXG4gICAgICAgIGNhY2hlOiBmdW5jdGlvbihhKSB7XHJcbiAgICAgICAgICAgIHZhciBiID0gYVt0aGlzLmV4cGFuZG9dO1xyXG4gICAgICAgICAgICByZXR1cm4gYiB8fCAoYiA9IHt9LCBVKGEpICYmIChhLm5vZGVUeXBlID8gYVt0aGlzLmV4cGFuZG9dID0gYiA6IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhLCB0aGlzLmV4cGFuZG8sIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlOiBiLFxyXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxyXG4gICAgICAgICAgICB9KSkpLCBiXHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKGEsIGIsIGMpIHtcclxuICAgICAgICAgICAgdmFyIGQsIGUgPSB0aGlzLmNhY2hlKGEpO1xyXG4gICAgICAgICAgICBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgYikgZVtyLmNhbWVsQ2FzZShiKV0gPSBjO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICBmb3IgKGQgaW4gYikgZVtyLmNhbWVsQ2FzZShkKV0gPSBiW2RdO1xyXG4gICAgICAgICAgICByZXR1cm4gZVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbihhLCBiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB2b2lkIDAgPT09IGIgPyB0aGlzLmNhY2hlKGEpIDogYVt0aGlzLmV4cGFuZG9dICYmIGFbdGhpcy5leHBhbmRvXVtyLmNhbWVsQ2FzZShiKV1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGFjY2VzczogZnVuY3Rpb24oYSwgYiwgYykge1xyXG4gICAgICAgICAgICByZXR1cm4gdm9pZCAwID09PSBiIHx8IGIgJiYgXCJzdHJpbmdcIiA9PSB0eXBlb2YgYiAmJiB2b2lkIDAgPT09IGMgPyB0aGlzLmdldChhLCBiKSA6ICh0aGlzLnNldChhLCBiLCBjKSwgdm9pZCAwICE9PSBjID8gYyA6IGIpXHJcbiAgICAgICAgfSxcclxuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uKGEsIGIpIHtcclxuICAgICAgICAgICAgdmFyIGMsIGQgPSBhW3RoaXMuZXhwYW5kb107XHJcbiAgICAgICAgICAgIGlmICh2b2lkIDAgIT09IGQpIHtcclxuICAgICAgICAgICAgICAgIGlmICh2b2lkIDAgIT09IGIpIHtcclxuICAgICAgICAgICAgICAgICAgICBBcnJheS5pc0FycmF5KGIpID8gYiA9IGIubWFwKHIuY2FtZWxDYXNlKSA6IChiID0gci5jYW1lbENhc2UoYiksIGIgPSBiIGluIGQgPyBbYl0gOiBiLm1hdGNoKEwpIHx8IFtdKSwgYyA9IGIubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChjLS0pIGRlbGV0ZSBkW2JbY11dXHJcbiAgICAgICAgICAgICAgICB9KHZvaWQgMCA9PT0gYiB8fCByLmlzRW1wdHlPYmplY3QoZCkpICYmIChhLm5vZGVUeXBlID8gYVt0aGlzLmV4cGFuZG9dID0gdm9pZCAwIDogZGVsZXRlIGFbdGhpcy5leHBhbmRvXSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaGFzRGF0YTogZnVuY3Rpb24oYSkge1xyXG4gICAgICAgICAgICB2YXIgYiA9IGFbdGhpcy5leHBhbmRvXTtcclxuICAgICAgICAgICAgcmV0dXJuIHZvaWQgMCAhPT0gYiAmJiAhci5pc0VtcHR5T2JqZWN0KGIpXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHZhciBXID0gbmV3IFYsXHJcbiAgICAgICAgWCA9IG5ldyBWLFxyXG4gICAgICAgIFkgPSAvXig/Olxce1tcXHdcXFddKlxcfXxcXFtbXFx3XFxXXSpcXF0pJC8sXHJcbiAgICAgICAgWiA9IC9bQS1aXS9nO1xyXG5cclxuICAgIGZ1bmN0aW9uICQoYSkge1xyXG4gICAgICAgIHJldHVybiBcInRydWVcIiA9PT0gYSB8fCBcImZhbHNlXCIgIT09IGEgJiYgKFwibnVsbFwiID09PSBhID8gbnVsbCA6IGEgPT09ICthICsgXCJcIiA/ICthIDogWS50ZXN0KGEpID8gSlNPTi5wYXJzZShhKSA6IGEpXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gXyhhLCBiLCBjKSB7XHJcbiAgICAgICAgdmFyIGQ7XHJcbiAgICAgICAgaWYgKHZvaWQgMCA9PT0gYyAmJiAxID09PSBhLm5vZGVUeXBlKVxyXG4gICAgICAgICAgICBpZiAoZCA9IFwiZGF0YS1cIiArIGIucmVwbGFjZShaLCBcIi0kJlwiKS50b0xvd2VyQ2FzZSgpLCBjID0gYS5nZXRBdHRyaWJ1dGUoZCksIFwic3RyaW5nXCIgPT0gdHlwZW9mIGMpIHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYyA9ICQoYylcclxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XHJcbiAgICAgICAgICAgICAgICBYLnNldChhLCBiLCBjKVxyXG4gICAgICAgICAgICB9IGVsc2UgYyA9IHZvaWQgMDtcclxuICAgICAgICByZXR1cm4gY1xyXG4gICAgfVxyXG4gICAgci5leHRlbmQoe1xyXG4gICAgICAgIGhhc0RhdGE6IGZ1bmN0aW9uKGEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFguaGFzRGF0YShhKSB8fCBXLmhhc0RhdGEoYSlcclxuICAgICAgICB9LFxyXG4gICAgICAgIGRhdGE6IGZ1bmN0aW9uKGEsIGIsIGMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFguYWNjZXNzKGEsIGIsIGMpXHJcbiAgICAgICAgfSxcclxuICAgICAgICByZW1vdmVEYXRhOiBmdW5jdGlvbihhLCBiKSB7XHJcbiAgICAgICAgICAgIFgucmVtb3ZlKGEsIGIpXHJcbiAgICAgICAgfSxcclxuICAgICAgICBfZGF0YTogZnVuY3Rpb24oYSwgYiwgYykge1xyXG4gICAgICAgICAgICByZXR1cm4gVy5hY2Nlc3MoYSwgYiwgYylcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9yZW1vdmVEYXRhOiBmdW5jdGlvbihhLCBiKSB7XHJcbiAgICAgICAgICAgIFcucmVtb3ZlKGEsIGIpXHJcbiAgICAgICAgfVxyXG4gICAgfSksIHIuZm4uZXh0ZW5kKHtcclxuICAgICAgICBkYXRhOiBmdW5jdGlvbihhLCBiKSB7XHJcbiAgICAgICAgICAgIHZhciBjLCBkLCBlLCBmID0gdGhpc1swXSxcclxuICAgICAgICAgICAgICAgIGcgPSBmICYmIGYuYXR0cmlidXRlcztcclxuICAgICAgICAgICAgaWYgKHZvaWQgMCA9PT0gYSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubGVuZ3RoICYmIChlID0gWC5nZXQoZiksIDEgPT09IGYubm9kZVR5cGUgJiYgIVcuZ2V0KGYsIFwiaGFzRGF0YUF0dHJzXCIpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGMgPSBnLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoYy0tKSBnW2NdICYmIChkID0gZ1tjXS5uYW1lLCAwID09PSBkLmluZGV4T2YoXCJkYXRhLVwiKSAmJiAoZCA9IHIuY2FtZWxDYXNlKGQuc2xpY2UoNSkpLCBfKGYsIGQsIGVbZF0pKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgVy5zZXQoZiwgXCJoYXNEYXRhQXR0cnNcIiwgITApXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBcIm9iamVjdFwiID09IHR5cGVvZiBhID8gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgWC5zZXQodGhpcywgYSlcclxuICAgICAgICAgICAgfSkgOiBUKHRoaXMsIGZ1bmN0aW9uKGIpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjO1xyXG4gICAgICAgICAgICAgICAgaWYgKGYgJiYgdm9pZCAwID09PSBiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMgPSBYLmdldChmLCBhKSwgdm9pZCAwICE9PSBjKSByZXR1cm4gYztcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYyA9IF8oZiwgYSksIHZvaWQgMCAhPT0gYykgcmV0dXJuIGNcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgWC5zZXQodGhpcywgYSwgYilcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIH0sIG51bGwsIGIsIGFyZ3VtZW50cy5sZW5ndGggPiAxLCBudWxsLCAhMClcclxuICAgICAgICB9LFxyXG4gICAgICAgIHJlbW92ZURhdGE6IGZ1bmN0aW9uKGEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIFgucmVtb3ZlKHRoaXMsIGEpXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfVxyXG4gICAgfSksIHIuZXh0ZW5kKHtcclxuICAgICAgICBxdWV1ZTogZnVuY3Rpb24oYSwgYiwgYykge1xyXG4gICAgICAgICAgICB2YXIgZDtcclxuICAgICAgICAgICAgaWYgKGEpIHJldHVybiBiID0gKGIgfHwgXCJmeFwiKSArIFwicXVldWVcIiwgZCA9IFcuZ2V0KGEsIGIpLCBjICYmICghZCB8fCBBcnJheS5pc0FycmF5KGMpID8gZCA9IFcuYWNjZXNzKGEsIGIsIHIubWFrZUFycmF5KGMpKSA6IGQucHVzaChjKSksIGQgfHwgW11cclxuICAgICAgICB9LFxyXG4gICAgICAgIGRlcXVldWU6IGZ1bmN0aW9uKGEsIGIpIHtcclxuICAgICAgICAgICAgYiA9IGIgfHwgXCJmeFwiO1xyXG4gICAgICAgICAgICB2YXIgYyA9IHIucXVldWUoYSwgYiksXHJcbiAgICAgICAgICAgICAgICBkID0gYy5sZW5ndGgsXHJcbiAgICAgICAgICAgICAgICBlID0gYy5zaGlmdCgpLFxyXG4gICAgICAgICAgICAgICAgZiA9IHIuX3F1ZXVlSG9va3MoYSwgYiksXHJcbiAgICAgICAgICAgICAgICBnID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgci5kZXF1ZXVlKGEsIGIpXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBcImlucHJvZ3Jlc3NcIiA9PT0gZSAmJiAoZSA9IGMuc2hpZnQoKSwgZC0tKSwgZSAmJiAoXCJmeFwiID09PSBiICYmIGMudW5zaGlmdChcImlucHJvZ3Jlc3NcIiksIGRlbGV0ZSBmLnN0b3AsIGUuY2FsbChhLCBnLCBmKSksICFkICYmIGYgJiYgZi5lbXB0eS5maXJlKClcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9xdWV1ZUhvb2tzOiBmdW5jdGlvbihhLCBiKSB7XHJcbiAgICAgICAgICAgIHZhciBjID0gYiArIFwicXVldWVIb29rc1wiO1xyXG4gICAgICAgICAgICByZXR1cm4gVy5nZXQoYSwgYykgfHwgVy5hY2Nlc3MoYSwgYywge1xyXG4gICAgICAgICAgICAgICAgZW1wdHk6IHIuQ2FsbGJhY2tzKFwib25jZSBtZW1vcnlcIikuYWRkKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIFcucmVtb3ZlKGEsIFtiICsgXCJxdWV1ZVwiLCBjXSlcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfVxyXG4gICAgfSksIHIuZm4uZXh0ZW5kKHtcclxuICAgICAgICBxdWV1ZTogZnVuY3Rpb24oYSwgYikge1xyXG4gICAgICAgICAgICB2YXIgYyA9IDI7XHJcbiAgICAgICAgICAgIHJldHVybiBcInN0cmluZ1wiICE9IHR5cGVvZiBhICYmIChiID0gYSwgYSA9IFwiZnhcIiwgYy0tKSwgYXJndW1lbnRzLmxlbmd0aCA8IGMgPyByLnF1ZXVlKHRoaXNbMF0sIGEpIDogdm9pZCAwID09PSBiID8gdGhpcyA6IHRoaXMuZWFjaChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjID0gci5xdWV1ZSh0aGlzLCBhLCBiKTtcclxuICAgICAgICAgICAgICAgIHIuX3F1ZXVlSG9va3ModGhpcywgYSksIFwiZnhcIiA9PT0gYSAmJiBcImlucHJvZ3Jlc3NcIiAhPT0gY1swXSAmJiByLmRlcXVldWUodGhpcywgYSlcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9LFxyXG4gICAgICAgIGRlcXVldWU6IGZ1bmN0aW9uKGEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHIuZGVxdWV1ZSh0aGlzLCBhKVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY2xlYXJRdWV1ZTogZnVuY3Rpb24oYSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5xdWV1ZShhIHx8IFwiZnhcIiwgW10pXHJcbiAgICAgICAgfSxcclxuICAgICAgICBwcm9taXNlOiBmdW5jdGlvbihhLCBiKSB7XHJcbiAgICAgICAgICAgIHZhciBjLCBkID0gMSxcclxuICAgICAgICAgICAgICAgIGUgPSByLkRlZmVycmVkKCksXHJcbiAgICAgICAgICAgICAgICBmID0gdGhpcyxcclxuICAgICAgICAgICAgICAgIGcgPSB0aGlzLmxlbmd0aCxcclxuICAgICAgICAgICAgICAgIGggPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICAtLWQgfHwgZS5yZXNvbHZlV2l0aChmLCBbZl0pXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBcInN0cmluZ1wiICE9IHR5cGVvZiBhICYmIChiID0gYSwgYSA9IHZvaWQgMCksIGEgPSBhIHx8IFwiZnhcIjtcclxuICAgICAgICAgICAgd2hpbGUgKGctLSkgYyA9IFcuZ2V0KGZbZ10sIGEgKyBcInF1ZXVlSG9va3NcIiksIGMgJiYgYy5lbXB0eSAmJiAoZCsrLCBjLmVtcHR5LmFkZChoKSk7XHJcbiAgICAgICAgICAgIHJldHVybiBoKCksIGUucHJvbWlzZShiKVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgdmFyIGFhID0gL1srLV0/KD86XFxkKlxcLnwpXFxkKyg/OltlRV1bKy1dP1xcZCt8KS8uc291cmNlLFxyXG4gICAgICAgIGJhID0gbmV3IFJlZ0V4cChcIl4oPzooWystXSk9fCkoXCIgKyBhYSArIFwiKShbYS16JV0qKSRcIiwgXCJpXCIpLFxyXG4gICAgICAgIGNhID0gW1wiVG9wXCIsIFwiUmlnaHRcIiwgXCJCb3R0b21cIiwgXCJMZWZ0XCJdLFxyXG4gICAgICAgIGRhID0gZnVuY3Rpb24oYSwgYikge1xyXG4gICAgICAgICAgICByZXR1cm4gYSA9IGIgfHwgYSwgXCJub25lXCIgPT09IGEuc3R5bGUuZGlzcGxheSB8fCBcIlwiID09PSBhLnN0eWxlLmRpc3BsYXkgJiYgci5jb250YWlucyhhLm93bmVyRG9jdW1lbnQsIGEpICYmIFwibm9uZVwiID09PSByLmNzcyhhLCBcImRpc3BsYXlcIilcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVhID0gZnVuY3Rpb24oYSwgYiwgYywgZCkge1xyXG4gICAgICAgICAgICB2YXIgZSwgZiwgZyA9IHt9O1xyXG4gICAgICAgICAgICBmb3IgKGYgaW4gYikgZ1tmXSA9IGEuc3R5bGVbZl0sIGEuc3R5bGVbZl0gPSBiW2ZdO1xyXG4gICAgICAgICAgICBlID0gYy5hcHBseShhLCBkIHx8IFtdKTtcclxuICAgICAgICAgICAgZm9yIChmIGluIGIpIGEuc3R5bGVbZl0gPSBnW2ZdO1xyXG4gICAgICAgICAgICByZXR1cm4gZVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gZmEoYSwgYiwgYywgZCkge1xyXG4gICAgICAgIHZhciBlLCBmID0gMSxcclxuICAgICAgICAgICAgZyA9IDIwLFxyXG4gICAgICAgICAgICBoID0gZCA/IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGQuY3VyKClcclxuICAgICAgICAgICAgfSA6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHIuY3NzKGEsIGIsIFwiXCIpXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGkgPSBoKCksXHJcbiAgICAgICAgICAgIGogPSBjICYmIGNbM10gfHwgKHIuY3NzTnVtYmVyW2JdID8gXCJcIiA6IFwicHhcIiksXHJcbiAgICAgICAgICAgIGsgPSAoci5jc3NOdW1iZXJbYl0gfHwgXCJweFwiICE9PSBqICYmICtpKSAmJiBiYS5leGVjKHIuY3NzKGEsIGIpKTtcclxuICAgICAgICBpZiAoayAmJiBrWzNdICE9PSBqKSB7XHJcbiAgICAgICAgICAgIGogPSBqIHx8IGtbM10sIGMgPSBjIHx8IFtdLCBrID0gK2kgfHwgMTtcclxuICAgICAgICAgICAgZG8gZiA9IGYgfHwgXCIuNVwiLCBrIC89IGYsIHIuc3R5bGUoYSwgYiwgayArIGopOyB3aGlsZSAoZiAhPT0gKGYgPSBoKCkgLyBpKSAmJiAxICE9PSBmICYmIC0tZylcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGMgJiYgKGsgPSArayB8fCAraSB8fCAwLCBlID0gY1sxXSA/IGsgKyAoY1sxXSArIDEpICogY1syXSA6ICtjWzJdLCBkICYmIChkLnVuaXQgPSBqLCBkLnN0YXJ0ID0gaywgZC5lbmQgPSBlKSksIGVcclxuICAgIH1cclxuICAgIHZhciBnYSA9IHt9O1xyXG5cclxuICAgIGZ1bmN0aW9uIGhhKGEpIHtcclxuICAgICAgICB2YXIgYiwgYyA9IGEub3duZXJEb2N1bWVudCxcclxuICAgICAgICAgICAgZCA9IGEubm9kZU5hbWUsXHJcbiAgICAgICAgICAgIGUgPSBnYVtkXTtcclxuICAgICAgICByZXR1cm4gZSA/IGUgOiAoYiA9IGMuYm9keS5hcHBlbmRDaGlsZChjLmNyZWF0ZUVsZW1lbnQoZCkpLCBlID0gci5jc3MoYiwgXCJkaXNwbGF5XCIpLCBiLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYiksIFwibm9uZVwiID09PSBlICYmIChlID0gXCJibG9ja1wiKSwgZ2FbZF0gPSBlLCBlKVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGlhKGEsIGIpIHtcclxuICAgICAgICBmb3IgKHZhciBjLCBkLCBlID0gW10sIGYgPSAwLCBnID0gYS5sZW5ndGg7IGYgPCBnOyBmKyspIGQgPSBhW2ZdLCBkLnN0eWxlICYmIChjID0gZC5zdHlsZS5kaXNwbGF5LCBiID8gKFwibm9uZVwiID09PSBjICYmIChlW2ZdID0gVy5nZXQoZCwgXCJkaXNwbGF5XCIpIHx8IG51bGwsIGVbZl0gfHwgKGQuc3R5bGUuZGlzcGxheSA9IFwiXCIpKSwgXCJcIiA9PT0gZC5zdHlsZS5kaXNwbGF5ICYmIGRhKGQpICYmIChlW2ZdID0gaGEoZCkpKSA6IFwibm9uZVwiICE9PSBjICYmIChlW2ZdID0gXCJub25lXCIsIFcuc2V0KGQsIFwiZGlzcGxheVwiLCBjKSkpO1xyXG4gICAgICAgIGZvciAoZiA9IDA7IGYgPCBnOyBmKyspIG51bGwgIT0gZVtmXSAmJiAoYVtmXS5zdHlsZS5kaXNwbGF5ID0gZVtmXSk7XHJcbiAgICAgICAgcmV0dXJuIGFcclxuICAgIH1cclxuICAgIHIuZm4uZXh0ZW5kKHtcclxuICAgICAgICBzaG93OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGlhKHRoaXMsICEwKVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaGlkZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpYSh0aGlzKVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdG9nZ2xlOiBmdW5jdGlvbihhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBcImJvb2xlYW5cIiA9PSB0eXBlb2YgYSA/IGEgPyB0aGlzLnNob3coKSA6IHRoaXMuaGlkZSgpIDogdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgZGEodGhpcykgPyByKHRoaXMpLnNob3coKSA6IHIodGhpcykuaGlkZSgpXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICB2YXIgamEgPSAvXig/OmNoZWNrYm94fHJhZGlvKSQvaSxcclxuICAgICAgICBrYSA9IC88KFthLXpdW15cXC9cXDA+XFx4MjBcXHRcXHJcXG5cXGZdKykvaSxcclxuICAgICAgICBsYSA9IC9eJHxcXC8oPzpqYXZhfGVjbWEpc2NyaXB0L2ksXHJcbiAgICAgICAgbWEgPSB7XHJcbiAgICAgICAgICAgIG9wdGlvbjogWzEsIFwiPHNlbGVjdCBtdWx0aXBsZT0nbXVsdGlwbGUnPlwiLCBcIjwvc2VsZWN0PlwiXSxcclxuICAgICAgICAgICAgdGhlYWQ6IFsxLCBcIjx0YWJsZT5cIiwgXCI8L3RhYmxlPlwiXSxcclxuICAgICAgICAgICAgY29sOiBbMiwgXCI8dGFibGU+PGNvbGdyb3VwPlwiLCBcIjwvY29sZ3JvdXA+PC90YWJsZT5cIl0sXHJcbiAgICAgICAgICAgIHRyOiBbMiwgXCI8dGFibGU+PHRib2R5PlwiLCBcIjwvdGJvZHk+PC90YWJsZT5cIl0sXHJcbiAgICAgICAgICAgIHRkOiBbMywgXCI8dGFibGU+PHRib2R5Pjx0cj5cIiwgXCI8L3RyPjwvdGJvZHk+PC90YWJsZT5cIl0sXHJcbiAgICAgICAgICAgIF9kZWZhdWx0OiBbMCwgXCJcIiwgXCJcIl1cclxuICAgICAgICB9O1xyXG4gICAgbWEub3B0Z3JvdXAgPSBtYS5vcHRpb24sIG1hLnRib2R5ID0gbWEudGZvb3QgPSBtYS5jb2xncm91cCA9IG1hLmNhcHRpb24gPSBtYS50aGVhZCwgbWEudGggPSBtYS50ZDtcclxuXHJcbiAgICBmdW5jdGlvbiBuYShhLCBiKSB7XHJcbiAgICAgICAgdmFyIGM7XHJcbiAgICAgICAgcmV0dXJuIGMgPSBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBhLmdldEVsZW1lbnRzQnlUYWdOYW1lID8gYS5nZXRFbGVtZW50c0J5VGFnTmFtZShiIHx8IFwiKlwiKSA6IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIGEucXVlcnlTZWxlY3RvckFsbCA/IGEucXVlcnlTZWxlY3RvckFsbChiIHx8IFwiKlwiKSA6IFtdLCB2b2lkIDAgPT09IGIgfHwgYiAmJiBCKGEsIGIpID8gci5tZXJnZShbYV0sIGMpIDogY1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG9hKGEsIGIpIHtcclxuICAgICAgICBmb3IgKHZhciBjID0gMCwgZCA9IGEubGVuZ3RoOyBjIDwgZDsgYysrKSBXLnNldChhW2NdLCBcImdsb2JhbEV2YWxcIiwgIWIgfHwgVy5nZXQoYltjXSwgXCJnbG9iYWxFdmFsXCIpKVxyXG4gICAgfVxyXG4gICAgdmFyIHBhID0gLzx8JiM/XFx3KzsvO1xyXG5cclxuICAgIGZ1bmN0aW9uIHFhKGEsIGIsIGMsIGQsIGUpIHtcclxuICAgICAgICBmb3IgKHZhciBmLCBnLCBoLCBpLCBqLCBrLCBsID0gYi5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksIG0gPSBbXSwgbiA9IDAsIG8gPSBhLmxlbmd0aDsgbiA8IG87IG4rKylcclxuICAgICAgICAgICAgaWYgKGYgPSBhW25dLCBmIHx8IDAgPT09IGYpXHJcbiAgICAgICAgICAgICAgICBpZiAoXCJvYmplY3RcIiA9PT0gci50eXBlKGYpKSByLm1lcmdlKG0sIGYubm9kZVR5cGUgPyBbZl0gOiBmKTtcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhLnRlc3QoZikpIHtcclxuICAgICAgICAgICAgZyA9IGcgfHwgbC5hcHBlbmRDaGlsZChiLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpLCBoID0gKGthLmV4ZWMoZikgfHwgW1wiXCIsIFwiXCJdKVsxXS50b0xvd2VyQ2FzZSgpLCBpID0gbWFbaF0gfHwgbWEuX2RlZmF1bHQsIGcuaW5uZXJIVE1MID0gaVsxXSArIHIuaHRtbFByZWZpbHRlcihmKSArIGlbMl0sIGsgPSBpWzBdO1xyXG4gICAgICAgICAgICB3aGlsZSAoay0tKSBnID0gZy5sYXN0Q2hpbGQ7XHJcbiAgICAgICAgICAgIHIubWVyZ2UobSwgZy5jaGlsZE5vZGVzKSwgZyA9IGwuZmlyc3RDaGlsZCwgZy50ZXh0Q29udGVudCA9IFwiXCJcclxuICAgICAgICB9IGVsc2UgbS5wdXNoKGIuY3JlYXRlVGV4dE5vZGUoZikpO1xyXG4gICAgICAgIGwudGV4dENvbnRlbnQgPSBcIlwiLCBuID0gMDtcclxuICAgICAgICB3aGlsZSAoZiA9IG1bbisrXSlcclxuICAgICAgICAgICAgaWYgKGQgJiYgci5pbkFycmF5KGYsIGQpID4gLTEpIGUgJiYgZS5wdXNoKGYpO1xyXG4gICAgICAgICAgICBlbHNlIGlmIChqID0gci5jb250YWlucyhmLm93bmVyRG9jdW1lbnQsIGYpLCBnID0gbmEobC5hcHBlbmRDaGlsZChmKSwgXCJzY3JpcHRcIiksIGogJiYgb2EoZyksIGMpIHtcclxuICAgICAgICAgICAgayA9IDA7XHJcbiAgICAgICAgICAgIHdoaWxlIChmID0gZ1trKytdKSBsYS50ZXN0KGYudHlwZSB8fCBcIlwiKSAmJiBjLnB1c2goZilcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGxcclxuICAgIH0hIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBhID0gZC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXHJcbiAgICAgICAgICAgIGIgPSBhLmFwcGVuZENoaWxkKGQuY3JlYXRlRWxlbWVudChcImRpdlwiKSksXHJcbiAgICAgICAgICAgIGMgPSBkLmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcclxuICAgICAgICBjLnNldEF0dHJpYnV0ZShcInR5cGVcIiwgXCJyYWRpb1wiKSwgYy5zZXRBdHRyaWJ1dGUoXCJjaGVja2VkXCIsIFwiY2hlY2tlZFwiKSwgYy5zZXRBdHRyaWJ1dGUoXCJuYW1lXCIsIFwidFwiKSwgYi5hcHBlbmRDaGlsZChjKSwgby5jaGVja0Nsb25lID0gYi5jbG9uZU5vZGUoITApLmNsb25lTm9kZSghMCkubGFzdENoaWxkLmNoZWNrZWQsIGIuaW5uZXJIVE1MID0gXCI8dGV4dGFyZWE+eDwvdGV4dGFyZWE+XCIsIG8ubm9DbG9uZUNoZWNrZWQgPSAhIWIuY2xvbmVOb2RlKCEwKS5sYXN0Q2hpbGQuZGVmYXVsdFZhbHVlXHJcbiAgICB9KCk7XHJcbiAgICB2YXIgcmEgPSBkLmRvY3VtZW50RWxlbWVudCxcclxuICAgICAgICBzYSA9IC9ea2V5LyxcclxuICAgICAgICB0YSA9IC9eKD86bW91c2V8cG9pbnRlcnxjb250ZXh0bWVudXxkcmFnfGRyb3ApfGNsaWNrLyxcclxuICAgICAgICB1YSA9IC9eKFteLl0qKSg/OlxcLiguKyl8KS87XHJcblxyXG4gICAgZnVuY3Rpb24gdmEoKSB7XHJcbiAgICAgICAgcmV0dXJuICEwXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gd2EoKSB7XHJcbiAgICAgICAgcmV0dXJuICExXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24geGEoKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgcmV0dXJuIGQuYWN0aXZlRWxlbWVudFxyXG4gICAgICAgIH0gY2F0Y2ggKGEpIHt9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24geWEoYSwgYiwgYywgZCwgZSwgZikge1xyXG4gICAgICAgIHZhciBnLCBoO1xyXG4gICAgICAgIGlmIChcIm9iamVjdFwiID09IHR5cGVvZiBiKSB7XHJcbiAgICAgICAgICAgIFwic3RyaW5nXCIgIT0gdHlwZW9mIGMgJiYgKGQgPSBkIHx8IGMsIGMgPSB2b2lkIDApO1xyXG4gICAgICAgICAgICBmb3IgKGggaW4gYikgeWEoYSwgaCwgYywgZCwgYltoXSwgZik7XHJcbiAgICAgICAgICAgIHJldHVybiBhXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChudWxsID09IGQgJiYgbnVsbCA9PSBlID8gKGUgPSBjLCBkID0gYyA9IHZvaWQgMCkgOiBudWxsID09IGUgJiYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIGMgPyAoZSA9IGQsIGQgPSB2b2lkIDApIDogKGUgPSBkLCBkID0gYywgYyA9IHZvaWQgMCkpLCBlID09PSAhMSkgZSA9IHdhO1xyXG4gICAgICAgIGVsc2UgaWYgKCFlKSByZXR1cm4gYTtcclxuICAgICAgICByZXR1cm4gMSA9PT0gZiAmJiAoZyA9IGUsIGUgPSBmdW5jdGlvbihhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByKCkub2ZmKGEpLCBnLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcclxuICAgICAgICB9LCBlLmd1aWQgPSBnLmd1aWQgfHwgKGcuZ3VpZCA9IHIuZ3VpZCsrKSksIGEuZWFjaChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgci5ldmVudC5hZGQodGhpcywgYiwgZSwgZCwgYylcclxuICAgICAgICB9KVxyXG4gICAgfVxyXG4gICAgci5ldmVudCA9IHtcclxuICAgICAgICBnbG9iYWw6IHt9LFxyXG4gICAgICAgIGFkZDogZnVuY3Rpb24oYSwgYiwgYywgZCwgZSkge1xyXG4gICAgICAgICAgICB2YXIgZiwgZywgaCwgaSwgaiwgaywgbCwgbSwgbiwgbywgcCwgcSA9IFcuZ2V0KGEpO1xyXG4gICAgICAgICAgICBpZiAocSkge1xyXG4gICAgICAgICAgICAgICAgYy5oYW5kbGVyICYmIChmID0gYywgYyA9IGYuaGFuZGxlciwgZSA9IGYuc2VsZWN0b3IpLCBlICYmIHIuZmluZC5tYXRjaGVzU2VsZWN0b3IocmEsIGUpLCBjLmd1aWQgfHwgKGMuZ3VpZCA9IHIuZ3VpZCsrKSwgKGkgPSBxLmV2ZW50cykgfHwgKGkgPSBxLmV2ZW50cyA9IHt9KSwgKGcgPSBxLmhhbmRsZSkgfHwgKGcgPSBxLmhhbmRsZSA9IGZ1bmN0aW9uKGIpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgciAmJiByLmV2ZW50LnRyaWdnZXJlZCAhPT0gYi50eXBlID8gci5ldmVudC5kaXNwYXRjaC5hcHBseShhLCBhcmd1bWVudHMpIDogdm9pZCAwXHJcbiAgICAgICAgICAgICAgICB9KSwgYiA9IChiIHx8IFwiXCIpLm1hdGNoKEwpIHx8IFtcIlwiXSwgaiA9IGIubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGotLSkgaCA9IHVhLmV4ZWMoYltqXSkgfHwgW10sIG4gPSBwID0gaFsxXSwgbyA9IChoWzJdIHx8IFwiXCIpLnNwbGl0KFwiLlwiKS5zb3J0KCksIG4gJiYgKGwgPSByLmV2ZW50LnNwZWNpYWxbbl0gfHwge30sIG4gPSAoZSA/IGwuZGVsZWdhdGVUeXBlIDogbC5iaW5kVHlwZSkgfHwgbiwgbCA9IHIuZXZlbnQuc3BlY2lhbFtuXSB8fCB7fSwgayA9IHIuZXh0ZW5kKHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBuLFxyXG4gICAgICAgICAgICAgICAgICAgIG9yaWdUeXBlOiBwLFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGQsXHJcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlcjogYyxcclxuICAgICAgICAgICAgICAgICAgICBndWlkOiBjLmd1aWQsXHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6IGUsXHJcbiAgICAgICAgICAgICAgICAgICAgbmVlZHNDb250ZXh0OiBlICYmIHIuZXhwci5tYXRjaC5uZWVkc0NvbnRleHQudGVzdChlKSxcclxuICAgICAgICAgICAgICAgICAgICBuYW1lc3BhY2U6IG8uam9pbihcIi5cIilcclxuICAgICAgICAgICAgICAgIH0sIGYpLCAobSA9IGlbbl0pIHx8IChtID0gaVtuXSA9IFtdLCBtLmRlbGVnYXRlQ291bnQgPSAwLCBsLnNldHVwICYmIGwuc2V0dXAuY2FsbChhLCBkLCBvLCBnKSAhPT0gITEgfHwgYS5hZGRFdmVudExpc3RlbmVyICYmIGEuYWRkRXZlbnRMaXN0ZW5lcihuLCBnKSksIGwuYWRkICYmIChsLmFkZC5jYWxsKGEsIGspLCBrLmhhbmRsZXIuZ3VpZCB8fCAoay5oYW5kbGVyLmd1aWQgPSBjLmd1aWQpKSwgZSA/IG0uc3BsaWNlKG0uZGVsZWdhdGVDb3VudCsrLCAwLCBrKSA6IG0ucHVzaChrKSwgci5ldmVudC5nbG9iYWxbbl0gPSAhMClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbihhLCBiLCBjLCBkLCBlKSB7XHJcbiAgICAgICAgICAgIHZhciBmLCBnLCBoLCBpLCBqLCBrLCBsLCBtLCBuLCBvLCBwLCBxID0gVy5oYXNEYXRhKGEpICYmIFcuZ2V0KGEpO1xyXG4gICAgICAgICAgICBpZiAocSAmJiAoaSA9IHEuZXZlbnRzKSkge1xyXG4gICAgICAgICAgICAgICAgYiA9IChiIHx8IFwiXCIpLm1hdGNoKEwpIHx8IFtcIlwiXSwgaiA9IGIubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGotLSlcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaCA9IHVhLmV4ZWMoYltqXSkgfHwgW10sIG4gPSBwID0gaFsxXSwgbyA9IChoWzJdIHx8IFwiXCIpLnNwbGl0KFwiLlwiKS5zb3J0KCksIG4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbCA9IHIuZXZlbnQuc3BlY2lhbFtuXSB8fCB7fSwgbiA9IChkID8gbC5kZWxlZ2F0ZVR5cGUgOiBsLmJpbmRUeXBlKSB8fCBuLCBtID0gaVtuXSB8fCBbXSwgaCA9IGhbMl0gJiYgbmV3IFJlZ0V4cChcIihefFxcXFwuKVwiICsgby5qb2luKFwiXFxcXC4oPzouKlxcXFwufClcIikgKyBcIihcXFxcLnwkKVwiKSwgZyA9IGYgPSBtLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGYtLSkgayA9IG1bZl0sICFlICYmIHAgIT09IGsub3JpZ1R5cGUgfHwgYyAmJiBjLmd1aWQgIT09IGsuZ3VpZCB8fCBoICYmICFoLnRlc3Qoay5uYW1lc3BhY2UpIHx8IGQgJiYgZCAhPT0gay5zZWxlY3RvciAmJiAoXCIqKlwiICE9PSBkIHx8ICFrLnNlbGVjdG9yKSB8fCAobS5zcGxpY2UoZiwgMSksIGsuc2VsZWN0b3IgJiYgbS5kZWxlZ2F0ZUNvdW50LS0sIGwucmVtb3ZlICYmIGwucmVtb3ZlLmNhbGwoYSwgaykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBnICYmICFtLmxlbmd0aCAmJiAobC50ZWFyZG93biAmJiBsLnRlYXJkb3duLmNhbGwoYSwgbywgcS5oYW5kbGUpICE9PSAhMSB8fCByLnJlbW92ZUV2ZW50KGEsIG4sIHEuaGFuZGxlKSwgZGVsZXRlIGlbbl0pXHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobiBpbiBpKSByLmV2ZW50LnJlbW92ZShhLCBuICsgYltqXSwgYywgZCwgITApO1xyXG4gICAgICAgICAgICAgICAgci5pc0VtcHR5T2JqZWN0KGkpICYmIFcucmVtb3ZlKGEsIFwiaGFuZGxlIGV2ZW50c1wiKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBkaXNwYXRjaDogZnVuY3Rpb24oYSkge1xyXG4gICAgICAgICAgICB2YXIgYiA9IHIuZXZlbnQuZml4KGEpLFxyXG4gICAgICAgICAgICAgICAgYywgZCwgZSwgZiwgZywgaCwgaSA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKSxcclxuICAgICAgICAgICAgICAgIGogPSAoVy5nZXQodGhpcywgXCJldmVudHNcIikgfHwge30pW2IudHlwZV0gfHwgW10sXHJcbiAgICAgICAgICAgICAgICBrID0gci5ldmVudC5zcGVjaWFsW2IudHlwZV0gfHwge307XHJcbiAgICAgICAgICAgIGZvciAoaVswXSA9IGIsIGMgPSAxOyBjIDwgYXJndW1lbnRzLmxlbmd0aDsgYysrKSBpW2NdID0gYXJndW1lbnRzW2NdO1xyXG4gICAgICAgICAgICBpZiAoYi5kZWxlZ2F0ZVRhcmdldCA9IHRoaXMsICFrLnByZURpc3BhdGNoIHx8IGsucHJlRGlzcGF0Y2guY2FsbCh0aGlzLCBiKSAhPT0gITEpIHtcclxuICAgICAgICAgICAgICAgIGggPSByLmV2ZW50LmhhbmRsZXJzLmNhbGwodGhpcywgYiwgaiksIGMgPSAwO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKChmID0gaFtjKytdKSAmJiAhYi5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYi5jdXJyZW50VGFyZ2V0ID0gZi5lbGVtLCBkID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKGcgPSBmLmhhbmRsZXJzW2QrK10pICYmICFiLmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkKCkpIGIucm5hbWVzcGFjZSAmJiAhYi5ybmFtZXNwYWNlLnRlc3QoZy5uYW1lc3BhY2UpIHx8IChiLmhhbmRsZU9iaiA9IGcsIGIuZGF0YSA9IGcuZGF0YSwgZSA9ICgoci5ldmVudC5zcGVjaWFsW2cub3JpZ1R5cGVdIHx8IHt9KS5oYW5kbGUgfHwgZy5oYW5kbGVyKS5hcHBseShmLmVsZW0sIGkpLCB2b2lkIDAgIT09IGUgJiYgKGIucmVzdWx0ID0gZSkgPT09ICExICYmIChiLnByZXZlbnREZWZhdWx0KCksIGIuc3RvcFByb3BhZ2F0aW9uKCkpKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGsucG9zdERpc3BhdGNoICYmIGsucG9zdERpc3BhdGNoLmNhbGwodGhpcywgYiksIGIucmVzdWx0XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGhhbmRsZXJzOiBmdW5jdGlvbihhLCBiKSB7XHJcbiAgICAgICAgICAgIHZhciBjLCBkLCBlLCBmLCBnLCBoID0gW10sXHJcbiAgICAgICAgICAgICAgICBpID0gYi5kZWxlZ2F0ZUNvdW50LFxyXG4gICAgICAgICAgICAgICAgaiA9IGEudGFyZ2V0O1xyXG4gICAgICAgICAgICBpZiAoaSAmJiBqLm5vZGVUeXBlICYmICEoXCJjbGlja1wiID09PSBhLnR5cGUgJiYgYS5idXR0b24gPj0gMSkpXHJcbiAgICAgICAgICAgICAgICBmb3IgKDsgaiAhPT0gdGhpczsgaiA9IGoucGFyZW50Tm9kZSB8fCB0aGlzKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICgxID09PSBqLm5vZGVUeXBlICYmIChcImNsaWNrXCIgIT09IGEudHlwZSB8fCBqLmRpc2FibGVkICE9PSAhMCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChmID0gW10sIGcgPSB7fSwgYyA9IDA7IGMgPCBpOyBjKyspIGQgPSBiW2NdLCBlID0gZC5zZWxlY3RvciArIFwiIFwiLCB2b2lkIDAgPT09IGdbZV0gJiYgKGdbZV0gPSBkLm5lZWRzQ29udGV4dCA/IHIoZSwgdGhpcykuaW5kZXgoaikgPiAtMSA6IHIuZmluZChlLCB0aGlzLCBudWxsLCBbal0pLmxlbmd0aCksIGdbZV0gJiYgZi5wdXNoKGQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmLmxlbmd0aCAmJiBoLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbTogaixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXJzOiBmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gaiA9IHRoaXMsIGkgPCBiLmxlbmd0aCAmJiBoLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgZWxlbTogaixcclxuICAgICAgICAgICAgICAgIGhhbmRsZXJzOiBiLnNsaWNlKGkpXHJcbiAgICAgICAgICAgIH0pLCBoXHJcbiAgICAgICAgfSxcclxuICAgICAgICBhZGRQcm9wOiBmdW5jdGlvbihhLCBiKSB7XHJcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyLkV2ZW50LnByb3RvdHlwZSwgYSwge1xyXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogITAsXHJcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6ICEwLFxyXG4gICAgICAgICAgICAgICAgZ2V0OiByLmlzRnVuY3Rpb24oYikgPyBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vcmlnaW5hbEV2ZW50KSByZXR1cm4gYih0aGlzLm9yaWdpbmFsRXZlbnQpXHJcbiAgICAgICAgICAgICAgICB9IDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3JpZ2luYWxFdmVudCkgcmV0dXJuIHRoaXMub3JpZ2luYWxFdmVudFthXVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24oYikge1xyXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBhLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6ICEwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB3cml0YWJsZTogITAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBiXHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9LFxyXG4gICAgICAgIGZpeDogZnVuY3Rpb24oYSkge1xyXG4gICAgICAgICAgICByZXR1cm4gYVtyLmV4cGFuZG9dID8gYSA6IG5ldyByLkV2ZW50KGEpXHJcbiAgICAgICAgfSxcclxuICAgICAgICBzcGVjaWFsOiB7XHJcbiAgICAgICAgICAgIGxvYWQ6IHtcclxuICAgICAgICAgICAgICAgIG5vQnViYmxlOiAhMFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBmb2N1czoge1xyXG4gICAgICAgICAgICAgICAgdHJpZ2dlcjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMgIT09IHhhKCkgJiYgdGhpcy5mb2N1cykgcmV0dXJuIHRoaXMuZm9jdXMoKSwgITFcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBkZWxlZ2F0ZVR5cGU6IFwiZm9jdXNpblwiXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGJsdXI6IHtcclxuICAgICAgICAgICAgICAgIHRyaWdnZXI6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzID09PSB4YSgpICYmIHRoaXMuYmx1cikgcmV0dXJuIHRoaXMuYmx1cigpLCAhMVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGRlbGVnYXRlVHlwZTogXCJmb2N1c291dFwiXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGNsaWNrOiB7XHJcbiAgICAgICAgICAgICAgICB0cmlnZ2VyOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoXCJjaGVja2JveFwiID09PSB0aGlzLnR5cGUgJiYgdGhpcy5jbGljayAmJiBCKHRoaXMsIFwiaW5wdXRcIikpIHJldHVybiB0aGlzLmNsaWNrKCksICExXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgX2RlZmF1bHQ6IGZ1bmN0aW9uKGEpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQihhLnRhcmdldCwgXCJhXCIpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGJlZm9yZXVubG9hZDoge1xyXG4gICAgICAgICAgICAgICAgcG9zdERpc3BhdGNoOiBmdW5jdGlvbihhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdm9pZCAwICE9PSBhLnJlc3VsdCAmJiBhLm9yaWdpbmFsRXZlbnQgJiYgKGEub3JpZ2luYWxFdmVudC5yZXR1cm5WYWx1ZSA9IGEucmVzdWx0KVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSwgci5yZW1vdmVFdmVudCA9IGZ1bmN0aW9uKGEsIGIsIGMpIHtcclxuICAgICAgICBhLnJlbW92ZUV2ZW50TGlzdGVuZXIgJiYgYS5yZW1vdmVFdmVudExpc3RlbmVyKGIsIGMpXHJcbiAgICB9LCByLkV2ZW50ID0gZnVuY3Rpb24oYSwgYikge1xyXG4gICAgICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2Ygci5FdmVudCA/IChhICYmIGEudHlwZSA/ICh0aGlzLm9yaWdpbmFsRXZlbnQgPSBhLCB0aGlzLnR5cGUgPSBhLnR5cGUsIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gYS5kZWZhdWx0UHJldmVudGVkIHx8IHZvaWQgMCA9PT0gYS5kZWZhdWx0UHJldmVudGVkICYmIGEucmV0dXJuVmFsdWUgPT09ICExID8gdmEgOiB3YSwgdGhpcy50YXJnZXQgPSBhLnRhcmdldCAmJiAzID09PSBhLnRhcmdldC5ub2RlVHlwZSA/IGEudGFyZ2V0LnBhcmVudE5vZGUgOiBhLnRhcmdldCwgdGhpcy5jdXJyZW50VGFyZ2V0ID0gYS5jdXJyZW50VGFyZ2V0LCB0aGlzLnJlbGF0ZWRUYXJnZXQgPSBhLnJlbGF0ZWRUYXJnZXQpIDogdGhpcy50eXBlID0gYSwgYiAmJiByLmV4dGVuZCh0aGlzLCBiKSwgdGhpcy50aW1lU3RhbXAgPSBhICYmIGEudGltZVN0YW1wIHx8IHIubm93KCksIHZvaWQodGhpc1tyLmV4cGFuZG9dID0gITApKSA6IG5ldyByLkV2ZW50KGEsIGIpXHJcbiAgICB9LCByLkV2ZW50LnByb3RvdHlwZSA9IHtcclxuICAgICAgICBjb25zdHJ1Y3Rvcjogci5FdmVudCxcclxuICAgICAgICBpc0RlZmF1bHRQcmV2ZW50ZWQ6IHdhLFxyXG4gICAgICAgIGlzUHJvcGFnYXRpb25TdG9wcGVkOiB3YSxcclxuICAgICAgICBpc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZDogd2EsXHJcbiAgICAgICAgaXNTaW11bGF0ZWQ6ICExLFxyXG4gICAgICAgIHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIGEgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XHJcbiAgICAgICAgICAgIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gdmEsIGEgJiYgIXRoaXMuaXNTaW11bGF0ZWQgJiYgYS5wcmV2ZW50RGVmYXVsdCgpXHJcbiAgICAgICAgfSxcclxuICAgICAgICBzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgYSA9IHRoaXMub3JpZ2luYWxFdmVudDtcclxuICAgICAgICAgICAgdGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IHZhLCBhICYmICF0aGlzLmlzU2ltdWxhdGVkICYmIGEuc3RvcFByb3BhZ2F0aW9uKClcclxuICAgICAgICB9LFxyXG4gICAgICAgIHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciBhID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xyXG4gICAgICAgICAgICB0aGlzLmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkID0gdmEsIGEgJiYgIXRoaXMuaXNTaW11bGF0ZWQgJiYgYS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKSwgdGhpcy5zdG9wUHJvcGFnYXRpb24oKVxyXG4gICAgICAgIH1cclxuICAgIH0sIHIuZWFjaCh7XHJcbiAgICAgICAgYWx0S2V5OiAhMCxcclxuICAgICAgICBidWJibGVzOiAhMCxcclxuICAgICAgICBjYW5jZWxhYmxlOiAhMCxcclxuICAgICAgICBjaGFuZ2VkVG91Y2hlczogITAsXHJcbiAgICAgICAgY3RybEtleTogITAsXHJcbiAgICAgICAgZGV0YWlsOiAhMCxcclxuICAgICAgICBldmVudFBoYXNlOiAhMCxcclxuICAgICAgICBtZXRhS2V5OiAhMCxcclxuICAgICAgICBwYWdlWDogITAsXHJcbiAgICAgICAgcGFnZVk6ICEwLFxyXG4gICAgICAgIHNoaWZ0S2V5OiAhMCxcclxuICAgICAgICB2aWV3OiAhMCxcclxuICAgICAgICBcImNoYXJcIjogITAsXHJcbiAgICAgICAgY2hhckNvZGU6ICEwLFxyXG4gICAgICAgIGtleTogITAsXHJcbiAgICAgICAga2V5Q29kZTogITAsXHJcbiAgICAgICAgYnV0dG9uOiAhMCxcclxuICAgICAgICBidXR0b25zOiAhMCxcclxuICAgICAgICBjbGllbnRYOiAhMCxcclxuICAgICAgICBjbGllbnRZOiAhMCxcclxuICAgICAgICBvZmZzZXRYOiAhMCxcclxuICAgICAgICBvZmZzZXRZOiAhMCxcclxuICAgICAgICBwb2ludGVySWQ6ICEwLFxyXG4gICAgICAgIHBvaW50ZXJUeXBlOiAhMCxcclxuICAgICAgICBzY3JlZW5YOiAhMCxcclxuICAgICAgICBzY3JlZW5ZOiAhMCxcclxuICAgICAgICB0YXJnZXRUb3VjaGVzOiAhMCxcclxuICAgICAgICB0b0VsZW1lbnQ6ICEwLFxyXG4gICAgICAgIHRvdWNoZXM6ICEwLFxyXG4gICAgICAgIHdoaWNoOiBmdW5jdGlvbihhKSB7XHJcbiAgICAgICAgICAgIHZhciBiID0gYS5idXR0b247XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsID09IGEud2hpY2ggJiYgc2EudGVzdChhLnR5cGUpID8gbnVsbCAhPSBhLmNoYXJDb2RlID8gYS5jaGFyQ29kZSA6IGEua2V5Q29kZSA6ICFhLndoaWNoICYmIHZvaWQgMCAhPT0gYiAmJiB0YS50ZXN0KGEudHlwZSkgPyAxICYgYiA/IDEgOiAyICYgYiA/IDMgOiA0ICYgYiA/IDIgOiAwIDogYS53aGljaFxyXG4gICAgICAgIH1cclxuICAgIH0sIHIuZXZlbnQuYWRkUHJvcCksIHIuZWFjaCh7XHJcbiAgICAgICAgbW91c2VlbnRlcjogXCJtb3VzZW92ZXJcIixcclxuICAgICAgICBtb3VzZWxlYXZlOiBcIm1vdXNlb3V0XCIsXHJcbiAgICAgICAgcG9pbnRlcmVudGVyOiBcInBvaW50ZXJvdmVyXCIsXHJcbiAgICAgICAgcG9pbnRlcmxlYXZlOiBcInBvaW50ZXJvdXRcIlxyXG4gICAgfSwgZnVuY3Rpb24oYSwgYikge1xyXG4gICAgICAgIHIuZXZlbnQuc3BlY2lhbFthXSA9IHtcclxuICAgICAgICAgICAgZGVsZWdhdGVUeXBlOiBiLFxyXG4gICAgICAgICAgICBiaW5kVHlwZTogYixcclxuICAgICAgICAgICAgaGFuZGxlOiBmdW5jdGlvbihhKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYywgZCA9IHRoaXMsXHJcbiAgICAgICAgICAgICAgICAgICAgZSA9IGEucmVsYXRlZFRhcmdldCxcclxuICAgICAgICAgICAgICAgICAgICBmID0gYS5oYW5kbGVPYmo7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZSAmJiAoZSA9PT0gZCB8fCByLmNvbnRhaW5zKGQsIGUpKSB8fCAoYS50eXBlID0gZi5vcmlnVHlwZSwgYyA9IGYuaGFuZGxlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCBhLnR5cGUgPSBiKSwgY1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSksIHIuZm4uZXh0ZW5kKHtcclxuICAgICAgICBvbjogZnVuY3Rpb24oYSwgYiwgYywgZCkge1xyXG4gICAgICAgICAgICByZXR1cm4geWEodGhpcywgYSwgYiwgYywgZClcclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uZTogZnVuY3Rpb24oYSwgYiwgYywgZCkge1xyXG4gICAgICAgICAgICByZXR1cm4geWEodGhpcywgYSwgYiwgYywgZCwgMSlcclxuICAgICAgICB9LFxyXG4gICAgICAgIG9mZjogZnVuY3Rpb24oYSwgYiwgYykge1xyXG4gICAgICAgICAgICB2YXIgZCwgZTtcclxuICAgICAgICAgICAgaWYgKGEgJiYgYS5wcmV2ZW50RGVmYXVsdCAmJiBhLmhhbmRsZU9iaikgcmV0dXJuIGQgPSBhLmhhbmRsZU9iaiwgcihhLmRlbGVnYXRlVGFyZ2V0KS5vZmYoZC5uYW1lc3BhY2UgPyBkLm9yaWdUeXBlICsgXCIuXCIgKyBkLm5hbWVzcGFjZSA6IGQub3JpZ1R5cGUsIGQuc2VsZWN0b3IsIGQuaGFuZGxlciksIHRoaXM7XHJcbiAgICAgICAgICAgIGlmIChcIm9iamVjdFwiID09IHR5cGVvZiBhKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGUgaW4gYSkgdGhpcy5vZmYoZSwgYiwgYVtlXSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBiICE9PSAhMSAmJiBcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIGIgfHwgKGMgPSBiLCBiID0gdm9pZCAwKSwgYyA9PT0gITEgJiYgKGMgPSB3YSksIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHIuZXZlbnQucmVtb3ZlKHRoaXMsIGEsIGMsIGIpXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICB2YXIgemEgPSAvPCg/IWFyZWF8YnJ8Y29sfGVtYmVkfGhyfGltZ3xpbnB1dHxsaW5rfG1ldGF8cGFyYW0pKChbYS16XVteXFwvXFwwPlxceDIwXFx0XFxyXFxuXFxmXSopW14+XSopXFwvPi9naSxcclxuICAgICAgICBBYSA9IC88c2NyaXB0fDxzdHlsZXw8bGluay9pLFxyXG4gICAgICAgIEJhID0gL2NoZWNrZWRcXHMqKD86W149XXw9XFxzKi5jaGVja2VkLikvaSxcclxuICAgICAgICBDYSA9IC9edHJ1ZVxcLyguKikvLFxyXG4gICAgICAgIERhID0gL15cXHMqPCEoPzpcXFtDREFUQVxcW3wtLSl8KD86XFxdXFxdfC0tKT5cXHMqJC9nO1xyXG5cclxuICAgIGZ1bmN0aW9uIEVhKGEsIGIpIHtcclxuICAgICAgICByZXR1cm4gQihhLCBcInRhYmxlXCIpICYmIEIoMTEgIT09IGIubm9kZVR5cGUgPyBiIDogYi5maXJzdENoaWxkLCBcInRyXCIpID8gcihcIj50Ym9keVwiLCBhKVswXSB8fCBhIDogYVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIEZhKGEpIHtcclxuICAgICAgICByZXR1cm4gYS50eXBlID0gKG51bGwgIT09IGEuZ2V0QXR0cmlidXRlKFwidHlwZVwiKSkgKyBcIi9cIiArIGEudHlwZSwgYVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIEdhKGEpIHtcclxuICAgICAgICB2YXIgYiA9IENhLmV4ZWMoYS50eXBlKTtcclxuICAgICAgICByZXR1cm4gYiA/IGEudHlwZSA9IGJbMV0gOiBhLnJlbW92ZUF0dHJpYnV0ZShcInR5cGVcIiksIGFcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBIYShhLCBiKSB7XHJcbiAgICAgICAgdmFyIGMsIGQsIGUsIGYsIGcsIGgsIGksIGo7XHJcbiAgICAgICAgaWYgKDEgPT09IGIubm9kZVR5cGUpIHtcclxuICAgICAgICAgICAgaWYgKFcuaGFzRGF0YShhKSAmJiAoZiA9IFcuYWNjZXNzKGEpLCBnID0gVy5zZXQoYiwgZiksIGogPSBmLmV2ZW50cykpIHtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBnLmhhbmRsZSwgZy5ldmVudHMgPSB7fTtcclxuICAgICAgICAgICAgICAgIGZvciAoZSBpbiBqKVxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoYyA9IDAsIGQgPSBqW2VdLmxlbmd0aDsgYyA8IGQ7IGMrKykgci5ldmVudC5hZGQoYiwgZSwgaltlXVtjXSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBYLmhhc0RhdGEoYSkgJiYgKGggPSBYLmFjY2VzcyhhKSwgaSA9IHIuZXh0ZW5kKHt9LCBoKSwgWC5zZXQoYiwgaSkpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIElhKGEsIGIpIHtcclxuICAgICAgICB2YXIgYyA9IGIubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICBcImlucHV0XCIgPT09IGMgJiYgamEudGVzdChhLnR5cGUpID8gYi5jaGVja2VkID0gYS5jaGVja2VkIDogXCJpbnB1dFwiICE9PSBjICYmIFwidGV4dGFyZWFcIiAhPT0gYyB8fCAoYi5kZWZhdWx0VmFsdWUgPSBhLmRlZmF1bHRWYWx1ZSlcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBKYShhLCBiLCBjLCBkKSB7XHJcbiAgICAgICAgYiA9IGcuYXBwbHkoW10sIGIpO1xyXG4gICAgICAgIHZhciBlLCBmLCBoLCBpLCBqLCBrLCBsID0gMCxcclxuICAgICAgICAgICAgbSA9IGEubGVuZ3RoLFxyXG4gICAgICAgICAgICBuID0gbSAtIDEsXHJcbiAgICAgICAgICAgIHEgPSBiWzBdLFxyXG4gICAgICAgICAgICBzID0gci5pc0Z1bmN0aW9uKHEpO1xyXG4gICAgICAgIGlmIChzIHx8IG0gPiAxICYmIFwic3RyaW5nXCIgPT0gdHlwZW9mIHEgJiYgIW8uY2hlY2tDbG9uZSAmJiBCYS50ZXN0KHEpKSByZXR1cm4gYS5lYWNoKGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgdmFyIGYgPSBhLmVxKGUpO1xyXG4gICAgICAgICAgICBzICYmIChiWzBdID0gcS5jYWxsKHRoaXMsIGUsIGYuaHRtbCgpKSksIEphKGYsIGIsIGMsIGQpXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKG0gJiYgKGUgPSBxYShiLCBhWzBdLm93bmVyRG9jdW1lbnQsICExLCBhLCBkKSwgZiA9IGUuZmlyc3RDaGlsZCwgMSA9PT0gZS5jaGlsZE5vZGVzLmxlbmd0aCAmJiAoZSA9IGYpLCBmIHx8IGQpKSB7XHJcbiAgICAgICAgICAgIGZvciAoaCA9IHIubWFwKG5hKGUsIFwic2NyaXB0XCIpLCBGYSksIGkgPSBoLmxlbmd0aDsgbCA8IG07IGwrKykgaiA9IGUsIGwgIT09IG4gJiYgKGogPSByLmNsb25lKGosICEwLCAhMCksIGkgJiYgci5tZXJnZShoLCBuYShqLCBcInNjcmlwdFwiKSkpLCBjLmNhbGwoYVtsXSwgaiwgbCk7XHJcbiAgICAgICAgICAgIGlmIChpKVxyXG4gICAgICAgICAgICAgICAgZm9yIChrID0gaFtoLmxlbmd0aCAtIDFdLm93bmVyRG9jdW1lbnQsIHIubWFwKGgsIEdhKSwgbCA9IDA7IGwgPCBpOyBsKyspIGogPSBoW2xdLCBsYS50ZXN0KGoudHlwZSB8fCBcIlwiKSAmJiAhVy5hY2Nlc3MoaiwgXCJnbG9iYWxFdmFsXCIpICYmIHIuY29udGFpbnMoaywgaikgJiYgKGouc3JjID8gci5fZXZhbFVybCAmJiByLl9ldmFsVXJsKGouc3JjKSA6IHAoai50ZXh0Q29udGVudC5yZXBsYWNlKERhLCBcIlwiKSwgaykpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gS2EoYSwgYiwgYykge1xyXG4gICAgICAgIGZvciAodmFyIGQsIGUgPSBiID8gci5maWx0ZXIoYiwgYSkgOiBhLCBmID0gMDsgbnVsbCAhPSAoZCA9IGVbZl0pOyBmKyspIGMgfHwgMSAhPT0gZC5ub2RlVHlwZSB8fCByLmNsZWFuRGF0YShuYShkKSksIGQucGFyZW50Tm9kZSAmJiAoYyAmJiByLmNvbnRhaW5zKGQub3duZXJEb2N1bWVudCwgZCkgJiYgb2EobmEoZCwgXCJzY3JpcHRcIikpLCBkLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZCkpO1xyXG4gICAgICAgIHJldHVybiBhXHJcbiAgICB9XHJcbiAgICByLmV4dGVuZCh7XHJcbiAgICAgICAgaHRtbFByZWZpbHRlcjogZnVuY3Rpb24oYSkge1xyXG4gICAgICAgICAgICByZXR1cm4gYS5yZXBsYWNlKHphLCBcIjwkMT48LyQyPlwiKVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY2xvbmU6IGZ1bmN0aW9uKGEsIGIsIGMpIHtcclxuICAgICAgICAgICAgdmFyIGQsIGUsIGYsIGcsIGggPSBhLmNsb25lTm9kZSghMCksXHJcbiAgICAgICAgICAgICAgICBpID0gci5jb250YWlucyhhLm93bmVyRG9jdW1lbnQsIGEpO1xyXG4gICAgICAgICAgICBpZiAoIShvLm5vQ2xvbmVDaGVja2VkIHx8IDEgIT09IGEubm9kZVR5cGUgJiYgMTEgIT09IGEubm9kZVR5cGUgfHwgci5pc1hNTERvYyhhKSkpXHJcbiAgICAgICAgICAgICAgICBmb3IgKGcgPSBuYShoKSwgZiA9IG5hKGEpLCBkID0gMCwgZSA9IGYubGVuZ3RoOyBkIDwgZTsgZCsrKSBJYShmW2RdLCBnW2RdKTtcclxuICAgICAgICAgICAgaWYgKGIpXHJcbiAgICAgICAgICAgICAgICBpZiAoYylcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGYgPSBmIHx8IG5hKGEpLCBnID0gZyB8fCBuYShoKSwgZCA9IDAsIGUgPSBmLmxlbmd0aDsgZCA8IGU7IGQrKykgSGEoZltkXSwgZ1tkXSk7XHJcbiAgICAgICAgICAgICAgICBlbHNlIEhhKGEsIGgpO1xyXG4gICAgICAgICAgICByZXR1cm4gZyA9IG5hKGgsIFwic2NyaXB0XCIpLCBnLmxlbmd0aCA+IDAgJiYgb2EoZywgIWkgJiYgbmEoYSwgXCJzY3JpcHRcIikpLCBoXHJcbiAgICAgICAgfSxcclxuICAgICAgICBjbGVhbkRhdGE6IGZ1bmN0aW9uKGEpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgYiwgYywgZCwgZSA9IHIuZXZlbnQuc3BlY2lhbCwgZiA9IDA7IHZvaWQgMCAhPT0gKGMgPSBhW2ZdKTsgZisrKVxyXG4gICAgICAgICAgICAgICAgaWYgKFUoYykpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYiA9IGNbVy5leHBhbmRvXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYi5ldmVudHMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGQgaW4gYi5ldmVudHMpIGVbZF0gPyByLmV2ZW50LnJlbW92ZShjLCBkKSA6IHIucmVtb3ZlRXZlbnQoYywgZCwgYi5oYW5kbGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjW1cuZXhwYW5kb10gPSB2b2lkIDBcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY1tYLmV4cGFuZG9dICYmIChjW1guZXhwYW5kb10gPSB2b2lkIDApXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSksIHIuZm4uZXh0ZW5kKHtcclxuICAgICAgICBkZXRhY2g6IGZ1bmN0aW9uKGEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIEthKHRoaXMsIGEsICEwKVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbihhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBLYSh0aGlzLCBhKVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdGV4dDogZnVuY3Rpb24oYSkge1xyXG4gICAgICAgICAgICByZXR1cm4gVCh0aGlzLCBmdW5jdGlvbihhKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdm9pZCAwID09PSBhID8gci50ZXh0KHRoaXMpIDogdGhpcy5lbXB0eSgpLmVhY2goZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgMSAhPT0gdGhpcy5ub2RlVHlwZSAmJiAxMSAhPT0gdGhpcy5ub2RlVHlwZSAmJiA5ICE9PSB0aGlzLm5vZGVUeXBlIHx8ICh0aGlzLnRleHRDb250ZW50ID0gYSlcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIH0sIG51bGwsIGEsIGFyZ3VtZW50cy5sZW5ndGgpXHJcbiAgICAgICAgfSxcclxuICAgICAgICBhcHBlbmQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gSmEodGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbihhKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoMSA9PT0gdGhpcy5ub2RlVHlwZSB8fCAxMSA9PT0gdGhpcy5ub2RlVHlwZSB8fCA5ID09PSB0aGlzLm5vZGVUeXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGIgPSBFYSh0aGlzLCBhKTtcclxuICAgICAgICAgICAgICAgICAgICBiLmFwcGVuZENoaWxkKGEpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfSxcclxuICAgICAgICBwcmVwZW5kOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIEphKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oYSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKDEgPT09IHRoaXMubm9kZVR5cGUgfHwgMTEgPT09IHRoaXMubm9kZVR5cGUgfHwgOSA9PT0gdGhpcy5ub2RlVHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBiID0gRWEodGhpcywgYSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYi5pbnNlcnRCZWZvcmUoYSwgYi5maXJzdENoaWxkKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYmVmb3JlOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIEphKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oYSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnROb2RlICYmIHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoYSwgdGhpcylcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9LFxyXG4gICAgICAgIGFmdGVyOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIEphKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oYSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnROb2RlICYmIHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoYSwgdGhpcy5uZXh0U2libGluZylcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVtcHR5OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgYSwgYiA9IDA7IG51bGwgIT0gKGEgPSB0aGlzW2JdKTsgYisrKSAxID09PSBhLm5vZGVUeXBlICYmIChyLmNsZWFuRGF0YShuYShhLCAhMSkpLCBhLnRleHRDb250ZW50ID0gXCJcIik7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfSxcclxuICAgICAgICBjbG9uZTogZnVuY3Rpb24oYSwgYikge1xyXG4gICAgICAgICAgICByZXR1cm4gYSA9IG51bGwgIT0gYSAmJiBhLCBiID0gbnVsbCA9PSBiID8gYSA6IGIsIHRoaXMubWFwKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHIuY2xvbmUodGhpcywgYSwgYilcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9LFxyXG4gICAgICAgIGh0bWw6IGZ1bmN0aW9uKGEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFQodGhpcywgZnVuY3Rpb24oYSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGIgPSB0aGlzWzBdIHx8IHt9LFxyXG4gICAgICAgICAgICAgICAgICAgIGMgPSAwLFxyXG4gICAgICAgICAgICAgICAgICAgIGQgPSB0aGlzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIGlmICh2b2lkIDAgPT09IGEgJiYgMSA9PT0gYi5ub2RlVHlwZSkgcmV0dXJuIGIuaW5uZXJIVE1MO1xyXG4gICAgICAgICAgICAgICAgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIGEgJiYgIUFhLnRlc3QoYSkgJiYgIW1hWyhrYS5leGVjKGEpIHx8IFtcIlwiLCBcIlwiXSlbMV0udG9Mb3dlckNhc2UoKV0pIHtcclxuICAgICAgICAgICAgICAgICAgICBhID0gci5odG1sUHJlZmlsdGVyKGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoOyBjIDwgZDsgYysrKSBiID0gdGhpc1tjXSB8fCB7fSwgMSA9PT0gYi5ub2RlVHlwZSAmJiAoci5jbGVhbkRhdGEobmEoYiwgITEpKSwgYi5pbm5lckhUTUwgPSBhKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYiA9IDBcclxuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7fVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYiAmJiB0aGlzLmVtcHR5KCkuYXBwZW5kKGEpXHJcbiAgICAgICAgICAgIH0sIG51bGwsIGEsIGFyZ3VtZW50cy5sZW5ndGgpXHJcbiAgICAgICAgfSxcclxuICAgICAgICByZXBsYWNlV2l0aDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciBhID0gW107XHJcbiAgICAgICAgICAgIHJldHVybiBKYSh0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKGIpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjID0gdGhpcy5wYXJlbnROb2RlO1xyXG4gICAgICAgICAgICAgICAgci5pbkFycmF5KHRoaXMsIGEpIDwgMCAmJiAoci5jbGVhbkRhdGEobmEodGhpcykpLCBjICYmIGMucmVwbGFjZUNoaWxkKGIsIHRoaXMpKVxyXG4gICAgICAgICAgICB9LCBhKVxyXG4gICAgICAgIH1cclxuICAgIH0pLCByLmVhY2goe1xyXG4gICAgICAgIGFwcGVuZFRvOiBcImFwcGVuZFwiLFxyXG4gICAgICAgIHByZXBlbmRUbzogXCJwcmVwZW5kXCIsXHJcbiAgICAgICAgaW5zZXJ0QmVmb3JlOiBcImJlZm9yZVwiLFxyXG4gICAgICAgIGluc2VydEFmdGVyOiBcImFmdGVyXCIsXHJcbiAgICAgICAgcmVwbGFjZUFsbDogXCJyZXBsYWNlV2l0aFwiXHJcbiAgICB9LCBmdW5jdGlvbihhLCBiKSB7XHJcbiAgICAgICAgci5mblthXSA9IGZ1bmN0aW9uKGEpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgYywgZCA9IFtdLCBlID0gcihhKSwgZiA9IGUubGVuZ3RoIC0gMSwgZyA9IDA7IGcgPD0gZjsgZysrKSBjID0gZyA9PT0gZiA/IHRoaXMgOiB0aGlzLmNsb25lKCEwKSwgcihlW2ddKVtiXShjKSwgaC5hcHBseShkLCBjLmdldCgpKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKGQpXHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICB2YXIgTGEgPSAvXm1hcmdpbi8sXHJcbiAgICAgICAgTWEgPSBuZXcgUmVnRXhwKFwiXihcIiArIGFhICsgXCIpKD8hcHgpW2EteiVdKyRcIiwgXCJpXCIpLFxyXG4gICAgICAgIE5hID0gZnVuY3Rpb24oYikge1xyXG4gICAgICAgICAgICB2YXIgYyA9IGIub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcclxuICAgICAgICAgICAgcmV0dXJuIGMgJiYgYy5vcGVuZXIgfHwgKGMgPSBhKSwgYy5nZXRDb21wdXRlZFN0eWxlKGIpXHJcbiAgICAgICAgfTtcclxuICAgICEgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gYigpIHtcclxuICAgICAgICAgICAgaWYgKGkpIHtcclxuICAgICAgICAgICAgICAgIGkuc3R5bGUuY3NzVGV4dCA9IFwiYm94LXNpemluZzpib3JkZXItYm94O3Bvc2l0aW9uOnJlbGF0aXZlO2Rpc3BsYXk6YmxvY2s7bWFyZ2luOmF1dG87Ym9yZGVyOjFweDtwYWRkaW5nOjFweDt0b3A6MSU7d2lkdGg6NTAlXCIsIGkuaW5uZXJIVE1MID0gXCJcIiwgcmEuYXBwZW5kQ2hpbGQoaCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgYiA9IGEuZ2V0Q29tcHV0ZWRTdHlsZShpKTtcclxuICAgICAgICAgICAgICAgIGMgPSBcIjElXCIgIT09IGIudG9wLCBnID0gXCIycHhcIiA9PT0gYi5tYXJnaW5MZWZ0LCBlID0gXCI0cHhcIiA9PT0gYi53aWR0aCwgaS5zdHlsZS5tYXJnaW5SaWdodCA9IFwiNTAlXCIsIGYgPSBcIjRweFwiID09PSBiLm1hcmdpblJpZ2h0LCByYS5yZW1vdmVDaGlsZChoKSwgaSA9IG51bGxcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYywgZSwgZiwgZywgaCA9IGQuY3JlYXRlRWxlbWVudChcImRpdlwiKSxcclxuICAgICAgICAgICAgaSA9IGQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcclxuICAgICAgICBpLnN0eWxlICYmIChpLnN0eWxlLmJhY2tncm91bmRDbGlwID0gXCJjb250ZW50LWJveFwiLCBpLmNsb25lTm9kZSghMCkuc3R5bGUuYmFja2dyb3VuZENsaXAgPSBcIlwiLCBvLmNsZWFyQ2xvbmVTdHlsZSA9IFwiY29udGVudC1ib3hcIiA9PT0gaS5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCwgaC5zdHlsZS5jc3NUZXh0ID0gXCJib3JkZXI6MDt3aWR0aDo4cHg7aGVpZ2h0OjA7dG9wOjA7bGVmdDotOTk5OXB4O3BhZGRpbmc6MDttYXJnaW4tdG9wOjFweDtwb3NpdGlvbjphYnNvbHV0ZVwiLCBoLmFwcGVuZENoaWxkKGkpLCByLmV4dGVuZChvLCB7XHJcbiAgICAgICAgICAgIHBpeGVsUG9zaXRpb246IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGIoKSwgY1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBib3hTaXppbmdSZWxpYWJsZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYigpLCBlXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHBpeGVsTWFyZ2luUmlnaHQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGIoKSwgZlxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICByZWxpYWJsZU1hcmdpbkxlZnQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGIoKSwgZ1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSkpXHJcbiAgICB9KCk7XHJcblxyXG4gICAgZnVuY3Rpb24gT2EoYSwgYiwgYykge1xyXG4gICAgICAgIHZhciBkLCBlLCBmLCBnLCBoID0gYS5zdHlsZTtcclxuICAgICAgICByZXR1cm4gYyA9IGMgfHwgTmEoYSksIGMgJiYgKGcgPSBjLmdldFByb3BlcnR5VmFsdWUoYikgfHwgY1tiXSwgXCJcIiAhPT0gZyB8fCByLmNvbnRhaW5zKGEub3duZXJEb2N1bWVudCwgYSkgfHwgKGcgPSByLnN0eWxlKGEsIGIpKSwgIW8ucGl4ZWxNYXJnaW5SaWdodCgpICYmIE1hLnRlc3QoZykgJiYgTGEudGVzdChiKSAmJiAoZCA9IGgud2lkdGgsIGUgPSBoLm1pbldpZHRoLCBmID0gaC5tYXhXaWR0aCwgaC5taW5XaWR0aCA9IGgubWF4V2lkdGggPSBoLndpZHRoID0gZywgZyA9IGMud2lkdGgsIGgud2lkdGggPSBkLCBoLm1pbldpZHRoID0gZSwgaC5tYXhXaWR0aCA9IGYpKSwgdm9pZCAwICE9PSBnID8gZyArIFwiXCIgOiBnXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gUGEoYSwgYikge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYSgpID8gdm9pZCBkZWxldGUgdGhpcy5nZXQgOiAodGhpcy5nZXQgPSBiKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB2YXIgUWEgPSAvXihub25lfHRhYmxlKD8hLWNbZWFdKS4rKS8sXHJcbiAgICAgICAgUmEgPSAvXi0tLyxcclxuICAgICAgICBTYSA9IHtcclxuICAgICAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcclxuICAgICAgICAgICAgdmlzaWJpbGl0eTogXCJoaWRkZW5cIixcclxuICAgICAgICAgICAgZGlzcGxheTogXCJibG9ja1wiXHJcbiAgICAgICAgfSxcclxuICAgICAgICBUYSA9IHtcclxuICAgICAgICAgICAgbGV0dGVyU3BhY2luZzogXCIwXCIsXHJcbiAgICAgICAgICAgIGZvbnRXZWlnaHQ6IFwiNDAwXCJcclxuICAgICAgICB9LFxyXG4gICAgICAgIFVhID0gW1wiV2Via2l0XCIsIFwiTW96XCIsIFwibXNcIl0sXHJcbiAgICAgICAgVmEgPSBkLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikuc3R5bGU7XHJcblxyXG4gICAgZnVuY3Rpb24gV2EoYSkge1xyXG4gICAgICAgIGlmIChhIGluIFZhKSByZXR1cm4gYTtcclxuICAgICAgICB2YXIgYiA9IGFbMF0udG9VcHBlckNhc2UoKSArIGEuc2xpY2UoMSksXHJcbiAgICAgICAgICAgIGMgPSBVYS5sZW5ndGg7XHJcbiAgICAgICAgd2hpbGUgKGMtLSlcclxuICAgICAgICAgICAgaWYgKGEgPSBVYVtjXSArIGIsIGEgaW4gVmEpIHJldHVybiBhXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gWGEoYSkge1xyXG4gICAgICAgIHZhciBiID0gci5jc3NQcm9wc1thXTtcclxuICAgICAgICByZXR1cm4gYiB8fCAoYiA9IHIuY3NzUHJvcHNbYV0gPSBXYShhKSB8fCBhKSwgYlxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIFlhKGEsIGIsIGMpIHtcclxuICAgICAgICB2YXIgZCA9IGJhLmV4ZWMoYik7XHJcbiAgICAgICAgcmV0dXJuIGQgPyBNYXRoLm1heCgwLCBkWzJdIC0gKGMgfHwgMCkpICsgKGRbM10gfHwgXCJweFwiKSA6IGJcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBaYShhLCBiLCBjLCBkLCBlKSB7XHJcbiAgICAgICAgdmFyIGYsIGcgPSAwO1xyXG4gICAgICAgIGZvciAoZiA9IGMgPT09IChkID8gXCJib3JkZXJcIiA6IFwiY29udGVudFwiKSA/IDQgOiBcIndpZHRoXCIgPT09IGIgPyAxIDogMDsgZiA8IDQ7IGYgKz0gMikgXCJtYXJnaW5cIiA9PT0gYyAmJiAoZyArPSByLmNzcyhhLCBjICsgY2FbZl0sICEwLCBlKSksIGQgPyAoXCJjb250ZW50XCIgPT09IGMgJiYgKGcgLT0gci5jc3MoYSwgXCJwYWRkaW5nXCIgKyBjYVtmXSwgITAsIGUpKSwgXCJtYXJnaW5cIiAhPT0gYyAmJiAoZyAtPSByLmNzcyhhLCBcImJvcmRlclwiICsgY2FbZl0gKyBcIldpZHRoXCIsICEwLCBlKSkpIDogKGcgKz0gci5jc3MoYSwgXCJwYWRkaW5nXCIgKyBjYVtmXSwgITAsIGUpLCBcInBhZGRpbmdcIiAhPT0gYyAmJiAoZyArPSByLmNzcyhhLCBcImJvcmRlclwiICsgY2FbZl0gKyBcIldpZHRoXCIsICEwLCBlKSkpO1xyXG4gICAgICAgIHJldHVybiBnXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gJGEoYSwgYiwgYykge1xyXG4gICAgICAgIHZhciBkLCBlID0gTmEoYSksXHJcbiAgICAgICAgICAgIGYgPSBPYShhLCBiLCBlKSxcclxuICAgICAgICAgICAgZyA9IFwiYm9yZGVyLWJveFwiID09PSByLmNzcyhhLCBcImJveFNpemluZ1wiLCAhMSwgZSk7XHJcbiAgICAgICAgcmV0dXJuIE1hLnRlc3QoZikgPyBmIDogKGQgPSBnICYmIChvLmJveFNpemluZ1JlbGlhYmxlKCkgfHwgZiA9PT0gYS5zdHlsZVtiXSksIFwiYXV0b1wiID09PSBmICYmIChmID0gYVtcIm9mZnNldFwiICsgYlswXS50b1VwcGVyQ2FzZSgpICsgYi5zbGljZSgxKV0pLCBmID0gcGFyc2VGbG9hdChmKSB8fCAwLCBmICsgWmEoYSwgYiwgYyB8fCAoZyA/IFwiYm9yZGVyXCIgOiBcImNvbnRlbnRcIiksIGQsIGUpICsgXCJweFwiKVxyXG4gICAgfVxyXG4gICAgci5leHRlbmQoe1xyXG4gICAgICAgIGNzc0hvb2tzOiB7XHJcbiAgICAgICAgICAgIG9wYWNpdHk6IHtcclxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oYSwgYikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjID0gT2EoYSwgXCJvcGFjaXR5XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJcIiA9PT0gYyA/IFwiMVwiIDogY1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY3NzTnVtYmVyOiB7XHJcbiAgICAgICAgICAgIGFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50OiAhMCxcclxuICAgICAgICAgICAgY29sdW1uQ291bnQ6ICEwLFxyXG4gICAgICAgICAgICBmaWxsT3BhY2l0eTogITAsXHJcbiAgICAgICAgICAgIGZsZXhHcm93OiAhMCxcclxuICAgICAgICAgICAgZmxleFNocmluazogITAsXHJcbiAgICAgICAgICAgIGZvbnRXZWlnaHQ6ICEwLFxyXG4gICAgICAgICAgICBsaW5lSGVpZ2h0OiAhMCxcclxuICAgICAgICAgICAgb3BhY2l0eTogITAsXHJcbiAgICAgICAgICAgIG9yZGVyOiAhMCxcclxuICAgICAgICAgICAgb3JwaGFuczogITAsXHJcbiAgICAgICAgICAgIHdpZG93czogITAsXHJcbiAgICAgICAgICAgIHpJbmRleDogITAsXHJcbiAgICAgICAgICAgIHpvb206ICEwXHJcbiAgICAgICAgfSxcclxuICAgICAgICBjc3NQcm9wczoge1xyXG4gICAgICAgICAgICBcImZsb2F0XCI6IFwiY3NzRmxvYXRcIlxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc3R5bGU6IGZ1bmN0aW9uKGEsIGIsIGMsIGQpIHtcclxuICAgICAgICAgICAgaWYgKGEgJiYgMyAhPT0gYS5ub2RlVHlwZSAmJiA4ICE9PSBhLm5vZGVUeXBlICYmIGEuc3R5bGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBlLCBmLCBnLCBoID0gci5jYW1lbENhc2UoYiksXHJcbiAgICAgICAgICAgICAgICAgICAgaSA9IFJhLnRlc3QoYiksXHJcbiAgICAgICAgICAgICAgICAgICAgaiA9IGEuc3R5bGU7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaSB8fCAoYiA9IFhhKGgpKSwgZyA9IHIuY3NzSG9va3NbYl0gfHwgci5jc3NIb29rc1toXSwgdm9pZCAwID09PSBjID8gZyAmJiBcImdldFwiIGluIGcgJiYgdm9pZCAwICE9PSAoZSA9IGcuZ2V0KGEsICExLCBkKSkgPyBlIDogaltiXSA6IChmID0gdHlwZW9mIGMsIFwic3RyaW5nXCIgPT09IGYgJiYgKGUgPSBiYS5leGVjKGMpKSAmJiBlWzFdICYmIChjID0gZmEoYSwgYiwgZSksIGYgPSBcIm51bWJlclwiKSwgbnVsbCAhPSBjICYmIGMgPT09IGMgJiYgKFwibnVtYmVyXCIgPT09IGYgJiYgKGMgKz0gZSAmJiBlWzNdIHx8IChyLmNzc051bWJlcltoXSA/IFwiXCIgOiBcInB4XCIpKSwgby5jbGVhckNsb25lU3R5bGUgfHwgXCJcIiAhPT0gYyB8fCAwICE9PSBiLmluZGV4T2YoXCJiYWNrZ3JvdW5kXCIpIHx8IChqW2JdID0gXCJpbmhlcml0XCIpLCBnICYmIFwic2V0XCIgaW4gZyAmJiB2b2lkIDAgPT09IChjID0gZy5zZXQoYSwgYywgZCkpIHx8IChpID8gai5zZXRQcm9wZXJ0eShiLCBjKSA6IGpbYl0gPSBjKSksIHZvaWQgMClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY3NzOiBmdW5jdGlvbihhLCBiLCBjLCBkKSB7XHJcbiAgICAgICAgICAgIHZhciBlLCBmLCBnLCBoID0gci5jYW1lbENhc2UoYiksXHJcbiAgICAgICAgICAgICAgICBpID0gUmEudGVzdChiKTtcclxuICAgICAgICAgICAgcmV0dXJuIGkgfHwgKGIgPSBYYShoKSksIGcgPSByLmNzc0hvb2tzW2JdIHx8IHIuY3NzSG9va3NbaF0sIGcgJiYgXCJnZXRcIiBpbiBnICYmIChlID0gZy5nZXQoYSwgITAsIGMpKSwgdm9pZCAwID09PSBlICYmIChlID0gT2EoYSwgYiwgZCkpLCBcIm5vcm1hbFwiID09PSBlICYmIGIgaW4gVGEgJiYgKGUgPSBUYVtiXSksIFwiXCIgPT09IGMgfHwgYyA/IChmID0gcGFyc2VGbG9hdChlKSwgYyA9PT0gITAgfHwgaXNGaW5pdGUoZikgPyBmIHx8IDAgOiBlKSA6IGVcclxuICAgICAgICB9XHJcbiAgICB9KSwgci5lYWNoKFtcImhlaWdodFwiLCBcIndpZHRoXCJdLCBmdW5jdGlvbihhLCBiKSB7XHJcbiAgICAgICAgci5jc3NIb29rc1tiXSA9IHtcclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbihhLCBjLCBkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYykgcmV0dXJuICFRYS50ZXN0KHIuY3NzKGEsIFwiZGlzcGxheVwiKSkgfHwgYS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCAmJiBhLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoID8gJGEoYSwgYiwgZCkgOiBlYShhLCBTYSwgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRhKGEsIGIsIGQpXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKGEsIGMsIGQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBlLCBmID0gZCAmJiBOYShhKSxcclxuICAgICAgICAgICAgICAgICAgICBnID0gZCAmJiBaYShhLCBiLCBkLCBcImJvcmRlci1ib3hcIiA9PT0gci5jc3MoYSwgXCJib3hTaXppbmdcIiwgITEsIGYpLCBmKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBnICYmIChlID0gYmEuZXhlYyhjKSkgJiYgXCJweFwiICE9PSAoZVszXSB8fCBcInB4XCIpICYmIChhLnN0eWxlW2JdID0gYywgYyA9IHIuY3NzKGEsIGIpKSwgWWEoYSwgYywgZylcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pLCByLmNzc0hvb2tzLm1hcmdpbkxlZnQgPSBQYShvLnJlbGlhYmxlTWFyZ2luTGVmdCwgZnVuY3Rpb24oYSwgYikge1xyXG4gICAgICAgIGlmIChiKSByZXR1cm4gKHBhcnNlRmxvYXQoT2EoYSwgXCJtYXJnaW5MZWZ0XCIpKSB8fCBhLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQgLSBlYShhLCB7XHJcbiAgICAgICAgICAgIG1hcmdpbkxlZnQ6IDBcclxuICAgICAgICB9LCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGEuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdFxyXG4gICAgICAgIH0pKSArIFwicHhcIlxyXG4gICAgfSksIHIuZWFjaCh7XHJcbiAgICAgICAgbWFyZ2luOiBcIlwiLFxyXG4gICAgICAgIHBhZGRpbmc6IFwiXCIsXHJcbiAgICAgICAgYm9yZGVyOiBcIldpZHRoXCJcclxuICAgIH0sIGZ1bmN0aW9uKGEsIGIpIHtcclxuICAgICAgICByLmNzc0hvb2tzW2EgKyBiXSA9IHtcclxuICAgICAgICAgICAgZXhwYW5kOiBmdW5jdGlvbihjKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBkID0gMCwgZSA9IHt9LCBmID0gXCJzdHJpbmdcIiA9PSB0eXBlb2YgYyA/IGMuc3BsaXQoXCIgXCIpIDogW2NdOyBkIDwgNDsgZCsrKSBlW2EgKyBjYVtkXSArIGJdID0gZltkXSB8fCBmW2QgLSAyXSB8fCBmWzBdO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIExhLnRlc3QoYSkgfHwgKHIuY3NzSG9va3NbYSArIGJdLnNldCA9IFlhKVxyXG4gICAgfSksIHIuZm4uZXh0ZW5kKHtcclxuICAgICAgICBjc3M6IGZ1bmN0aW9uKGEsIGIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFQodGhpcywgZnVuY3Rpb24oYSwgYiwgYykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGQsIGUsIGYgPSB7fSxcclxuICAgICAgICAgICAgICAgICAgICBnID0gMDtcclxuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChkID0gTmEoYSksIGUgPSBiLmxlbmd0aDsgZyA8IGU7IGcrKykgZltiW2ddXSA9IHIuY3NzKGEsIGJbZ10sICExLCBkKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZlxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZvaWQgMCAhPT0gYyA/IHIuc3R5bGUoYSwgYiwgYykgOiByLmNzcyhhLCBiKVxyXG4gICAgICAgICAgICB9LCBhLCBiLCBhcmd1bWVudHMubGVuZ3RoID4gMSlcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBmdW5jdGlvbiBfYShhLCBiLCBjLCBkLCBlKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBfYS5wcm90b3R5cGUuaW5pdChhLCBiLCBjLCBkLCBlKVxyXG4gICAgfVxyXG4gICAgci5Ud2VlbiA9IF9hLCBfYS5wcm90b3R5cGUgPSB7XHJcbiAgICAgICAgY29uc3RydWN0b3I6IF9hLFxyXG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uKGEsIGIsIGMsIGQsIGUsIGYpIHtcclxuICAgICAgICAgICAgdGhpcy5lbGVtID0gYSwgdGhpcy5wcm9wID0gYywgdGhpcy5lYXNpbmcgPSBlIHx8IHIuZWFzaW5nLl9kZWZhdWx0LCB0aGlzLm9wdGlvbnMgPSBiLCB0aGlzLnN0YXJ0ID0gdGhpcy5ub3cgPSB0aGlzLmN1cigpLCB0aGlzLmVuZCA9IGQsIHRoaXMudW5pdCA9IGYgfHwgKHIuY3NzTnVtYmVyW2NdID8gXCJcIiA6IFwicHhcIilcclxuICAgICAgICB9LFxyXG4gICAgICAgIGN1cjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciBhID0gX2EucHJvcEhvb2tzW3RoaXMucHJvcF07XHJcbiAgICAgICAgICAgIHJldHVybiBhICYmIGEuZ2V0ID8gYS5nZXQodGhpcykgOiBfYS5wcm9wSG9va3MuX2RlZmF1bHQuZ2V0KHRoaXMpXHJcbiAgICAgICAgfSxcclxuICAgICAgICBydW46IGZ1bmN0aW9uKGEpIHtcclxuICAgICAgICAgICAgdmFyIGIsIGMgPSBfYS5wcm9wSG9va3NbdGhpcy5wcm9wXTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5kdXJhdGlvbiA/IHRoaXMucG9zID0gYiA9IHIuZWFzaW5nW3RoaXMuZWFzaW5nXShhLCB0aGlzLm9wdGlvbnMuZHVyYXRpb24gKiBhLCAwLCAxLCB0aGlzLm9wdGlvbnMuZHVyYXRpb24pIDogdGhpcy5wb3MgPSBiID0gYSwgdGhpcy5ub3cgPSAodGhpcy5lbmQgLSB0aGlzLnN0YXJ0KSAqIGIgKyB0aGlzLnN0YXJ0LCB0aGlzLm9wdGlvbnMuc3RlcCAmJiB0aGlzLm9wdGlvbnMuc3RlcC5jYWxsKHRoaXMuZWxlbSwgdGhpcy5ub3csIHRoaXMpLCBjICYmIGMuc2V0ID8gYy5zZXQodGhpcykgOiBfYS5wcm9wSG9va3MuX2RlZmF1bHQuc2V0KHRoaXMpLCB0aGlzXHJcbiAgICAgICAgfVxyXG4gICAgfSwgX2EucHJvdG90eXBlLmluaXQucHJvdG90eXBlID0gX2EucHJvdG90eXBlLCBfYS5wcm9wSG9va3MgPSB7XHJcbiAgICAgICAgX2RlZmF1bHQ6IHtcclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbihhKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYjtcclxuICAgICAgICAgICAgICAgIHJldHVybiAxICE9PSBhLmVsZW0ubm9kZVR5cGUgfHwgbnVsbCAhPSBhLmVsZW1bYS5wcm9wXSAmJiBudWxsID09IGEuZWxlbS5zdHlsZVthLnByb3BdID8gYS5lbGVtW2EucHJvcF0gOiAoYiA9IHIuY3NzKGEuZWxlbSwgYS5wcm9wLCBcIlwiKSwgYiAmJiBcImF1dG9cIiAhPT0gYiA/IGIgOiAwKVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKGEpIHtcclxuICAgICAgICAgICAgICAgIHIuZnguc3RlcFthLnByb3BdID8gci5meC5zdGVwW2EucHJvcF0oYSkgOiAxICE9PSBhLmVsZW0ubm9kZVR5cGUgfHwgbnVsbCA9PSBhLmVsZW0uc3R5bGVbci5jc3NQcm9wc1thLnByb3BdXSAmJiAhci5jc3NIb29rc1thLnByb3BdID8gYS5lbGVtW2EucHJvcF0gPSBhLm5vdyA6IHIuc3R5bGUoYS5lbGVtLCBhLnByb3AsIGEubm93ICsgYS51bml0KVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSwgX2EucHJvcEhvb2tzLnNjcm9sbFRvcCA9IF9hLnByb3BIb29rcy5zY3JvbGxMZWZ0ID0ge1xyXG4gICAgICAgIHNldDogZnVuY3Rpb24oYSkge1xyXG4gICAgICAgICAgICBhLmVsZW0ubm9kZVR5cGUgJiYgYS5lbGVtLnBhcmVudE5vZGUgJiYgKGEuZWxlbVthLnByb3BdID0gYS5ub3cpXHJcbiAgICAgICAgfVxyXG4gICAgfSwgci5lYXNpbmcgPSB7XHJcbiAgICAgICAgbGluZWFyOiBmdW5jdGlvbihhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhXHJcbiAgICAgICAgfSxcclxuICAgICAgICBzd2luZzogZnVuY3Rpb24oYSkge1xyXG4gICAgICAgICAgICByZXR1cm4gLjUgLSBNYXRoLmNvcyhhICogTWF0aC5QSSkgLyAyXHJcbiAgICAgICAgfSxcclxuICAgICAgICBfZGVmYXVsdDogXCJzd2luZ1wiXHJcbiAgICB9LCByLmZ4ID0gX2EucHJvdG90eXBlLmluaXQsIHIuZnguc3RlcCA9IHt9O1xyXG4gICAgdmFyIGFiLCBiYiwgY2IgPSAvXig/OnRvZ2dsZXxzaG93fGhpZGUpJC8sXHJcbiAgICAgICAgZGIgPSAvcXVldWVIb29rcyQvO1xyXG5cclxuICAgIGZ1bmN0aW9uIGViKCkge1xyXG4gICAgICAgIGJiICYmIChkLmhpZGRlbiA9PT0gITEgJiYgYS5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPyBhLnJlcXVlc3RBbmltYXRpb25GcmFtZShlYikgOiBhLnNldFRpbWVvdXQoZWIsIHIuZnguaW50ZXJ2YWwpLCByLmZ4LnRpY2soKSlcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBmYigpIHtcclxuICAgICAgICByZXR1cm4gYS5zZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBhYiA9IHZvaWQgMFxyXG4gICAgICAgIH0pLCBhYiA9IHIubm93KClcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnYihhLCBiKSB7XHJcbiAgICAgICAgdmFyIGMsIGQgPSAwLFxyXG4gICAgICAgICAgICBlID0ge1xyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBhXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgZm9yIChiID0gYiA/IDEgOiAwOyBkIDwgNDsgZCArPSAyIC0gYikgYyA9IGNhW2RdLCBlW1wibWFyZ2luXCIgKyBjXSA9IGVbXCJwYWRkaW5nXCIgKyBjXSA9IGE7XHJcbiAgICAgICAgcmV0dXJuIGIgJiYgKGUub3BhY2l0eSA9IGUud2lkdGggPSBhKSwgZVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGhiKGEsIGIsIGMpIHtcclxuICAgICAgICBmb3IgKHZhciBkLCBlID0gKGtiLnR3ZWVuZXJzW2JdIHx8IFtdKS5jb25jYXQoa2IudHdlZW5lcnNbXCIqXCJdKSwgZiA9IDAsIGcgPSBlLmxlbmd0aDsgZiA8IGc7IGYrKylcclxuICAgICAgICAgICAgaWYgKGQgPSBlW2ZdLmNhbGwoYywgYiwgYSkpIHJldHVybiBkXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaWIoYSwgYiwgYykge1xyXG4gICAgICAgIHZhciBkLCBlLCBmLCBnLCBoLCBpLCBqLCBrLCBsID0gXCJ3aWR0aFwiIGluIGIgfHwgXCJoZWlnaHRcIiBpbiBiLFxyXG4gICAgICAgICAgICBtID0gdGhpcyxcclxuICAgICAgICAgICAgbiA9IHt9LFxyXG4gICAgICAgICAgICBvID0gYS5zdHlsZSxcclxuICAgICAgICAgICAgcCA9IGEubm9kZVR5cGUgJiYgZGEoYSksXHJcbiAgICAgICAgICAgIHEgPSBXLmdldChhLCBcImZ4c2hvd1wiKTtcclxuICAgICAgICBjLnF1ZXVlIHx8IChnID0gci5fcXVldWVIb29rcyhhLCBcImZ4XCIpLCBudWxsID09IGcudW5xdWV1ZWQgJiYgKGcudW5xdWV1ZWQgPSAwLCBoID0gZy5lbXB0eS5maXJlLCBnLmVtcHR5LmZpcmUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgZy51bnF1ZXVlZCB8fCBoKClcclxuICAgICAgICB9KSwgZy51bnF1ZXVlZCsrLCBtLmFsd2F5cyhmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgbS5hbHdheXMoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICBnLnVucXVldWVkLS0sIHIucXVldWUoYSwgXCJmeFwiKS5sZW5ndGggfHwgZy5lbXB0eS5maXJlKClcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9KSk7XHJcbiAgICAgICAgZm9yIChkIGluIGIpXHJcbiAgICAgICAgICAgIGlmIChlID0gYltkXSwgY2IudGVzdChlKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGRlbGV0ZSBiW2RdLCBmID0gZiB8fCBcInRvZ2dsZVwiID09PSBlLCBlID09PSAocCA/IFwiaGlkZVwiIDogXCJzaG93XCIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKFwic2hvd1wiICE9PSBlIHx8ICFxIHx8IHZvaWQgMCA9PT0gcVtkXSkgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgcCA9ICEwXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBuW2RdID0gcSAmJiBxW2RdIHx8IHIuc3R5bGUoYSwgZClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIGlmIChpID0gIXIuaXNFbXB0eU9iamVjdChiKSwgaSB8fCAhci5pc0VtcHR5T2JqZWN0KG4pKSB7XHJcbiAgICAgICAgICAgIGwgJiYgMSA9PT0gYS5ub2RlVHlwZSAmJiAoYy5vdmVyZmxvdyA9IFtvLm92ZXJmbG93LCBvLm92ZXJmbG93WCwgby5vdmVyZmxvd1ldLCBqID0gcSAmJiBxLmRpc3BsYXksIG51bGwgPT0gaiAmJiAoaiA9IFcuZ2V0KGEsIFwiZGlzcGxheVwiKSksIGsgPSByLmNzcyhhLCBcImRpc3BsYXlcIiksIFwibm9uZVwiID09PSBrICYmIChqID8gayA9IGogOiAoaWEoW2FdLCAhMCksIGogPSBhLnN0eWxlLmRpc3BsYXkgfHwgaiwgayA9IHIuY3NzKGEsIFwiZGlzcGxheVwiKSwgaWEoW2FdKSkpLCAoXCJpbmxpbmVcIiA9PT0gayB8fCBcImlubGluZS1ibG9ja1wiID09PSBrICYmIG51bGwgIT0gaikgJiYgXCJub25lXCIgPT09IHIuY3NzKGEsIFwiZmxvYXRcIikgJiYgKGkgfHwgKG0uZG9uZShmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIG8uZGlzcGxheSA9IGpcclxuICAgICAgICAgICAgfSksIG51bGwgPT0gaiAmJiAoayA9IG8uZGlzcGxheSwgaiA9IFwibm9uZVwiID09PSBrID8gXCJcIiA6IGspKSwgby5kaXNwbGF5ID0gXCJpbmxpbmUtYmxvY2tcIikpLCBjLm92ZXJmbG93ICYmIChvLm92ZXJmbG93ID0gXCJoaWRkZW5cIiwgbS5hbHdheXMoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICBvLm92ZXJmbG93ID0gYy5vdmVyZmxvd1swXSwgby5vdmVyZmxvd1ggPSBjLm92ZXJmbG93WzFdLCBvLm92ZXJmbG93WSA9IGMub3ZlcmZsb3dbMl1cclxuICAgICAgICAgICAgfSkpLCBpID0gITE7XHJcbiAgICAgICAgICAgIGZvciAoZCBpbiBuKSBpIHx8IChxID8gXCJoaWRkZW5cIiBpbiBxICYmIChwID0gcS5oaWRkZW4pIDogcSA9IFcuYWNjZXNzKGEsIFwiZnhzaG93XCIsIHtcclxuICAgICAgICAgICAgICAgIGRpc3BsYXk6IGpcclxuICAgICAgICAgICAgfSksIGYgJiYgKHEuaGlkZGVuID0gIXApLCBwICYmIGlhKFthXSwgITApLCBtLmRvbmUoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICBwIHx8IGlhKFthXSksIFcucmVtb3ZlKGEsIFwiZnhzaG93XCIpO1xyXG4gICAgICAgICAgICAgICAgZm9yIChkIGluIG4pIHIuc3R5bGUoYSwgZCwgbltkXSlcclxuICAgICAgICAgICAgfSkpLCBpID0gaGIocCA/IHFbZF0gOiAwLCBkLCBtKSwgZCBpbiBxIHx8IChxW2RdID0gaS5zdGFydCwgcCAmJiAoaS5lbmQgPSBpLnN0YXJ0LCBpLnN0YXJ0ID0gMCkpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGpiKGEsIGIpIHtcclxuICAgICAgICB2YXIgYywgZCwgZSwgZiwgZztcclxuICAgICAgICBmb3IgKGMgaW4gYSlcclxuICAgICAgICAgICAgaWYgKGQgPSByLmNhbWVsQ2FzZShjKSwgZSA9IGJbZF0sIGYgPSBhW2NdLCBBcnJheS5pc0FycmF5KGYpICYmIChlID0gZlsxXSwgZiA9IGFbY10gPSBmWzBdKSwgYyAhPT0gZCAmJiAoYVtkXSA9IGYsIGRlbGV0ZSBhW2NdKSwgZyA9IHIuY3NzSG9va3NbZF0sIGcgJiYgXCJleHBhbmRcIiBpbiBnKSB7XHJcbiAgICAgICAgICAgICAgICBmID0gZy5leHBhbmQoZiksIGRlbGV0ZSBhW2RdO1xyXG4gICAgICAgICAgICAgICAgZm9yIChjIGluIGYpIGMgaW4gYSB8fCAoYVtjXSA9IGZbY10sIGJbY10gPSBlKVxyXG4gICAgICAgICAgICB9IGVsc2UgYltkXSA9IGVcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBrYihhLCBiLCBjKSB7XHJcbiAgICAgICAgdmFyIGQsIGUsIGYgPSAwLFxyXG4gICAgICAgICAgICBnID0ga2IucHJlZmlsdGVycy5sZW5ndGgsXHJcbiAgICAgICAgICAgIGggPSByLkRlZmVycmVkKCkuYWx3YXlzKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIGkuZWxlbVxyXG4gICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgaSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGUpIHJldHVybiAhMTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGIgPSBhYiB8fCBmYigpLCBjID0gTWF0aC5tYXgoMCwgai5zdGFydFRpbWUgKyBqLmR1cmF0aW9uIC0gYiksIGQgPSBjIC8gai5kdXJhdGlvbiB8fCAwLCBmID0gMSAtIGQsIGcgPSAwLCBpID0gai50d2VlbnMubGVuZ3RoOyBnIDwgaTsgZysrKSBqLnR3ZWVuc1tnXS5ydW4oZik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaC5ub3RpZnlXaXRoKGEsIFtqLCBmLCBjXSksIGYgPCAxICYmIGkgPyBjIDogKGkgfHwgaC5ub3RpZnlXaXRoKGEsIFtqLCAxLCAwXSksIGgucmVzb2x2ZVdpdGgoYSwgW2pdKSwgITEpXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGogPSBoLnByb21pc2Uoe1xyXG4gICAgICAgICAgICAgICAgZWxlbTogYSxcclxuICAgICAgICAgICAgICAgIHByb3BzOiByLmV4dGVuZCh7fSwgYiksXHJcbiAgICAgICAgICAgICAgICBvcHRzOiByLmV4dGVuZCghMCwge1xyXG4gICAgICAgICAgICAgICAgICAgIHNwZWNpYWxFYXNpbmc6IHt9LFxyXG4gICAgICAgICAgICAgICAgICAgIGVhc2luZzogci5lYXNpbmcuX2RlZmF1bHRcclxuICAgICAgICAgICAgICAgIH0sIGMpLFxyXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxQcm9wZXJ0aWVzOiBiLFxyXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxPcHRpb25zOiBjLFxyXG4gICAgICAgICAgICAgICAgc3RhcnRUaW1lOiBhYiB8fCBmYigpLFxyXG4gICAgICAgICAgICAgICAgZHVyYXRpb246IGMuZHVyYXRpb24sXHJcbiAgICAgICAgICAgICAgICB0d2VlbnM6IFtdLFxyXG4gICAgICAgICAgICAgICAgY3JlYXRlVHdlZW46IGZ1bmN0aW9uKGIsIGMpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZCA9IHIuVHdlZW4oYSwgai5vcHRzLCBiLCBjLCBqLm9wdHMuc3BlY2lhbEVhc2luZ1tiXSB8fCBqLm9wdHMuZWFzaW5nKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gai50d2VlbnMucHVzaChkKSwgZFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHN0b3A6IGZ1bmN0aW9uKGIpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYyA9IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGQgPSBiID8gai50d2VlbnMubGVuZ3RoIDogMDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZSkgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChlID0gITA7IGMgPCBkOyBjKyspIGoudHdlZW5zW2NdLnJ1bigxKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYiA/IChoLm5vdGlmeVdpdGgoYSwgW2osIDEsIDBdKSwgaC5yZXNvbHZlV2l0aChhLCBbaiwgYl0pKSA6IGgucmVqZWN0V2l0aChhLCBbaiwgYl0pLCB0aGlzXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICBrID0gai5wcm9wcztcclxuICAgICAgICBmb3IgKGpiKGssIGoub3B0cy5zcGVjaWFsRWFzaW5nKTsgZiA8IGc7IGYrKylcclxuICAgICAgICAgICAgaWYgKGQgPSBrYi5wcmVmaWx0ZXJzW2ZdLmNhbGwoaiwgYSwgaywgai5vcHRzKSkgcmV0dXJuIHIuaXNGdW5jdGlvbihkLnN0b3ApICYmIChyLl9xdWV1ZUhvb2tzKGouZWxlbSwgai5vcHRzLnF1ZXVlKS5zdG9wID0gci5wcm94eShkLnN0b3AsIGQpKSwgZDtcclxuICAgICAgICByZXR1cm4gci5tYXAoaywgaGIsIGopLCByLmlzRnVuY3Rpb24oai5vcHRzLnN0YXJ0KSAmJiBqLm9wdHMuc3RhcnQuY2FsbChhLCBqKSwgai5wcm9ncmVzcyhqLm9wdHMucHJvZ3Jlc3MpLmRvbmUoai5vcHRzLmRvbmUsIGoub3B0cy5jb21wbGV0ZSkuZmFpbChqLm9wdHMuZmFpbCkuYWx3YXlzKGoub3B0cy5hbHdheXMpLCByLmZ4LnRpbWVyKHIuZXh0ZW5kKGksIHtcclxuICAgICAgICAgICAgZWxlbTogYSxcclxuICAgICAgICAgICAgYW5pbTogaixcclxuICAgICAgICAgICAgcXVldWU6IGoub3B0cy5xdWV1ZVxyXG4gICAgICAgIH0pKSwgalxyXG4gICAgfVxyXG4gICAgci5BbmltYXRpb24gPSByLmV4dGVuZChrYiwge1xyXG4gICAgICAgICAgICB0d2VlbmVyczoge1xyXG4gICAgICAgICAgICAgICAgXCIqXCI6IFtmdW5jdGlvbihhLCBiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGMgPSB0aGlzLmNyZWF0ZVR3ZWVuKGEsIGIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYShjLmVsZW0sIGEsIGJhLmV4ZWMoYiksIGMpLCBjXHJcbiAgICAgICAgICAgICAgICB9XVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB0d2VlbmVyOiBmdW5jdGlvbihhLCBiKSB7XHJcbiAgICAgICAgICAgICAgICByLmlzRnVuY3Rpb24oYSkgPyAoYiA9IGEsIGEgPSBbXCIqXCJdKSA6IGEgPSBhLm1hdGNoKEwpO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgYywgZCA9IDAsIGUgPSBhLmxlbmd0aDsgZCA8IGU7IGQrKykgYyA9IGFbZF0sIGtiLnR3ZWVuZXJzW2NdID0ga2IudHdlZW5lcnNbY10gfHwgW10sIGtiLnR3ZWVuZXJzW2NdLnVuc2hpZnQoYilcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcHJlZmlsdGVyczogW2liXSxcclxuICAgICAgICAgICAgcHJlZmlsdGVyOiBmdW5jdGlvbihhLCBiKSB7XHJcbiAgICAgICAgICAgICAgICBiID8ga2IucHJlZmlsdGVycy51bnNoaWZ0KGEpIDoga2IucHJlZmlsdGVycy5wdXNoKGEpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KSwgci5zcGVlZCA9IGZ1bmN0aW9uKGEsIGIsIGMpIHtcclxuICAgICAgICAgICAgdmFyIGQgPSBhICYmIFwib2JqZWN0XCIgPT0gdHlwZW9mIGEgPyByLmV4dGVuZCh7fSwgYSkgOiB7XHJcbiAgICAgICAgICAgICAgICBjb21wbGV0ZTogYyB8fCAhYyAmJiBiIHx8IHIuaXNGdW5jdGlvbihhKSAmJiBhLFxyXG4gICAgICAgICAgICAgICAgZHVyYXRpb246IGEsXHJcbiAgICAgICAgICAgICAgICBlYXNpbmc6IGMgJiYgYiB8fCBiICYmICFyLmlzRnVuY3Rpb24oYikgJiYgYlxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gci5meC5vZmYgPyBkLmR1cmF0aW9uID0gMCA6IFwibnVtYmVyXCIgIT0gdHlwZW9mIGQuZHVyYXRpb24gJiYgKGQuZHVyYXRpb24gaW4gci5meC5zcGVlZHMgPyBkLmR1cmF0aW9uID0gci5meC5zcGVlZHNbZC5kdXJhdGlvbl0gOiBkLmR1cmF0aW9uID0gci5meC5zcGVlZHMuX2RlZmF1bHQpLCBudWxsICE9IGQucXVldWUgJiYgZC5xdWV1ZSAhPT0gITAgfHwgKGQucXVldWUgPSBcImZ4XCIpLCBkLm9sZCA9IGQuY29tcGxldGUsIGQuY29tcGxldGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHIuaXNGdW5jdGlvbihkLm9sZCkgJiYgZC5vbGQuY2FsbCh0aGlzKSwgZC5xdWV1ZSAmJiByLmRlcXVldWUodGhpcywgZC5xdWV1ZSlcclxuICAgICAgICAgICAgfSwgZFxyXG4gICAgICAgIH0sIHIuZm4uZXh0ZW5kKHtcclxuICAgICAgICAgICAgZmFkZVRvOiBmdW5jdGlvbihhLCBiLCBjLCBkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXIoZGEpLmNzcyhcIm9wYWNpdHlcIiwgMCkuc2hvdygpLmVuZCgpLmFuaW1hdGUoe1xyXG4gICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IGJcclxuICAgICAgICAgICAgICAgIH0sIGEsIGMsIGQpXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGFuaW1hdGU6IGZ1bmN0aW9uKGEsIGIsIGMsIGQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBlID0gci5pc0VtcHR5T2JqZWN0KGEpLFxyXG4gICAgICAgICAgICAgICAgICAgIGYgPSByLnNwZWVkKGIsIGMsIGQpLFxyXG4gICAgICAgICAgICAgICAgICAgIGcgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGIgPSBrYih0aGlzLCByLmV4dGVuZCh7fSwgYSksIGYpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAoZSB8fCBXLmdldCh0aGlzLCBcImZpbmlzaFwiKSkgJiYgYi5zdG9wKCEwKVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZy5maW5pc2ggPSBnLCBlIHx8IGYucXVldWUgPT09ICExID8gdGhpcy5lYWNoKGcpIDogdGhpcy5xdWV1ZShmLnF1ZXVlLCBnKVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzdG9wOiBmdW5jdGlvbihhLCBiLCBjKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZCA9IGZ1bmN0aW9uKGEpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYiA9IGEuc3RvcDtcclxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgYS5zdG9wLCBiKGMpXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwic3RyaW5nXCIgIT0gdHlwZW9mIGEgJiYgKGMgPSBiLCBiID0gYSwgYSA9IHZvaWQgMCksIGIgJiYgYSAhPT0gITEgJiYgdGhpcy5xdWV1ZShhIHx8IFwiZnhcIiwgW10pLCB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGIgPSAhMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZSA9IG51bGwgIT0gYSAmJiBhICsgXCJxdWV1ZUhvb2tzXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGYgPSByLnRpbWVycyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZyA9IFcuZ2V0KHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlKSBnW2VdICYmIGdbZV0uc3RvcCAmJiBkKGdbZV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChlIGluIGcpIGdbZV0gJiYgZ1tlXS5zdG9wICYmIGRiLnRlc3QoZSkgJiYgZChnW2VdKTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGUgPSBmLmxlbmd0aDsgZS0tOykgZltlXS5lbGVtICE9PSB0aGlzIHx8IG51bGwgIT0gYSAmJiBmW2VdLnF1ZXVlICE9PSBhIHx8IChmW2VdLmFuaW0uc3RvcChjKSwgYiA9ICExLCBmLnNwbGljZShlLCAxKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgIWIgJiYgYyB8fCByLmRlcXVldWUodGhpcywgYSlcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGZpbmlzaDogZnVuY3Rpb24oYSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGEgIT09ICExICYmIChhID0gYSB8fCBcImZ4XCIpLCB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGIsIGMgPSBXLmdldCh0aGlzKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZCA9IGNbYSArIFwicXVldWVcIl0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGUgPSBjW2EgKyBcInF1ZXVlSG9va3NcIl0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGYgPSByLnRpbWVycyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZyA9IGQgPyBkLmxlbmd0aCA6IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjLmZpbmlzaCA9ICEwLCByLnF1ZXVlKHRoaXMsIGEsIFtdKSwgZSAmJiBlLnN0b3AgJiYgZS5zdG9wLmNhbGwodGhpcywgITApLCBiID0gZi5sZW5ndGg7IGItLTspIGZbYl0uZWxlbSA9PT0gdGhpcyAmJiBmW2JdLnF1ZXVlID09PSBhICYmIChmW2JdLmFuaW0uc3RvcCghMCksIGYuc3BsaWNlKGIsIDEpKTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGIgPSAwOyBiIDwgZzsgYisrKSBkW2JdICYmIGRbYl0uZmluaXNoICYmIGRbYl0uZmluaXNoLmNhbGwodGhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGMuZmluaXNoXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSksIHIuZWFjaChbXCJ0b2dnbGVcIiwgXCJzaG93XCIsIFwiaGlkZVwiXSwgZnVuY3Rpb24oYSwgYikge1xyXG4gICAgICAgICAgICB2YXIgYyA9IHIuZm5bYl07XHJcbiAgICAgICAgICAgIHIuZm5bYl0gPSBmdW5jdGlvbihhLCBkLCBlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbCA9PSBhIHx8IFwiYm9vbGVhblwiID09IHR5cGVvZiBhID8gYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogdGhpcy5hbmltYXRlKGdiKGIsICEwKSwgYSwgZCwgZSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pLCByLmVhY2goe1xyXG4gICAgICAgICAgICBzbGlkZURvd246IGdiKFwic2hvd1wiKSxcclxuICAgICAgICAgICAgc2xpZGVVcDogZ2IoXCJoaWRlXCIpLFxyXG4gICAgICAgICAgICBzbGlkZVRvZ2dsZTogZ2IoXCJ0b2dnbGVcIiksXHJcbiAgICAgICAgICAgIGZhZGVJbjoge1xyXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogXCJzaG93XCJcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZmFkZU91dDoge1xyXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogXCJoaWRlXCJcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZmFkZVRvZ2dsZToge1xyXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogXCJ0b2dnbGVcIlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgZnVuY3Rpb24oYSwgYikge1xyXG4gICAgICAgICAgICByLmZuW2FdID0gZnVuY3Rpb24oYSwgYywgZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYW5pbWF0ZShiLCBhLCBjLCBkKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSksIHIudGltZXJzID0gW10sIHIuZngudGljayA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgYSwgYiA9IDAsXHJcbiAgICAgICAgICAgICAgICBjID0gci50aW1lcnM7XHJcbiAgICAgICAgICAgIGZvciAoYWIgPSByLm5vdygpOyBiIDwgYy5sZW5ndGg7IGIrKykgYSA9IGNbYl0sIGEoKSB8fCBjW2JdICE9PSBhIHx8IGMuc3BsaWNlKGItLSwgMSk7XHJcbiAgICAgICAgICAgIGMubGVuZ3RoIHx8IHIuZnguc3RvcCgpLCBhYiA9IHZvaWQgMFxyXG4gICAgICAgIH0sIHIuZngudGltZXIgPSBmdW5jdGlvbihhKSB7XHJcbiAgICAgICAgICAgIHIudGltZXJzLnB1c2goYSksIHIuZnguc3RhcnQoKVxyXG4gICAgICAgIH0sIHIuZnguaW50ZXJ2YWwgPSAxMywgci5meC5zdGFydCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBiYiB8fCAoYmIgPSAhMCwgZWIoKSlcclxuICAgICAgICB9LCByLmZ4LnN0b3AgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgYmIgPSBudWxsXHJcbiAgICAgICAgfSwgci5meC5zcGVlZHMgPSB7XHJcbiAgICAgICAgICAgIHNsb3c6IDYwMCxcclxuICAgICAgICAgICAgZmFzdDogMjAwLFxyXG4gICAgICAgICAgICBfZGVmYXVsdDogNDAwXHJcbiAgICAgICAgfSwgci5mbi5kZWxheSA9IGZ1bmN0aW9uKGIsIGMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGIgPSByLmZ4ID8gci5meC5zcGVlZHNbYl0gfHwgYiA6IGIsIGMgPSBjIHx8IFwiZnhcIiwgdGhpcy5xdWV1ZShjLCBmdW5jdGlvbihjLCBkKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZSA9IGEuc2V0VGltZW91dChjLCBiKTtcclxuICAgICAgICAgICAgICAgIGQuc3RvcCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGEuY2xlYXJUaW1lb3V0KGUpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfSxcclxuICAgICAgICBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIGEgPSBkLmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKSxcclxuICAgICAgICAgICAgICAgIGIgPSBkLmNyZWF0ZUVsZW1lbnQoXCJzZWxlY3RcIiksXHJcbiAgICAgICAgICAgICAgICBjID0gYi5hcHBlbmRDaGlsZChkLmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIikpO1xyXG4gICAgICAgICAgICBhLnR5cGUgPSBcImNoZWNrYm94XCIsIG8uY2hlY2tPbiA9IFwiXCIgIT09IGEudmFsdWUsIG8ub3B0U2VsZWN0ZWQgPSBjLnNlbGVjdGVkLCBhID0gZC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIiksIGEudmFsdWUgPSBcInRcIiwgYS50eXBlID0gXCJyYWRpb1wiLCBvLnJhZGlvVmFsdWUgPSBcInRcIiA9PT0gYS52YWx1ZVxyXG4gICAgICAgIH0oKTtcclxuICAgIHZhciBsYiwgbWIgPSByLmV4cHIuYXR0ckhhbmRsZTtcclxuICAgIHIuZm4uZXh0ZW5kKHtcclxuICAgICAgICBhdHRyOiBmdW5jdGlvbihhLCBiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBUKHRoaXMsIHIuYXR0ciwgYSwgYiwgYXJndW1lbnRzLmxlbmd0aCA+IDEpXHJcbiAgICAgICAgfSxcclxuICAgICAgICByZW1vdmVBdHRyOiBmdW5jdGlvbihhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICByLnJlbW92ZUF0dHIodGhpcywgYSlcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9XHJcbiAgICB9KSwgci5leHRlbmQoe1xyXG4gICAgICAgIGF0dHI6IGZ1bmN0aW9uKGEsIGIsIGMpIHtcclxuICAgICAgICAgICAgdmFyIGQsIGUsIGYgPSBhLm5vZGVUeXBlO1xyXG4gICAgICAgICAgICBpZiAoMyAhPT0gZiAmJiA4ICE9PSBmICYmIDIgIT09IGYpIHJldHVybiBcInVuZGVmaW5lZFwiID09IHR5cGVvZiBhLmdldEF0dHJpYnV0ZSA/IHIucHJvcChhLCBiLCBjKSA6ICgxID09PSBmICYmIHIuaXNYTUxEb2MoYSkgfHwgKGUgPSByLmF0dHJIb29rc1tiLnRvTG93ZXJDYXNlKCldIHx8IChyLmV4cHIubWF0Y2guYm9vbC50ZXN0KGIpID8gbGIgOiB2b2lkIDApKSwgdm9pZCAwICE9PSBjID8gbnVsbCA9PT0gYyA/IHZvaWQgci5yZW1vdmVBdHRyKGEsIGIpIDogZSAmJiBcInNldFwiIGluIGUgJiYgdm9pZCAwICE9PSAoZCA9IGUuc2V0KGEsIGMsIGIpKSA/IGQgOiAoYS5zZXRBdHRyaWJ1dGUoYiwgYyArIFwiXCIpLCBjKSA6IGUgJiYgXCJnZXRcIiBpbiBlICYmIG51bGwgIT09IChkID0gZS5nZXQoYSwgYikpID8gZCA6IChkID0gci5maW5kLmF0dHIoYSwgYiksXHJcbiAgICAgICAgICAgICAgICBudWxsID09IGQgPyB2b2lkIDAgOiBkKSlcclxuICAgICAgICB9LFxyXG4gICAgICAgIGF0dHJIb29rczoge1xyXG4gICAgICAgICAgICB0eXBlOiB7XHJcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKGEsIGIpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIW8ucmFkaW9WYWx1ZSAmJiBcInJhZGlvXCIgPT09IGIgJiYgQihhLCBcImlucHV0XCIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjID0gYS52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEuc2V0QXR0cmlidXRlKFwidHlwZVwiLCBiKSwgYyAmJiAoYS52YWx1ZSA9IGMpLCBiXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICByZW1vdmVBdHRyOiBmdW5jdGlvbihhLCBiKSB7XHJcbiAgICAgICAgICAgIHZhciBjLCBkID0gMCxcclxuICAgICAgICAgICAgICAgIGUgPSBiICYmIGIubWF0Y2goTCk7XHJcbiAgICAgICAgICAgIGlmIChlICYmIDEgPT09IGEubm9kZVR5cGUpXHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoYyA9IGVbZCsrXSkgYS5yZW1vdmVBdHRyaWJ1dGUoYylcclxuICAgICAgICB9XHJcbiAgICB9KSwgbGIgPSB7XHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbihhLCBiLCBjKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBiID09PSAhMSA/IHIucmVtb3ZlQXR0cihhLCBjKSA6IGEuc2V0QXR0cmlidXRlKGMsIGMpLCBjXHJcbiAgICAgICAgfVxyXG4gICAgfSwgci5lYWNoKHIuZXhwci5tYXRjaC5ib29sLnNvdXJjZS5tYXRjaCgvXFx3Ky9nKSwgZnVuY3Rpb24oYSwgYikge1xyXG4gICAgICAgIHZhciBjID0gbWJbYl0gfHwgci5maW5kLmF0dHI7XHJcbiAgICAgICAgbWJbYl0gPSBmdW5jdGlvbihhLCBiLCBkKSB7XHJcbiAgICAgICAgICAgIHZhciBlLCBmLCBnID0gYi50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICByZXR1cm4gZCB8fCAoZiA9IG1iW2ddLCBtYltnXSA9IGUsIGUgPSBudWxsICE9IGMoYSwgYiwgZCkgPyBnIDogbnVsbCwgbWJbZ10gPSBmKSwgZVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgdmFyIG5iID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uKSQvaSxcclxuICAgICAgICBvYiA9IC9eKD86YXxhcmVhKSQvaTtcclxuICAgIHIuZm4uZXh0ZW5kKHtcclxuICAgICAgICBwcm9wOiBmdW5jdGlvbihhLCBiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBUKHRoaXMsIHIucHJvcCwgYSwgYiwgYXJndW1lbnRzLmxlbmd0aCA+IDEpXHJcbiAgICAgICAgfSxcclxuICAgICAgICByZW1vdmVQcm9wOiBmdW5jdGlvbihhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpc1tyLnByb3BGaXhbYV0gfHwgYV1cclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9XHJcbiAgICB9KSwgci5leHRlbmQoe1xyXG4gICAgICAgIHByb3A6IGZ1bmN0aW9uKGEsIGIsIGMpIHtcclxuICAgICAgICAgICAgdmFyIGQsIGUsIGYgPSBhLm5vZGVUeXBlO1xyXG4gICAgICAgICAgICBpZiAoMyAhPT0gZiAmJiA4ICE9PSBmICYmIDIgIT09IGYpIHJldHVybiAxID09PSBmICYmIHIuaXNYTUxEb2MoYSkgfHwgKGIgPSByLnByb3BGaXhbYl0gfHwgYiwgZSA9IHIucHJvcEhvb2tzW2JdKSwgdm9pZCAwICE9PSBjID8gZSAmJiBcInNldFwiIGluIGUgJiYgdm9pZCAwICE9PSAoZCA9IGUuc2V0KGEsIGMsIGIpKSA/IGQgOiBhW2JdID0gYyA6IGUgJiYgXCJnZXRcIiBpbiBlICYmIG51bGwgIT09IChkID0gZS5nZXQoYSwgYikpID8gZCA6IGFbYl1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHByb3BIb29rczoge1xyXG4gICAgICAgICAgICB0YWJJbmRleDoge1xyXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbihhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGIgPSByLmZpbmQuYXR0cihhLCBcInRhYmluZGV4XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBiID8gcGFyc2VJbnQoYiwgMTApIDogbmIudGVzdChhLm5vZGVOYW1lKSB8fCBvYi50ZXN0KGEubm9kZU5hbWUpICYmIGEuaHJlZiA/IDAgOiAtMVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBwcm9wRml4OiB7XHJcbiAgICAgICAgICAgIFwiZm9yXCI6IFwiaHRtbEZvclwiLFxyXG4gICAgICAgICAgICBcImNsYXNzXCI6IFwiY2xhc3NOYW1lXCJcclxuICAgICAgICB9XHJcbiAgICB9KSwgby5vcHRTZWxlY3RlZCB8fCAoci5wcm9wSG9va3Muc2VsZWN0ZWQgPSB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbihhKSB7XHJcbiAgICAgICAgICAgIHZhciBiID0gYS5wYXJlbnROb2RlO1xyXG4gICAgICAgICAgICByZXR1cm4gYiAmJiBiLnBhcmVudE5vZGUgJiYgYi5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXgsIG51bGxcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldDogZnVuY3Rpb24oYSkge1xyXG4gICAgICAgICAgICB2YXIgYiA9IGEucGFyZW50Tm9kZTtcclxuICAgICAgICAgICAgYiAmJiAoYi5zZWxlY3RlZEluZGV4LCBiLnBhcmVudE5vZGUgJiYgYi5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXgpXHJcbiAgICAgICAgfVxyXG4gICAgfSksIHIuZWFjaChbXCJ0YWJJbmRleFwiLCBcInJlYWRPbmx5XCIsIFwibWF4TGVuZ3RoXCIsIFwiY2VsbFNwYWNpbmdcIiwgXCJjZWxsUGFkZGluZ1wiLCBcInJvd1NwYW5cIiwgXCJjb2xTcGFuXCIsIFwidXNlTWFwXCIsIFwiZnJhbWVCb3JkZXJcIiwgXCJjb250ZW50RWRpdGFibGVcIl0sIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHIucHJvcEZpeFt0aGlzLnRvTG93ZXJDYXNlKCldID0gdGhpc1xyXG4gICAgfSk7XHJcblxyXG4gICAgZnVuY3Rpb24gcGIoYSkge1xyXG4gICAgICAgIHZhciBiID0gYS5tYXRjaChMKSB8fCBbXTtcclxuICAgICAgICByZXR1cm4gYi5qb2luKFwiIFwiKVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHFiKGEpIHtcclxuICAgICAgICByZXR1cm4gYS5nZXRBdHRyaWJ1dGUgJiYgYS5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKSB8fCBcIlwiXHJcbiAgICB9XHJcbiAgICByLmZuLmV4dGVuZCh7XHJcbiAgICAgICAgYWRkQ2xhc3M6IGZ1bmN0aW9uKGEpIHtcclxuICAgICAgICAgICAgdmFyIGIsIGMsIGQsIGUsIGYsIGcsIGgsIGkgPSAwO1xyXG4gICAgICAgICAgICBpZiAoci5pc0Z1bmN0aW9uKGEpKSByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKGIpIHtcclxuICAgICAgICAgICAgICAgIHIodGhpcykuYWRkQ2xhc3MoYS5jYWxsKHRoaXMsIGIsIHFiKHRoaXMpKSlcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmIChcInN0cmluZ1wiID09IHR5cGVvZiBhICYmIGEpIHtcclxuICAgICAgICAgICAgICAgIGIgPSBhLm1hdGNoKEwpIHx8IFtdO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGMgPSB0aGlzW2krK10pXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUgPSBxYihjKSwgZCA9IDEgPT09IGMubm9kZVR5cGUgJiYgXCIgXCIgKyBwYihlKSArIFwiIFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGcgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoZiA9IGJbZysrXSkgZC5pbmRleE9mKFwiIFwiICsgZiArIFwiIFwiKSA8IDAgJiYgKGQgKz0gZiArIFwiIFwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaCA9IHBiKGQpLCBlICE9PSBoICYmIGMuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgaClcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LFxyXG4gICAgICAgIHJlbW92ZUNsYXNzOiBmdW5jdGlvbihhKSB7XHJcbiAgICAgICAgICAgIHZhciBiLCBjLCBkLCBlLCBmLCBnLCBoLCBpID0gMDtcclxuICAgICAgICAgICAgaWYgKHIuaXNGdW5jdGlvbihhKSkgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbihiKSB7XHJcbiAgICAgICAgICAgICAgICByKHRoaXMpLnJlbW92ZUNsYXNzKGEuY2FsbCh0aGlzLCBiLCBxYih0aGlzKSkpXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLmF0dHIoXCJjbGFzc1wiLCBcIlwiKTtcclxuICAgICAgICAgICAgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIGEgJiYgYSkge1xyXG4gICAgICAgICAgICAgICAgYiA9IGEubWF0Y2goTCkgfHwgW107XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoYyA9IHRoaXNbaSsrXSlcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZSA9IHFiKGMpLCBkID0gMSA9PT0gYy5ub2RlVHlwZSAmJiBcIiBcIiArIHBiKGUpICsgXCIgXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZyA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChmID0gYltnKytdKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGQuaW5kZXhPZihcIiBcIiArIGYgKyBcIiBcIikgPiAtMSkgZCA9IGQucmVwbGFjZShcIiBcIiArIGYgKyBcIiBcIiwgXCIgXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoID0gcGIoZCksIGUgIT09IGggJiYgYy5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBoKVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdG9nZ2xlQ2xhc3M6IGZ1bmN0aW9uKGEsIGIpIHtcclxuICAgICAgICAgICAgdmFyIGMgPSB0eXBlb2YgYTtcclxuICAgICAgICAgICAgcmV0dXJuIFwiYm9vbGVhblwiID09IHR5cGVvZiBiICYmIFwic3RyaW5nXCIgPT09IGMgPyBiID8gdGhpcy5hZGRDbGFzcyhhKSA6IHRoaXMucmVtb3ZlQ2xhc3MoYSkgOiByLmlzRnVuY3Rpb24oYSkgPyB0aGlzLmVhY2goZnVuY3Rpb24oYykge1xyXG4gICAgICAgICAgICAgICAgcih0aGlzKS50b2dnbGVDbGFzcyhhLmNhbGwodGhpcywgYywgcWIodGhpcyksIGIpLCBiKVxyXG4gICAgICAgICAgICB9KSA6IHRoaXMuZWFjaChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHZhciBiLCBkLCBlLCBmO1xyXG4gICAgICAgICAgICAgICAgaWYgKFwic3RyaW5nXCIgPT09IGMpIHtcclxuICAgICAgICAgICAgICAgICAgICBkID0gMCwgZSA9IHIodGhpcyksIGYgPSBhLm1hdGNoKEwpIHx8IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChiID0gZltkKytdKSBlLmhhc0NsYXNzKGIpID8gZS5yZW1vdmVDbGFzcyhiKSA6IGUuYWRkQ2xhc3MoYilcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB2b2lkIDAgIT09IGEgJiYgXCJib29sZWFuXCIgIT09IGMgfHwgKGIgPSBxYih0aGlzKSwgYiAmJiBXLnNldCh0aGlzLCBcIl9fY2xhc3NOYW1lX19cIiwgYiksIHRoaXMuc2V0QXR0cmlidXRlICYmIHRoaXMuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgYiB8fCBhID09PSAhMSA/IFwiXCIgOiBXLmdldCh0aGlzLCBcIl9fY2xhc3NOYW1lX19cIikgfHwgXCJcIikpXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfSxcclxuICAgICAgICBoYXNDbGFzczogZnVuY3Rpb24oYSkge1xyXG4gICAgICAgICAgICB2YXIgYiwgYywgZCA9IDA7XHJcbiAgICAgICAgICAgIGIgPSBcIiBcIiArIGEgKyBcIiBcIjtcclxuICAgICAgICAgICAgd2hpbGUgKGMgPSB0aGlzW2QrK10pXHJcbiAgICAgICAgICAgICAgICBpZiAoMSA9PT0gYy5ub2RlVHlwZSAmJiAoXCIgXCIgKyBwYihxYihjKSkgKyBcIiBcIikuaW5kZXhPZihiKSA+IC0xKSByZXR1cm4gITA7XHJcbiAgICAgICAgICAgIHJldHVybiAhMVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgdmFyIHJiID0gL1xcci9nO1xyXG4gICAgci5mbi5leHRlbmQoe1xyXG4gICAgICAgIHZhbDogZnVuY3Rpb24oYSkge1xyXG4gICAgICAgICAgICB2YXIgYiwgYywgZCwgZSA9IHRoaXNbMF07IHtcclxuICAgICAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZCA9IHIuaXNGdW5jdGlvbihhKSwgdGhpcy5lYWNoKGZ1bmN0aW9uKGMpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZTtcclxuICAgICAgICAgICAgICAgICAgICAxID09PSB0aGlzLm5vZGVUeXBlICYmIChlID0gZCA/IGEuY2FsbCh0aGlzLCBjLCByKHRoaXMpLnZhbCgpKSA6IGEsIG51bGwgPT0gZSA/IGUgPSBcIlwiIDogXCJudW1iZXJcIiA9PSB0eXBlb2YgZSA/IGUgKz0gXCJcIiA6IEFycmF5LmlzQXJyYXkoZSkgJiYgKGUgPSByLm1hcChlLCBmdW5jdGlvbihhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsID09IGEgPyBcIlwiIDogYSArIFwiXCJcclxuICAgICAgICAgICAgICAgICAgICB9KSksIGIgPSByLnZhbEhvb2tzW3RoaXMudHlwZV0gfHwgci52YWxIb29rc1t0aGlzLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCldLCBiICYmIFwic2V0XCIgaW4gYiAmJiB2b2lkIDAgIT09IGIuc2V0KHRoaXMsIGUsIFwidmFsdWVcIikgfHwgKHRoaXMudmFsdWUgPSBlKSlcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKGUpIHJldHVybiBiID0gci52YWxIb29rc1tlLnR5cGVdIHx8IHIudmFsSG9va3NbZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpXSwgYiAmJiBcImdldFwiIGluIGIgJiYgdm9pZCAwICE9PSAoYyA9IGIuZ2V0KGUsIFwidmFsdWVcIikpID8gYyA6IChjID0gZS52YWx1ZSwgXCJzdHJpbmdcIiA9PSB0eXBlb2YgYyA/IGMucmVwbGFjZShyYiwgXCJcIikgOiBudWxsID09IGMgPyBcIlwiIDogYylcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pLCByLmV4dGVuZCh7XHJcbiAgICAgICAgdmFsSG9va3M6IHtcclxuICAgICAgICAgICAgb3B0aW9uOiB7XHJcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKGEpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYiA9IHIuZmluZC5hdHRyKGEsIFwidmFsdWVcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGwgIT0gYiA/IGIgOiBwYihyLnRleHQoYSkpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHNlbGVjdDoge1xyXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbihhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGIsIGMsIGQsIGUgPSBhLm9wdGlvbnMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGYgPSBhLnNlbGVjdGVkSW5kZXgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGcgPSBcInNlbGVjdC1vbmVcIiA9PT0gYS50eXBlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBoID0gZyA/IG51bGwgOiBbXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaSA9IGcgPyBmICsgMSA6IGUubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoZCA9IGYgPCAwID8gaSA6IGcgPyBmIDogMDsgZCA8IGk7IGQrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGMgPSBlW2RdLCAoYy5zZWxlY3RlZCB8fCBkID09PSBmKSAmJiAhYy5kaXNhYmxlZCAmJiAoIWMucGFyZW50Tm9kZS5kaXNhYmxlZCB8fCAhQihjLnBhcmVudE5vZGUsIFwib3B0Z3JvdXBcIikpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYiA9IHIoYykudmFsKCksIGcpIHJldHVybiBiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaC5wdXNoKGIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24oYSwgYikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjLCBkLCBlID0gYS5vcHRpb25zLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmID0gci5tYWtlQXJyYXkoYiksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGcgPSBlLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoZy0tKSBkID0gZVtnXSwgKGQuc2VsZWN0ZWQgPSByLmluQXJyYXkoci52YWxIb29rcy5vcHRpb24uZ2V0KGQpLCBmKSA+IC0xKSAmJiAoYyA9ICEwKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYyB8fCAoYS5zZWxlY3RlZEluZGV4ID0gLTEpLCBmXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KSwgci5lYWNoKFtcInJhZGlvXCIsIFwiY2hlY2tib3hcIl0sIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHIudmFsSG9va3NbdGhpc10gPSB7XHJcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24oYSwgYikge1xyXG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYikpIHJldHVybiBhLmNoZWNrZWQgPSByLmluQXJyYXkocihhKS52YWwoKSwgYikgPiAtMVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgby5jaGVja09uIHx8IChyLnZhbEhvb2tzW3RoaXNdLmdldCA9IGZ1bmN0aW9uKGEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGwgPT09IGEuZ2V0QXR0cmlidXRlKFwidmFsdWVcIikgPyBcIm9uXCIgOiBhLnZhbHVlXHJcbiAgICAgICAgfSlcclxuICAgIH0pO1xyXG4gICAgdmFyIHNiID0gL14oPzpmb2N1c2luZm9jdXN8Zm9jdXNvdXRibHVyKSQvO1xyXG4gICAgci5leHRlbmQoci5ldmVudCwge1xyXG4gICAgICAgIHRyaWdnZXI6IGZ1bmN0aW9uKGIsIGMsIGUsIGYpIHtcclxuICAgICAgICAgICAgdmFyIGcsIGgsIGksIGosIGssIG0sIG4sIG8gPSBbZSB8fCBkXSxcclxuICAgICAgICAgICAgICAgIHAgPSBsLmNhbGwoYiwgXCJ0eXBlXCIpID8gYi50eXBlIDogYixcclxuICAgICAgICAgICAgICAgIHEgPSBsLmNhbGwoYiwgXCJuYW1lc3BhY2VcIikgPyBiLm5hbWVzcGFjZS5zcGxpdChcIi5cIikgOiBbXTtcclxuICAgICAgICAgICAgaWYgKGggPSBpID0gZSA9IGUgfHwgZCwgMyAhPT0gZS5ub2RlVHlwZSAmJiA4ICE9PSBlLm5vZGVUeXBlICYmICFzYi50ZXN0KHAgKyByLmV2ZW50LnRyaWdnZXJlZCkgJiYgKHAuaW5kZXhPZihcIi5cIikgPiAtMSAmJiAocSA9IHAuc3BsaXQoXCIuXCIpLCBwID0gcS5zaGlmdCgpLCBxLnNvcnQoKSksIGsgPSBwLmluZGV4T2YoXCI6XCIpIDwgMCAmJiBcIm9uXCIgKyBwLCBiID0gYltyLmV4cGFuZG9dID8gYiA6IG5ldyByLkV2ZW50KHAsIFwib2JqZWN0XCIgPT0gdHlwZW9mIGIgJiYgYiksIGIuaXNUcmlnZ2VyID0gZiA/IDIgOiAzLCBiLm5hbWVzcGFjZSA9IHEuam9pbihcIi5cIiksIGIucm5hbWVzcGFjZSA9IGIubmFtZXNwYWNlID8gbmV3IFJlZ0V4cChcIihefFxcXFwuKVwiICsgcS5qb2luKFwiXFxcXC4oPzouKlxcXFwufClcIikgKyBcIihcXFxcLnwkKVwiKSA6IG51bGwsIGIucmVzdWx0ID0gdm9pZCAwLCBiLnRhcmdldCB8fCAoYi50YXJnZXQgPSBlKSwgYyA9IG51bGwgPT0gYyA/IFtiXSA6IHIubWFrZUFycmF5KGMsIFtiXSksIG4gPSByLmV2ZW50LnNwZWNpYWxbcF0gfHwge30sIGYgfHwgIW4udHJpZ2dlciB8fCBuLnRyaWdnZXIuYXBwbHkoZSwgYykgIT09ICExKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFmICYmICFuLm5vQnViYmxlICYmICFyLmlzV2luZG93KGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gbi5kZWxlZ2F0ZVR5cGUgfHwgcCwgc2IudGVzdChqICsgcCkgfHwgKGggPSBoLnBhcmVudE5vZGUpOyBoOyBoID0gaC5wYXJlbnROb2RlKSBvLnB1c2goaCksIGkgPSBoO1xyXG4gICAgICAgICAgICAgICAgICAgIGkgPT09IChlLm93bmVyRG9jdW1lbnQgfHwgZCkgJiYgby5wdXNoKGkuZGVmYXVsdFZpZXcgfHwgaS5wYXJlbnRXaW5kb3cgfHwgYSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGcgPSAwO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKChoID0gb1tnKytdKSAmJiAhYi5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKSBiLnR5cGUgPSBnID4gMSA/IGogOiBuLmJpbmRUeXBlIHx8IHAsIG0gPSAoVy5nZXQoaCwgXCJldmVudHNcIikgfHwge30pW2IudHlwZV0gJiYgVy5nZXQoaCwgXCJoYW5kbGVcIiksIG0gJiYgbS5hcHBseShoLCBjKSwgbSA9IGsgJiYgaFtrXSwgbSAmJiBtLmFwcGx5ICYmIFUoaCkgJiYgKGIucmVzdWx0ID0gbS5hcHBseShoLCBjKSwgYi5yZXN1bHQgPT09ICExICYmIGIucHJldmVudERlZmF1bHQoKSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYi50eXBlID0gcCwgZiB8fCBiLmlzRGVmYXVsdFByZXZlbnRlZCgpIHx8IG4uX2RlZmF1bHQgJiYgbi5fZGVmYXVsdC5hcHBseShvLnBvcCgpLCBjKSAhPT0gITEgfHwgIVUoZSkgfHwgayAmJiByLmlzRnVuY3Rpb24oZVtwXSkgJiYgIXIuaXNXaW5kb3coZSkgJiYgKGkgPSBlW2tdLCBpICYmIChlW2tdID0gbnVsbCksIHIuZXZlbnQudHJpZ2dlcmVkID0gcCwgZVtwXSgpLCByLmV2ZW50LnRyaWdnZXJlZCA9IHZvaWQgMCwgaSAmJiAoZVtrXSA9IGkpKSwgYi5yZXN1bHRcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2ltdWxhdGU6IGZ1bmN0aW9uKGEsIGIsIGMpIHtcclxuICAgICAgICAgICAgdmFyIGQgPSByLmV4dGVuZChuZXcgci5FdmVudCwgYywge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogYSxcclxuICAgICAgICAgICAgICAgIGlzU2ltdWxhdGVkOiAhMFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgci5ldmVudC50cmlnZ2VyKGQsIG51bGwsIGIpXHJcbiAgICAgICAgfVxyXG4gICAgfSksIHIuZm4uZXh0ZW5kKHtcclxuICAgICAgICB0cmlnZ2VyOiBmdW5jdGlvbihhLCBiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICByLmV2ZW50LnRyaWdnZXIoYSwgYiwgdGhpcylcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9LFxyXG4gICAgICAgIHRyaWdnZXJIYW5kbGVyOiBmdW5jdGlvbihhLCBiKSB7XHJcbiAgICAgICAgICAgIHZhciBjID0gdGhpc1swXTtcclxuICAgICAgICAgICAgaWYgKGMpIHJldHVybiByLmV2ZW50LnRyaWdnZXIoYSwgYiwgYywgITApXHJcbiAgICAgICAgfVxyXG4gICAgfSksIHIuZWFjaChcImJsdXIgZm9jdXMgZm9jdXNpbiBmb2N1c291dCByZXNpemUgc2Nyb2xsIGNsaWNrIGRibGNsaWNrIG1vdXNlZG93biBtb3VzZXVwIG1vdXNlbW92ZSBtb3VzZW92ZXIgbW91c2VvdXQgbW91c2VlbnRlciBtb3VzZWxlYXZlIGNoYW5nZSBzZWxlY3Qgc3VibWl0IGtleWRvd24ga2V5cHJlc3Mga2V5dXAgY29udGV4dG1lbnVcIi5zcGxpdChcIiBcIiksIGZ1bmN0aW9uKGEsIGIpIHtcclxuICAgICAgICByLmZuW2JdID0gZnVuY3Rpb24oYSwgYykge1xyXG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDAgPyB0aGlzLm9uKGIsIG51bGwsIGEsIGMpIDogdGhpcy50cmlnZ2VyKGIpXHJcbiAgICAgICAgfVxyXG4gICAgfSksIHIuZm4uZXh0ZW5kKHtcclxuICAgICAgICBob3ZlcjogZnVuY3Rpb24oYSwgYikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tb3VzZWVudGVyKGEpLm1vdXNlbGVhdmUoYiB8fCBhKVxyXG4gICAgICAgIH1cclxuICAgIH0pLCBvLmZvY3VzaW4gPSBcIm9uZm9jdXNpblwiIGluIGEsIG8uZm9jdXNpbiB8fCByLmVhY2goe1xyXG4gICAgICAgIGZvY3VzOiBcImZvY3VzaW5cIixcclxuICAgICAgICBibHVyOiBcImZvY3Vzb3V0XCJcclxuICAgIH0sIGZ1bmN0aW9uKGEsIGIpIHtcclxuICAgICAgICB2YXIgYyA9IGZ1bmN0aW9uKGEpIHtcclxuICAgICAgICAgICAgci5ldmVudC5zaW11bGF0ZShiLCBhLnRhcmdldCwgci5ldmVudC5maXgoYSkpXHJcbiAgICAgICAgfTtcclxuICAgICAgICByLmV2ZW50LnNwZWNpYWxbYl0gPSB7XHJcbiAgICAgICAgICAgIHNldHVwOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHZhciBkID0gdGhpcy5vd25lckRvY3VtZW50IHx8IHRoaXMsXHJcbiAgICAgICAgICAgICAgICAgICAgZSA9IFcuYWNjZXNzKGQsIGIpO1xyXG4gICAgICAgICAgICAgICAgZSB8fCBkLmFkZEV2ZW50TGlzdGVuZXIoYSwgYywgITApLCBXLmFjY2VzcyhkLCBiLCAoZSB8fCAwKSArIDEpXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHRlYXJkb3duOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHZhciBkID0gdGhpcy5vd25lckRvY3VtZW50IHx8IHRoaXMsXHJcbiAgICAgICAgICAgICAgICAgICAgZSA9IFcuYWNjZXNzKGQsIGIpIC0gMTtcclxuICAgICAgICAgICAgICAgIGUgPyBXLmFjY2VzcyhkLCBiLCBlKSA6IChkLnJlbW92ZUV2ZW50TGlzdGVuZXIoYSwgYywgITApLCBXLnJlbW92ZShkLCBiKSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgdmFyIHRiID0gYS5sb2NhdGlvbixcclxuICAgICAgICB1YiA9IHIubm93KCksXHJcbiAgICAgICAgdmIgPSAvXFw/LztcclxuICAgIHIucGFyc2VYTUwgPSBmdW5jdGlvbihiKSB7XHJcbiAgICAgICAgdmFyIGM7XHJcbiAgICAgICAgaWYgKCFiIHx8IFwic3RyaW5nXCIgIT0gdHlwZW9mIGIpIHJldHVybiBudWxsO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGMgPSAobmV3IGEuRE9NUGFyc2VyKS5wYXJzZUZyb21TdHJpbmcoYiwgXCJ0ZXh0L3htbFwiKVxyXG4gICAgICAgIH0gY2F0Y2ggKGQpIHtcclxuICAgICAgICAgICAgYyA9IHZvaWQgMFxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYyAmJiAhYy5nZXRFbGVtZW50c0J5VGFnTmFtZShcInBhcnNlcmVycm9yXCIpLmxlbmd0aCB8fCByLmVycm9yKFwiSW52YWxpZCBYTUw6IFwiICsgYiksIGNcclxuICAgIH07XHJcbiAgICB2YXIgd2IgPSAvXFxbXFxdJC8sXHJcbiAgICAgICAgeGIgPSAvXFxyP1xcbi9nLFxyXG4gICAgICAgIHliID0gL14oPzpzdWJtaXR8YnV0dG9ufGltYWdlfHJlc2V0fGZpbGUpJC9pLFxyXG4gICAgICAgIHpiID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8a2V5Z2VuKS9pO1xyXG5cclxuICAgIGZ1bmN0aW9uIEFiKGEsIGIsIGMsIGQpIHtcclxuICAgICAgICB2YXIgZTtcclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShiKSkgci5lYWNoKGIsIGZ1bmN0aW9uKGIsIGUpIHtcclxuICAgICAgICAgICAgYyB8fCB3Yi50ZXN0KGEpID8gZChhLCBlKSA6IEFiKGEgKyBcIltcIiArIChcIm9iamVjdFwiID09IHR5cGVvZiBlICYmIG51bGwgIT0gZSA/IGIgOiBcIlwiKSArIFwiXVwiLCBlLCBjLCBkKVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGVsc2UgaWYgKGMgfHwgXCJvYmplY3RcIiAhPT0gci50eXBlKGIpKSBkKGEsIGIpO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgZm9yIChlIGluIGIpIEFiKGEgKyBcIltcIiArIGUgKyBcIl1cIiwgYltlXSwgYywgZClcclxuICAgIH1cclxuICAgIHIucGFyYW0gPSBmdW5jdGlvbihhLCBiKSB7XHJcbiAgICAgICAgdmFyIGMsIGQgPSBbXSxcclxuICAgICAgICAgICAgZSA9IGZ1bmN0aW9uKGEsIGIpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjID0gci5pc0Z1bmN0aW9uKGIpID8gYigpIDogYjtcclxuICAgICAgICAgICAgICAgIGRbZC5sZW5ndGhdID0gZW5jb2RlVVJJQ29tcG9uZW50KGEpICsgXCI9XCIgKyBlbmNvZGVVUklDb21wb25lbnQobnVsbCA9PSBjID8gXCJcIiA6IGMpXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYSkgfHwgYS5qcXVlcnkgJiYgIXIuaXNQbGFpbk9iamVjdChhKSkgci5lYWNoKGEsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBlKHRoaXMubmFtZSwgdGhpcy52YWx1ZSlcclxuICAgICAgICB9KTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIGZvciAoYyBpbiBhKSBBYihjLCBhW2NdLCBiLCBlKTtcclxuICAgICAgICByZXR1cm4gZC5qb2luKFwiJlwiKVxyXG4gICAgfSwgci5mbi5leHRlbmQoe1xyXG4gICAgICAgIHNlcmlhbGl6ZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByLnBhcmFtKHRoaXMuc2VyaWFsaXplQXJyYXkoKSlcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNlcmlhbGl6ZUFycmF5OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGEgPSByLnByb3AodGhpcywgXCJlbGVtZW50c1wiKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhID8gci5tYWtlQXJyYXkoYSkgOiB0aGlzXHJcbiAgICAgICAgICAgIH0pLmZpbHRlcihmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHZhciBhID0gdGhpcy50eXBlO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubmFtZSAmJiAhcih0aGlzKS5pcyhcIjpkaXNhYmxlZFwiKSAmJiB6Yi50ZXN0KHRoaXMubm9kZU5hbWUpICYmICF5Yi50ZXN0KGEpICYmICh0aGlzLmNoZWNrZWQgfHwgIWphLnRlc3QoYSkpXHJcbiAgICAgICAgICAgIH0pLm1hcChmdW5jdGlvbihhLCBiKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYyA9IHIodGhpcykudmFsKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbCA9PSBjID8gbnVsbCA6IEFycmF5LmlzQXJyYXkoYykgPyByLm1hcChjLCBmdW5jdGlvbihhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogYi5uYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogYS5yZXBsYWNlKHhiLCBcIlxcclxcblwiKVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pIDoge1xyXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IGIubmFtZSxcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogYy5yZXBsYWNlKHhiLCBcIlxcclxcblwiKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KS5nZXQoKVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgdmFyIEJiID0gLyUyMC9nLFxyXG4gICAgICAgIENiID0gLyMuKiQvLFxyXG4gICAgICAgIERiID0gLyhbPyZdKV89W14mXSovLFxyXG4gICAgICAgIEViID0gL14oLio/KTpbIFxcdF0qKFteXFxyXFxuXSopJC9nbSxcclxuICAgICAgICBGYiA9IC9eKD86YWJvdXR8YXBwfGFwcC1zdG9yYWdlfC4rLWV4dGVuc2lvbnxmaWxlfHJlc3x3aWRnZXQpOiQvLFxyXG4gICAgICAgIEdiID0gL14oPzpHRVR8SEVBRCkkLyxcclxuICAgICAgICBIYiA9IC9eXFwvXFwvLyxcclxuICAgICAgICBJYiA9IHt9LFxyXG4gICAgICAgIEpiID0ge30sXHJcbiAgICAgICAgS2IgPSBcIiovXCIuY29uY2F0KFwiKlwiKSxcclxuICAgICAgICBMYiA9IGQuY3JlYXRlRWxlbWVudChcImFcIik7XHJcbiAgICBMYi5ocmVmID0gdGIuaHJlZjtcclxuXHJcbiAgICBmdW5jdGlvbiBNYihhKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGIsIGMpIHtcclxuICAgICAgICAgICAgXCJzdHJpbmdcIiAhPSB0eXBlb2YgYiAmJiAoYyA9IGIsIGIgPSBcIipcIik7XHJcbiAgICAgICAgICAgIHZhciBkLCBlID0gMCxcclxuICAgICAgICAgICAgICAgIGYgPSBiLnRvTG93ZXJDYXNlKCkubWF0Y2goTCkgfHwgW107XHJcbiAgICAgICAgICAgIGlmIChyLmlzRnVuY3Rpb24oYykpXHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoZCA9IGZbZSsrXSkgXCIrXCIgPT09IGRbMF0gPyAoZCA9IGQuc2xpY2UoMSkgfHwgXCIqXCIsIChhW2RdID0gYVtkXSB8fCBbXSkudW5zaGlmdChjKSkgOiAoYVtkXSA9IGFbZF0gfHwgW10pLnB1c2goYylcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gTmIoYSwgYiwgYywgZCkge1xyXG4gICAgICAgIHZhciBlID0ge30sXHJcbiAgICAgICAgICAgIGYgPSBhID09PSBKYjtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gZyhoKSB7XHJcbiAgICAgICAgICAgIHZhciBpO1xyXG4gICAgICAgICAgICByZXR1cm4gZVtoXSA9ICEwLCByLmVhY2goYVtoXSB8fCBbXSwgZnVuY3Rpb24oYSwgaCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGogPSBoKGIsIGMsIGQpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwic3RyaW5nXCIgIT0gdHlwZW9mIGogfHwgZiB8fCBlW2pdID8gZiA/ICEoaSA9IGopIDogdm9pZCAwIDogKGIuZGF0YVR5cGVzLnVuc2hpZnQoaiksIGcoaiksICExKVxyXG4gICAgICAgICAgICB9KSwgaVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZyhiLmRhdGFUeXBlc1swXSkgfHwgIWVbXCIqXCJdICYmIGcoXCIqXCIpXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gT2IoYSwgYikge1xyXG4gICAgICAgIHZhciBjLCBkLCBlID0gci5hamF4U2V0dGluZ3MuZmxhdE9wdGlvbnMgfHwge307XHJcbiAgICAgICAgZm9yIChjIGluIGIpIHZvaWQgMCAhPT0gYltjXSAmJiAoKGVbY10gPyBhIDogZCB8fCAoZCA9IHt9KSlbY10gPSBiW2NdKTtcclxuICAgICAgICByZXR1cm4gZCAmJiByLmV4dGVuZCghMCwgYSwgZCksIGFcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBQYihhLCBiLCBjKSB7XHJcbiAgICAgICAgdmFyIGQsIGUsIGYsIGcsIGggPSBhLmNvbnRlbnRzLFxyXG4gICAgICAgICAgICBpID0gYS5kYXRhVHlwZXM7XHJcbiAgICAgICAgd2hpbGUgKFwiKlwiID09PSBpWzBdKSBpLnNoaWZ0KCksIHZvaWQgMCA9PT0gZCAmJiAoZCA9IGEubWltZVR5cGUgfHwgYi5nZXRSZXNwb25zZUhlYWRlcihcIkNvbnRlbnQtVHlwZVwiKSk7XHJcbiAgICAgICAgaWYgKGQpXHJcbiAgICAgICAgICAgIGZvciAoZSBpbiBoKVxyXG4gICAgICAgICAgICAgICAgaWYgKGhbZV0gJiYgaFtlXS50ZXN0KGQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaS51bnNoaWZ0KGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlbMF0gaW4gYykgZiA9IGlbMF07XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGZvciAoZSBpbiBjKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlbMF0gfHwgYS5jb252ZXJ0ZXJzW2UgKyBcIiBcIiArIGlbMF1dKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZiA9IGU7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGcgfHwgKGcgPSBlKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGYgPSBmIHx8IGdcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGYpIHJldHVybiBmICE9PSBpWzBdICYmIGkudW5zaGlmdChmKSwgY1tmXVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIFFiKGEsIGIsIGMsIGQpIHtcclxuICAgICAgICB2YXIgZSwgZiwgZywgaCwgaSwgaiA9IHt9LFxyXG4gICAgICAgICAgICBrID0gYS5kYXRhVHlwZXMuc2xpY2UoKTtcclxuICAgICAgICBpZiAoa1sxXSlcclxuICAgICAgICAgICAgZm9yIChnIGluIGEuY29udmVydGVycykgaltnLnRvTG93ZXJDYXNlKCldID0gYS5jb252ZXJ0ZXJzW2ddO1xyXG4gICAgICAgIGYgPSBrLnNoaWZ0KCk7XHJcbiAgICAgICAgd2hpbGUgKGYpXHJcbiAgICAgICAgICAgIGlmIChhLnJlc3BvbnNlRmllbGRzW2ZdICYmIChjW2EucmVzcG9uc2VGaWVsZHNbZl1dID0gYiksICFpICYmIGQgJiYgYS5kYXRhRmlsdGVyICYmIChiID0gYS5kYXRhRmlsdGVyKGIsIGEuZGF0YVR5cGUpKSwgaSA9IGYsIGYgPSBrLnNoaWZ0KCkpXHJcbiAgICAgICAgICAgICAgICBpZiAoXCIqXCIgPT09IGYpIGYgPSBpO1xyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoXCIqXCIgIT09IGkgJiYgaSAhPT0gZikge1xyXG4gICAgICAgICAgICBpZiAoZyA9IGpbaSArIFwiIFwiICsgZl0gfHwgaltcIiogXCIgKyBmXSwgIWcpXHJcbiAgICAgICAgICAgICAgICBmb3IgKGUgaW4gailcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaCA9IGUuc3BsaXQoXCIgXCIpLCBoWzFdID09PSBmICYmIChnID0galtpICsgXCIgXCIgKyBoWzBdXSB8fCBqW1wiKiBcIiArIGhbMF1dKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBnID09PSAhMCA/IGcgPSBqW2VdIDogaltlXSAhPT0gITAgJiYgKGYgPSBoWzBdLCBrLnVuc2hpZnQoaFsxXSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVha1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGcgIT09ICEwKVxyXG4gICAgICAgICAgICAgICAgaWYgKGcgJiYgYVtcInRocm93c1wiXSkgYiA9IGcoYik7XHJcbiAgICAgICAgICAgICAgICBlbHNlIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYiA9IGcoYilcclxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGwpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZTogXCJwYXJzZXJlcnJvclwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZyA/IGwgOiBcIk5vIGNvbnZlcnNpb24gZnJvbSBcIiArIGkgKyBcIiB0byBcIiArIGZcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHN0YXRlOiBcInN1Y2Nlc3NcIixcclxuICAgICAgICAgICAgZGF0YTogYlxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHIuZXh0ZW5kKHtcclxuICAgICAgICBhY3RpdmU6IDAsXHJcbiAgICAgICAgbGFzdE1vZGlmaWVkOiB7fSxcclxuICAgICAgICBldGFnOiB7fSxcclxuICAgICAgICBhamF4U2V0dGluZ3M6IHtcclxuICAgICAgICAgICAgdXJsOiB0Yi5ocmVmLFxyXG4gICAgICAgICAgICB0eXBlOiBcIkdFVFwiLFxyXG4gICAgICAgICAgICBpc0xvY2FsOiBGYi50ZXN0KHRiLnByb3RvY29sKSxcclxuICAgICAgICAgICAgZ2xvYmFsOiAhMCxcclxuICAgICAgICAgICAgcHJvY2Vzc0RhdGE6ICEwLFxyXG4gICAgICAgICAgICBhc3luYzogITAsXHJcbiAgICAgICAgICAgIGNvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDsgY2hhcnNldD1VVEYtOFwiLFxyXG4gICAgICAgICAgICBhY2NlcHRzOiB7XHJcbiAgICAgICAgICAgICAgICBcIipcIjogS2IsXHJcbiAgICAgICAgICAgICAgICB0ZXh0OiBcInRleHQvcGxhaW5cIixcclxuICAgICAgICAgICAgICAgIGh0bWw6IFwidGV4dC9odG1sXCIsXHJcbiAgICAgICAgICAgICAgICB4bWw6IFwiYXBwbGljYXRpb24veG1sLCB0ZXh0L3htbFwiLFxyXG4gICAgICAgICAgICAgICAganNvbjogXCJhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L2phdmFzY3JpcHRcIlxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBjb250ZW50czoge1xyXG4gICAgICAgICAgICAgICAgeG1sOiAvXFxieG1sXFxiLyxcclxuICAgICAgICAgICAgICAgIGh0bWw6IC9cXGJodG1sLyxcclxuICAgICAgICAgICAgICAgIGpzb246IC9cXGJqc29uXFxiL1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICByZXNwb25zZUZpZWxkczoge1xyXG4gICAgICAgICAgICAgICAgeG1sOiBcInJlc3BvbnNlWE1MXCIsXHJcbiAgICAgICAgICAgICAgICB0ZXh0OiBcInJlc3BvbnNlVGV4dFwiLFxyXG4gICAgICAgICAgICAgICAganNvbjogXCJyZXNwb25zZUpTT05cIlxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBjb252ZXJ0ZXJzOiB7XHJcbiAgICAgICAgICAgICAgICBcIiogdGV4dFwiOiBTdHJpbmcsXHJcbiAgICAgICAgICAgICAgICBcInRleHQgaHRtbFwiOiAhMCxcclxuICAgICAgICAgICAgICAgIFwidGV4dCBqc29uXCI6IEpTT04ucGFyc2UsXHJcbiAgICAgICAgICAgICAgICBcInRleHQgeG1sXCI6IHIucGFyc2VYTUxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZmxhdE9wdGlvbnM6IHtcclxuICAgICAgICAgICAgICAgIHVybDogITAsXHJcbiAgICAgICAgICAgICAgICBjb250ZXh0OiAhMFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBhamF4U2V0dXA6IGZ1bmN0aW9uKGEsIGIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGIgPyBPYihPYihhLCByLmFqYXhTZXR0aW5ncyksIGIpIDogT2Ioci5hamF4U2V0dGluZ3MsIGEpXHJcbiAgICAgICAgfSxcclxuICAgICAgICBhamF4UHJlZmlsdGVyOiBNYihJYiksXHJcbiAgICAgICAgYWpheFRyYW5zcG9ydDogTWIoSmIpLFxyXG4gICAgICAgIGFqYXg6IGZ1bmN0aW9uKGIsIGMpIHtcclxuICAgICAgICAgICAgXCJvYmplY3RcIiA9PSB0eXBlb2YgYiAmJiAoYyA9IGIsIGIgPSB2b2lkIDApLCBjID0gYyB8fCB7fTtcclxuICAgICAgICAgICAgdmFyIGUsIGYsIGcsIGgsIGksIGosIGssIGwsIG0sIG4sIG8gPSByLmFqYXhTZXR1cCh7fSwgYyksXHJcbiAgICAgICAgICAgICAgICBwID0gby5jb250ZXh0IHx8IG8sXHJcbiAgICAgICAgICAgICAgICBxID0gby5jb250ZXh0ICYmIChwLm5vZGVUeXBlIHx8IHAuanF1ZXJ5KSA/IHIocCkgOiByLmV2ZW50LFxyXG4gICAgICAgICAgICAgICAgcyA9IHIuRGVmZXJyZWQoKSxcclxuICAgICAgICAgICAgICAgIHQgPSByLkNhbGxiYWNrcyhcIm9uY2UgbWVtb3J5XCIpLFxyXG4gICAgICAgICAgICAgICAgdSA9IG8uc3RhdHVzQ29kZSB8fCB7fSxcclxuICAgICAgICAgICAgICAgIHYgPSB7fSxcclxuICAgICAgICAgICAgICAgIHcgPSB7fSxcclxuICAgICAgICAgICAgICAgIHggPSBcImNhbmNlbGVkXCIsXHJcbiAgICAgICAgICAgICAgICB5ID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlYWR5U3RhdGU6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgZ2V0UmVzcG9uc2VIZWFkZXI6IGZ1bmN0aW9uKGEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGIgPSBFYi5leGVjKGcpKSBoW2JbMV0udG9Mb3dlckNhc2UoKV0gPSBiWzJdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiID0gaFthLnRvTG93ZXJDYXNlKCldXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGwgPT0gYiA/IG51bGwgOiBiXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBnZXRBbGxSZXNwb25zZUhlYWRlcnM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gayA/IGcgOiBudWxsXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBzZXRSZXF1ZXN0SGVhZGVyOiBmdW5jdGlvbihhLCBiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsID09IGsgJiYgKGEgPSB3W2EudG9Mb3dlckNhc2UoKV0gPSB3W2EudG9Mb3dlckNhc2UoKV0gfHwgYSwgdlthXSA9IGIpLCB0aGlzXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBvdmVycmlkZU1pbWVUeXBlOiBmdW5jdGlvbihhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsID09IGsgJiYgKG8ubWltZVR5cGUgPSBhKSwgdGhpc1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzQ29kZTogZnVuY3Rpb24oYSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaykgeS5hbHdheXMoYVt5LnN0YXR1c10pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoYiBpbiBhKSB1W2JdID0gW3VbYl0sIGFbYl1dO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgYWJvcnQ6IGZ1bmN0aW9uKGEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGIgPSBhIHx8IHg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlICYmIGUuYWJvcnQoYiksIEEoMCwgYiksIHRoaXNcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBpZiAocy5wcm9taXNlKHkpLCBvLnVybCA9ICgoYiB8fCBvLnVybCB8fCB0Yi5ocmVmKSArIFwiXCIpLnJlcGxhY2UoSGIsIHRiLnByb3RvY29sICsgXCIvL1wiKSwgby50eXBlID0gYy5tZXRob2QgfHwgYy50eXBlIHx8IG8ubWV0aG9kIHx8IG8udHlwZSwgby5kYXRhVHlwZXMgPSAoby5kYXRhVHlwZSB8fCBcIipcIikudG9Mb3dlckNhc2UoKS5tYXRjaChMKSB8fCBbXCJcIl0sIG51bGwgPT0gby5jcm9zc0RvbWFpbikge1xyXG4gICAgICAgICAgICAgICAgaiA9IGQuY3JlYXRlRWxlbWVudChcImFcIik7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGouaHJlZiA9IG8udXJsLCBqLmhyZWYgPSBqLmhyZWYsIG8uY3Jvc3NEb21haW4gPSBMYi5wcm90b2NvbCArIFwiLy9cIiArIExiLmhvc3QgIT0gai5wcm90b2NvbCArIFwiLy9cIiArIGouaG9zdFxyXG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoeikge1xyXG4gICAgICAgICAgICAgICAgICAgIG8uY3Jvc3NEb21haW4gPSAhMFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChvLmRhdGEgJiYgby5wcm9jZXNzRGF0YSAmJiBcInN0cmluZ1wiICE9IHR5cGVvZiBvLmRhdGEgJiYgKG8uZGF0YSA9IHIucGFyYW0oby5kYXRhLCBvLnRyYWRpdGlvbmFsKSksIE5iKEliLCBvLCBjLCB5KSwgaykgcmV0dXJuIHk7XHJcbiAgICAgICAgICAgIGwgPSByLmV2ZW50ICYmIG8uZ2xvYmFsLCBsICYmIDAgPT09IHIuYWN0aXZlKysgJiYgci5ldmVudC50cmlnZ2VyKFwiYWpheFN0YXJ0XCIpLCBvLnR5cGUgPSBvLnR5cGUudG9VcHBlckNhc2UoKSwgby5oYXNDb250ZW50ID0gIUdiLnRlc3Qoby50eXBlKSwgZiA9IG8udXJsLnJlcGxhY2UoQ2IsIFwiXCIpLCBvLmhhc0NvbnRlbnQgPyBvLmRhdGEgJiYgby5wcm9jZXNzRGF0YSAmJiAwID09PSAoby5jb250ZW50VHlwZSB8fCBcIlwiKS5pbmRleE9mKFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIpICYmIChvLmRhdGEgPSBvLmRhdGEucmVwbGFjZShCYiwgXCIrXCIpKSA6IChuID0gby51cmwuc2xpY2UoZi5sZW5ndGgpLCBvLmRhdGEgJiYgKGYgKz0gKHZiLnRlc3QoZikgPyBcIiZcIiA6IFwiP1wiKSArIG8uZGF0YSwgZGVsZXRlIG8uZGF0YSksIG8uY2FjaGUgPT09ICExICYmIChmID0gZi5yZXBsYWNlKERiLCBcIiQxXCIpLCBuID0gKHZiLnRlc3QoZikgPyBcIiZcIiA6IFwiP1wiKSArIFwiXz1cIiArIHViKysgKyBuKSwgby51cmwgPSBmICsgbiksIG8uaWZNb2RpZmllZCAmJiAoci5sYXN0TW9kaWZpZWRbZl0gJiYgeS5zZXRSZXF1ZXN0SGVhZGVyKFwiSWYtTW9kaWZpZWQtU2luY2VcIiwgci5sYXN0TW9kaWZpZWRbZl0pLCByLmV0YWdbZl0gJiYgeS5zZXRSZXF1ZXN0SGVhZGVyKFwiSWYtTm9uZS1NYXRjaFwiLCByLmV0YWdbZl0pKSwgKG8uZGF0YSAmJiBvLmhhc0NvbnRlbnQgJiYgby5jb250ZW50VHlwZSAhPT0gITEgfHwgYy5jb250ZW50VHlwZSkgJiYgeS5zZXRSZXF1ZXN0SGVhZGVyKFwiQ29udGVudC1UeXBlXCIsIG8uY29udGVudFR5cGUpLCB5LnNldFJlcXVlc3RIZWFkZXIoXCJBY2NlcHRcIiwgby5kYXRhVHlwZXNbMF0gJiYgby5hY2NlcHRzW28uZGF0YVR5cGVzWzBdXSA/IG8uYWNjZXB0c1tvLmRhdGFUeXBlc1swXV0gKyAoXCIqXCIgIT09IG8uZGF0YVR5cGVzWzBdID8gXCIsIFwiICsgS2IgKyBcIjsgcT0wLjAxXCIgOiBcIlwiKSA6IG8uYWNjZXB0c1tcIipcIl0pO1xyXG4gICAgICAgICAgICBmb3IgKG0gaW4gby5oZWFkZXJzKSB5LnNldFJlcXVlc3RIZWFkZXIobSwgby5oZWFkZXJzW21dKTtcclxuICAgICAgICAgICAgaWYgKG8uYmVmb3JlU2VuZCAmJiAoby5iZWZvcmVTZW5kLmNhbGwocCwgeSwgbykgPT09ICExIHx8IGspKSByZXR1cm4geS5hYm9ydCgpO1xyXG4gICAgICAgICAgICBpZiAoeCA9IFwiYWJvcnRcIiwgdC5hZGQoby5jb21wbGV0ZSksIHkuZG9uZShvLnN1Y2Nlc3MpLCB5LmZhaWwoby5lcnJvciksIGUgPSBOYihKYiwgbywgYywgeSkpIHtcclxuICAgICAgICAgICAgICAgIGlmICh5LnJlYWR5U3RhdGUgPSAxLCBsICYmIHEudHJpZ2dlcihcImFqYXhTZW5kXCIsIFt5LCBvXSksIGspIHJldHVybiB5O1xyXG4gICAgICAgICAgICAgICAgby5hc3luYyAmJiBvLnRpbWVvdXQgPiAwICYmIChpID0gYS5zZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHkuYWJvcnQoXCJ0aW1lb3V0XCIpXHJcbiAgICAgICAgICAgICAgICB9LCBvLnRpbWVvdXQpKTtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgayA9ICExLCBlLnNlbmQodiwgQSlcclxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKHopIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaykgdGhyb3cgejtcclxuICAgICAgICAgICAgICAgICAgICBBKC0xLCB6KVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2UgQSgtMSwgXCJObyBUcmFuc3BvcnRcIik7XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBBKGIsIGMsIGQsIGgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBqLCBtLCBuLCB2LCB3LCB4ID0gYztcclxuICAgICAgICAgICAgICAgIGsgfHwgKGsgPSAhMCwgaSAmJiBhLmNsZWFyVGltZW91dChpKSwgZSA9IHZvaWQgMCwgZyA9IGggfHwgXCJcIiwgeS5yZWFkeVN0YXRlID0gYiA+IDAgPyA0IDogMCwgaiA9IGIgPj0gMjAwICYmIGIgPCAzMDAgfHwgMzA0ID09PSBiLCBkICYmICh2ID0gUGIobywgeSwgZCkpLCB2ID0gUWIobywgdiwgeSwgaiksIGogPyAoby5pZk1vZGlmaWVkICYmICh3ID0geS5nZXRSZXNwb25zZUhlYWRlcihcIkxhc3QtTW9kaWZpZWRcIiksIHcgJiYgKHIubGFzdE1vZGlmaWVkW2ZdID0gdyksIHcgPSB5LmdldFJlc3BvbnNlSGVhZGVyKFwiZXRhZ1wiKSwgdyAmJiAoci5ldGFnW2ZdID0gdykpLCAyMDQgPT09IGIgfHwgXCJIRUFEXCIgPT09IG8udHlwZSA/IHggPSBcIm5vY29udGVudFwiIDogMzA0ID09PSBiID8geCA9IFwibm90bW9kaWZpZWRcIiA6ICh4ID0gdi5zdGF0ZSwgbSA9IHYuZGF0YSwgbiA9IHYuZXJyb3IsIGogPSAhbikpIDogKG4gPSB4LCAhYiAmJiB4IHx8ICh4ID0gXCJlcnJvclwiLCBiIDwgMCAmJiAoYiA9IDApKSksIHkuc3RhdHVzID0gYiwgeS5zdGF0dXNUZXh0ID0gKGMgfHwgeCkgKyBcIlwiLCBqID8gcy5yZXNvbHZlV2l0aChwLCBbbSwgeCwgeV0pIDogcy5yZWplY3RXaXRoKHAsIFt5LCB4LCBuXSksIHkuc3RhdHVzQ29kZSh1KSwgdSA9IHZvaWQgMCwgbCAmJiBxLnRyaWdnZXIoaiA/IFwiYWpheFN1Y2Nlc3NcIiA6IFwiYWpheEVycm9yXCIsIFt5LCBvLCBqID8gbSA6IG5dKSwgdC5maXJlV2l0aChwLCBbeSwgeF0pLCBsICYmIChxLnRyaWdnZXIoXCJhamF4Q29tcGxldGVcIiwgW3ksIG9dKSwgLS1yLmFjdGl2ZSB8fCByLmV2ZW50LnRyaWdnZXIoXCJhamF4U3RvcFwiKSkpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHlcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldEpTT046IGZ1bmN0aW9uKGEsIGIsIGMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHIuZ2V0KGEsIGIsIGMsIFwianNvblwiKVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0U2NyaXB0OiBmdW5jdGlvbihhLCBiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByLmdldChhLCB2b2lkIDAsIGIsIFwic2NyaXB0XCIpXHJcbiAgICAgICAgfVxyXG4gICAgfSksIHIuZWFjaChbXCJnZXRcIiwgXCJwb3N0XCJdLCBmdW5jdGlvbihhLCBiKSB7XHJcbiAgICAgICAgcltiXSA9IGZ1bmN0aW9uKGEsIGMsIGQsIGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHIuaXNGdW5jdGlvbihjKSAmJiAoZSA9IGUgfHwgZCwgZCA9IGMsIGMgPSB2b2lkIDApLCByLmFqYXgoci5leHRlbmQoe1xyXG4gICAgICAgICAgICAgICAgdXJsOiBhLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogYixcclxuICAgICAgICAgICAgICAgIGRhdGFUeXBlOiBlLFxyXG4gICAgICAgICAgICAgICAgZGF0YTogYyxcclxuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGRcclxuICAgICAgICAgICAgfSwgci5pc1BsYWluT2JqZWN0KGEpICYmIGEpKVxyXG4gICAgICAgIH1cclxuICAgIH0pLCByLl9ldmFsVXJsID0gZnVuY3Rpb24oYSkge1xyXG4gICAgICAgIHJldHVybiByLmFqYXgoe1xyXG4gICAgICAgICAgICB1cmw6IGEsXHJcbiAgICAgICAgICAgIHR5cGU6IFwiR0VUXCIsXHJcbiAgICAgICAgICAgIGRhdGFUeXBlOiBcInNjcmlwdFwiLFxyXG4gICAgICAgICAgICBjYWNoZTogITAsXHJcbiAgICAgICAgICAgIGFzeW5jOiAhMSxcclxuICAgICAgICAgICAgZ2xvYmFsOiAhMSxcclxuICAgICAgICAgICAgXCJ0aHJvd3NcIjogITBcclxuICAgICAgICB9KVxyXG4gICAgfSwgci5mbi5leHRlbmQoe1xyXG4gICAgICAgIHdyYXBBbGw6IGZ1bmN0aW9uKGEpIHtcclxuICAgICAgICAgICAgdmFyIGI7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzWzBdICYmIChyLmlzRnVuY3Rpb24oYSkgJiYgKGEgPSBhLmNhbGwodGhpc1swXSkpLCBiID0gcihhLCB0aGlzWzBdLm93bmVyRG9jdW1lbnQpLmVxKDApLmNsb25lKCEwKSwgdGhpc1swXS5wYXJlbnROb2RlICYmIGIuaW5zZXJ0QmVmb3JlKHRoaXNbMF0pLCBiLm1hcChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHZhciBhID0gdGhpcztcclxuICAgICAgICAgICAgICAgIHdoaWxlIChhLmZpcnN0RWxlbWVudENoaWxkKSBhID0gYS5maXJzdEVsZW1lbnRDaGlsZDtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhXHJcbiAgICAgICAgICAgIH0pLmFwcGVuZCh0aGlzKSksIHRoaXNcclxuICAgICAgICB9LFxyXG4gICAgICAgIHdyYXBJbm5lcjogZnVuY3Rpb24oYSkge1xyXG4gICAgICAgICAgICByZXR1cm4gci5pc0Z1bmN0aW9uKGEpID8gdGhpcy5lYWNoKGZ1bmN0aW9uKGIpIHtcclxuICAgICAgICAgICAgICAgIHIodGhpcykud3JhcElubmVyKGEuY2FsbCh0aGlzLCBiKSlcclxuICAgICAgICAgICAgfSkgOiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYiA9IHIodGhpcyksXHJcbiAgICAgICAgICAgICAgICAgICAgYyA9IGIuY29udGVudHMoKTtcclxuICAgICAgICAgICAgICAgIGMubGVuZ3RoID8gYy53cmFwQWxsKGEpIDogYi5hcHBlbmQoYSlcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9LFxyXG4gICAgICAgIHdyYXA6IGZ1bmN0aW9uKGEpIHtcclxuICAgICAgICAgICAgdmFyIGIgPSByLmlzRnVuY3Rpb24oYSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oYykge1xyXG4gICAgICAgICAgICAgICAgcih0aGlzKS53cmFwQWxsKGIgPyBhLmNhbGwodGhpcywgYykgOiBhKVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdW53cmFwOiBmdW5jdGlvbihhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudChhKS5ub3QoXCJib2R5XCIpLmVhY2goZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICByKHRoaXMpLnJlcGxhY2VXaXRoKHRoaXMuY2hpbGROb2RlcylcclxuICAgICAgICAgICAgfSksIHRoaXNcclxuICAgICAgICB9XHJcbiAgICB9KSwgci5leHByLnBzZXVkb3MuaGlkZGVuID0gZnVuY3Rpb24oYSkge1xyXG4gICAgICAgIHJldHVybiAhci5leHByLnBzZXVkb3MudmlzaWJsZShhKVxyXG4gICAgfSwgci5leHByLnBzZXVkb3MudmlzaWJsZSA9IGZ1bmN0aW9uKGEpIHtcclxuICAgICAgICByZXR1cm4gISEoYS5vZmZzZXRXaWR0aCB8fCBhLm9mZnNldEhlaWdodCB8fCBhLmdldENsaWVudFJlY3RzKCkubGVuZ3RoKVxyXG4gICAgfSwgci5hamF4U2V0dGluZ3MueGhyID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBhLlhNTEh0dHBSZXF1ZXN0XHJcbiAgICAgICAgfSBjYXRjaCAoYikge31cclxuICAgIH07XHJcbiAgICB2YXIgUmIgPSB7XHJcbiAgICAgICAgICAgIDA6IDIwMCxcclxuICAgICAgICAgICAgMTIyMzogMjA0XHJcbiAgICAgICAgfSxcclxuICAgICAgICBTYiA9IHIuYWpheFNldHRpbmdzLnhocigpO1xyXG4gICAgby5jb3JzID0gISFTYiAmJiBcIndpdGhDcmVkZW50aWFsc1wiIGluIFNiLCBvLmFqYXggPSBTYiA9ICEhU2IsIHIuYWpheFRyYW5zcG9ydChmdW5jdGlvbihiKSB7XHJcbiAgICAgICAgdmFyIGMsIGQ7XHJcbiAgICAgICAgaWYgKG8uY29ycyB8fCBTYiAmJiAhYi5jcm9zc0RvbWFpbikgcmV0dXJuIHtcclxuICAgICAgICAgICAgc2VuZDogZnVuY3Rpb24oZSwgZikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGcsIGggPSBiLnhocigpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGgub3BlbihiLnR5cGUsIGIudXJsLCBiLmFzeW5jLCBiLnVzZXJuYW1lLCBiLnBhc3N3b3JkKSwgYi54aHJGaWVsZHMpXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChnIGluIGIueGhyRmllbGRzKSBoW2ddID0gYi54aHJGaWVsZHNbZ107XHJcbiAgICAgICAgICAgICAgICBiLm1pbWVUeXBlICYmIGgub3ZlcnJpZGVNaW1lVHlwZSAmJiBoLm92ZXJyaWRlTWltZVR5cGUoYi5taW1lVHlwZSksIGIuY3Jvc3NEb21haW4gfHwgZVtcIlgtUmVxdWVzdGVkLVdpdGhcIl0gfHwgKGVbXCJYLVJlcXVlc3RlZC1XaXRoXCJdID0gXCJYTUxIdHRwUmVxdWVzdFwiKTtcclxuICAgICAgICAgICAgICAgIGZvciAoZyBpbiBlKSBoLnNldFJlcXVlc3RIZWFkZXIoZywgZVtnXSk7XHJcbiAgICAgICAgICAgICAgICBjID0gZnVuY3Rpb24oYSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYyAmJiAoYyA9IGQgPSBoLm9ubG9hZCA9IGgub25lcnJvciA9IGgub25hYm9ydCA9IGgub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbCwgXCJhYm9ydFwiID09PSBhID8gaC5hYm9ydCgpIDogXCJlcnJvclwiID09PSBhID8gXCJudW1iZXJcIiAhPSB0eXBlb2YgaC5zdGF0dXMgPyBmKDAsIFwiZXJyb3JcIikgOiBmKGguc3RhdHVzLCBoLnN0YXR1c1RleHQpIDogZihSYltoLnN0YXR1c10gfHwgaC5zdGF0dXMsIGguc3RhdHVzVGV4dCwgXCJ0ZXh0XCIgIT09IChoLnJlc3BvbnNlVHlwZSB8fCBcInRleHRcIikgfHwgXCJzdHJpbmdcIiAhPSB0eXBlb2YgaC5yZXNwb25zZVRleHQgPyB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaW5hcnk6IGgucmVzcG9uc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSA6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IGgucmVzcG9uc2VUZXh0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGguZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpKVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sIGgub25sb2FkID0gYygpLCBkID0gaC5vbmVycm9yID0gYyhcImVycm9yXCIpLCB2b2lkIDAgIT09IGgub25hYm9ydCA/IGgub25hYm9ydCA9IGQgOiBoLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIDQgPT09IGgucmVhZHlTdGF0ZSAmJiBhLnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGMgJiYgZCgpXHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIH0sIGMgPSBjKFwiYWJvcnRcIik7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGguc2VuZChiLmhhc0NvbnRlbnQgJiYgYi5kYXRhIHx8IG51bGwpXHJcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMpIHRocm93IGlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgYWJvcnQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgYyAmJiBjKClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pLCByLmFqYXhQcmVmaWx0ZXIoZnVuY3Rpb24oYSkge1xyXG4gICAgICAgIGEuY3Jvc3NEb21haW4gJiYgKGEuY29udGVudHMuc2NyaXB0ID0gITEpXHJcbiAgICB9KSwgci5hamF4U2V0dXAoe1xyXG4gICAgICAgIGFjY2VwdHM6IHtcclxuICAgICAgICAgICAgc2NyaXB0OiBcInRleHQvamF2YXNjcmlwdCwgYXBwbGljYXRpb24vamF2YXNjcmlwdCwgYXBwbGljYXRpb24vZWNtYXNjcmlwdCwgYXBwbGljYXRpb24veC1lY21hc2NyaXB0XCJcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNvbnRlbnRzOiB7XHJcbiAgICAgICAgICAgIHNjcmlwdDogL1xcYig/OmphdmF8ZWNtYSlzY3JpcHRcXGIvXHJcbiAgICAgICAgfSxcclxuICAgICAgICBjb252ZXJ0ZXJzOiB7XHJcbiAgICAgICAgICAgIFwidGV4dCBzY3JpcHRcIjogZnVuY3Rpb24oYSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHIuZ2xvYmFsRXZhbChhKSwgYVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSksIHIuYWpheFByZWZpbHRlcihcInNjcmlwdFwiLCBmdW5jdGlvbihhKSB7XHJcbiAgICAgICAgdm9pZCAwID09PSBhLmNhY2hlICYmIChhLmNhY2hlID0gITEpLCBhLmNyb3NzRG9tYWluICYmIChhLnR5cGUgPSBcIkdFVFwiKVxyXG4gICAgfSksIHIuYWpheFRyYW5zcG9ydChcInNjcmlwdFwiLCBmdW5jdGlvbihhKSB7XHJcbiAgICAgICAgaWYgKGEuY3Jvc3NEb21haW4pIHtcclxuICAgICAgICAgICAgdmFyIGIsIGM7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBzZW5kOiBmdW5jdGlvbihlLCBmKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYiA9IHIoXCI8c2NyaXB0PlwiKS5wcm9wKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhcnNldDogYS5zY3JpcHRDaGFyc2V0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzcmM6IGEudXJsXHJcbiAgICAgICAgICAgICAgICAgICAgfSkub24oXCJsb2FkIGVycm9yXCIsIGMgPSBmdW5jdGlvbihhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGIucmVtb3ZlKCksIGMgPSBudWxsLCBhICYmIGYoXCJlcnJvclwiID09PSBhLnR5cGUgPyA0MDQgOiAyMDAsIGEudHlwZSlcclxuICAgICAgICAgICAgICAgICAgICB9KSwgZC5oZWFkLmFwcGVuZENoaWxkKGJbMF0pXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgYWJvcnQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGMgJiYgYygpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHZhciBUYiA9IFtdLFxyXG4gICAgICAgIFViID0gLyg9KVxcPyg/PSZ8JCl8XFw/XFw/LztcclxuICAgIHIuYWpheFNldHVwKHtcclxuICAgICAgICBqc29ucDogXCJjYWxsYmFja1wiLFxyXG4gICAgICAgIGpzb25wQ2FsbGJhY2s6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgYSA9IFRiLnBvcCgpIHx8IHIuZXhwYW5kbyArIFwiX1wiICsgdWIrKztcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNbYV0gPSAhMCwgYVxyXG4gICAgICAgIH1cclxuICAgIH0pLCByLmFqYXhQcmVmaWx0ZXIoXCJqc29uIGpzb25wXCIsIGZ1bmN0aW9uKGIsIGMsIGQpIHtcclxuICAgICAgICB2YXIgZSwgZiwgZywgaCA9IGIuanNvbnAgIT09ICExICYmIChVYi50ZXN0KGIudXJsKSA/IFwidXJsXCIgOiBcInN0cmluZ1wiID09IHR5cGVvZiBiLmRhdGEgJiYgMCA9PT0gKGIuY29udGVudFR5cGUgfHwgXCJcIikuaW5kZXhPZihcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiKSAmJiBVYi50ZXN0KGIuZGF0YSkgJiYgXCJkYXRhXCIpO1xyXG4gICAgICAgIGlmIChoIHx8IFwianNvbnBcIiA9PT0gYi5kYXRhVHlwZXNbMF0pIHJldHVybiBlID0gYi5qc29ucENhbGxiYWNrID0gci5pc0Z1bmN0aW9uKGIuanNvbnBDYWxsYmFjaykgPyBiLmpzb25wQ2FsbGJhY2soKSA6IGIuanNvbnBDYWxsYmFjaywgaCA/IGJbaF0gPSBiW2hdLnJlcGxhY2UoVWIsIFwiJDFcIiArIGUpIDogYi5qc29ucCAhPT0gITEgJiYgKGIudXJsICs9ICh2Yi50ZXN0KGIudXJsKSA/IFwiJlwiIDogXCI/XCIpICsgYi5qc29ucCArIFwiPVwiICsgZSksIGIuY29udmVydGVyc1tcInNjcmlwdCBqc29uXCJdID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBnIHx8IHIuZXJyb3IoZSArIFwiIHdhcyBub3QgY2FsbGVkXCIpLCBnWzBdXHJcbiAgICAgICAgfSwgYi5kYXRhVHlwZXNbMF0gPSBcImpzb25cIiwgZiA9IGFbZV0sIGFbZV0gPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgZyA9IGFyZ3VtZW50c1xyXG4gICAgICAgIH0sIGQuYWx3YXlzKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2b2lkIDAgPT09IGYgPyByKGEpLnJlbW92ZVByb3AoZSkgOiBhW2VdID0gZiwgYltlXSAmJiAoYi5qc29ucENhbGxiYWNrID0gYy5qc29ucENhbGxiYWNrLCBUYi5wdXNoKGUpKSwgZyAmJiByLmlzRnVuY3Rpb24oZikgJiYgZihnWzBdKSwgZyA9IGYgPSB2b2lkIDBcclxuICAgICAgICB9KSwgXCJzY3JpcHRcIlxyXG4gICAgfSksIG8uY3JlYXRlSFRNTERvY3VtZW50ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIGEgPSBkLmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudChcIlwiKS5ib2R5O1xyXG4gICAgICAgIHJldHVybiBhLmlubmVySFRNTCA9IFwiPGZvcm0+PC9mb3JtPjxmb3JtPjwvZm9ybT5cIiwgMiA9PT0gYS5jaGlsZE5vZGVzLmxlbmd0aFxyXG4gICAgfSgpLCByLnBhcnNlSFRNTCA9IGZ1bmN0aW9uKGEsIGIsIGMpIHtcclxuICAgICAgICBpZiAoXCJzdHJpbmdcIiAhPSB0eXBlb2YgYSkgcmV0dXJuIFtdO1xyXG4gICAgICAgIFwiYm9vbGVhblwiID09IHR5cGVvZiBiICYmIChjID0gYiwgYiA9ICExKTtcclxuICAgICAgICB2YXIgZSwgZiwgZztcclxuICAgICAgICByZXR1cm4gYiB8fCAoby5jcmVhdGVIVE1MRG9jdW1lbnQgPyAoYiA9IGQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KFwiXCIpLCBlID0gYi5jcmVhdGVFbGVtZW50KFwiYmFzZVwiKSwgZS5ocmVmID0gZC5sb2NhdGlvbi5ocmVmLCBiLmhlYWQuYXBwZW5kQ2hpbGQoZSkpIDogYiA9IGQpLCBmID0gQy5leGVjKGEpLCBnID0gIWMgJiYgW10sIGYgPyBbYi5jcmVhdGVFbGVtZW50KGZbMV0pXSA6IChmID0gcWEoW2FdLCBiLCBnKSwgZyAmJiBnLmxlbmd0aCAmJiByKGcpLnJlbW92ZSgpLCByLm1lcmdlKFtdLCBmLmNoaWxkTm9kZXMpKVxyXG4gICAgfSwgci5mbi5sb2FkID0gZnVuY3Rpb24oYSwgYiwgYykge1xyXG4gICAgICAgIHZhciBkLCBlLCBmLCBnID0gdGhpcyxcclxuICAgICAgICAgICAgaCA9IGEuaW5kZXhPZihcIiBcIik7XHJcbiAgICAgICAgcmV0dXJuIGggPiAtMSAmJiAoZCA9IHBiKGEuc2xpY2UoaCkpLCBhID0gYS5zbGljZSgwLCBoKSksIHIuaXNGdW5jdGlvbihiKSA/IChjID0gYiwgYiA9IHZvaWQgMCkgOiBiICYmIFwib2JqZWN0XCIgPT0gdHlwZW9mIGIgJiYgKGUgPSBcIlBPU1RcIiksIGcubGVuZ3RoID4gMCAmJiByLmFqYXgoe1xyXG4gICAgICAgICAgICB1cmw6IGEsXHJcbiAgICAgICAgICAgIHR5cGU6IGUgfHwgXCJHRVRcIixcclxuICAgICAgICAgICAgZGF0YVR5cGU6IFwiaHRtbFwiLFxyXG4gICAgICAgICAgICBkYXRhOiBiXHJcbiAgICAgICAgfSkuZG9uZShmdW5jdGlvbihhKSB7XHJcbiAgICAgICAgICAgIGYgPSBhcmd1bWVudHMsIGcuaHRtbChkID8gcihcIjxkaXY+XCIpLmFwcGVuZChyLnBhcnNlSFRNTChhKSkuZmluZChkKSA6IGEpXHJcbiAgICAgICAgfSkuYWx3YXlzKGMgJiYgZnVuY3Rpb24oYSwgYikge1xyXG4gICAgICAgICAgICBnLmVhY2goZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICBjLmFwcGx5KHRoaXMsIGYgfHwgW2EucmVzcG9uc2VUZXh0LCBiLCBhXSlcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9KSwgdGhpc1xyXG4gICAgfSwgci5lYWNoKFtcImFqYXhTdGFydFwiLCBcImFqYXhTdG9wXCIsIFwiYWpheENvbXBsZXRlXCIsIFwiYWpheEVycm9yXCIsIFwiYWpheFN1Y2Nlc3NcIiwgXCJhamF4U2VuZFwiXSwgZnVuY3Rpb24oYSwgYikge1xyXG4gICAgICAgIHIuZm5bYl0gPSBmdW5jdGlvbihhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9uKGIsIGEpXHJcbiAgICAgICAgfVxyXG4gICAgfSksIHIuZXhwci5wc2V1ZG9zLmFuaW1hdGVkID0gZnVuY3Rpb24oYSkge1xyXG4gICAgICAgIHJldHVybiByLmdyZXAoci50aW1lcnMsIGZ1bmN0aW9uKGIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGEgPT09IGIuZWxlbVxyXG4gICAgICAgIH0pLmxlbmd0aFxyXG4gICAgfSwgci5vZmZzZXQgPSB7XHJcbiAgICAgICAgc2V0T2Zmc2V0OiBmdW5jdGlvbihhLCBiLCBjKSB7XHJcbiAgICAgICAgICAgIHZhciBkLCBlLCBmLCBnLCBoLCBpLCBqLCBrID0gci5jc3MoYSwgXCJwb3NpdGlvblwiKSxcclxuICAgICAgICAgICAgICAgIGwgPSByKGEpLFxyXG4gICAgICAgICAgICAgICAgbSA9IHt9O1xyXG4gICAgICAgICAgICBcInN0YXRpY1wiID09PSBrICYmIChhLnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiKSwgaCA9IGwub2Zmc2V0KCksIGYgPSByLmNzcyhhLCBcInRvcFwiKSwgaSA9IHIuY3NzKGEsIFwibGVmdFwiKSwgaiA9IChcImFic29sdXRlXCIgPT09IGsgfHwgXCJmaXhlZFwiID09PSBrKSAmJiAoZiArIGkpLmluZGV4T2YoXCJhdXRvXCIpID4gLTEsIGogPyAoZCA9IGwucG9zaXRpb24oKSwgZyA9IGQudG9wLCBlID0gZC5sZWZ0KSA6IChnID0gcGFyc2VGbG9hdChmKSB8fCAwLCBlID0gcGFyc2VGbG9hdChpKSB8fCAwKSwgci5pc0Z1bmN0aW9uKGIpICYmIChiID0gYi5jYWxsKGEsIGMsIHIuZXh0ZW5kKHt9LCBoKSkpLCBudWxsICE9IGIudG9wICYmIChtLnRvcCA9IGIudG9wIC0gaC50b3AgKyBnKSwgbnVsbCAhPSBiLmxlZnQgJiYgKG0ubGVmdCA9IGIubGVmdCAtIGgubGVmdCArIGUpLCBcInVzaW5nXCIgaW4gYiA/IGIudXNpbmcuY2FsbChhLCBtKSA6IGwuY3NzKG0pXHJcbiAgICAgICAgfVxyXG4gICAgfSwgci5mbi5leHRlbmQoe1xyXG4gICAgICAgIG9mZnNldDogZnVuY3Rpb24oYSkge1xyXG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHZvaWQgMCA9PT0gYSA/IHRoaXMgOiB0aGlzLmVhY2goZnVuY3Rpb24oYikge1xyXG4gICAgICAgICAgICAgICAgci5vZmZzZXQuc2V0T2Zmc2V0KHRoaXMsIGEsIGIpXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB2YXIgYiwgYywgZCwgZSwgZiA9IHRoaXNbMF07XHJcbiAgICAgICAgICAgIGlmIChmKSByZXR1cm4gZi5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCA/IChkID0gZi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgYiA9IGYub3duZXJEb2N1bWVudCwgYyA9IGIuZG9jdW1lbnRFbGVtZW50LCBlID0gYi5kZWZhdWx0Vmlldywge1xyXG4gICAgICAgICAgICAgICAgdG9wOiBkLnRvcCArIGUucGFnZVlPZmZzZXQgLSBjLmNsaWVudFRvcCxcclxuICAgICAgICAgICAgICAgIGxlZnQ6IGQubGVmdCArIGUucGFnZVhPZmZzZXQgLSBjLmNsaWVudExlZnRcclxuICAgICAgICAgICAgfSkgOiB7XHJcbiAgICAgICAgICAgICAgICB0b3A6IDAsXHJcbiAgICAgICAgICAgICAgICBsZWZ0OiAwXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHBvc2l0aW9uOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXNbMF0pIHtcclxuICAgICAgICAgICAgICAgIHZhciBhLCBiLCBjID0gdGhpc1swXSxcclxuICAgICAgICAgICAgICAgICAgICBkID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3A6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IDBcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiZml4ZWRcIiA9PT0gci5jc3MoYywgXCJwb3NpdGlvblwiKSA/IGIgPSBjLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIDogKGEgPSB0aGlzLm9mZnNldFBhcmVudCgpLCBiID0gdGhpcy5vZmZzZXQoKSwgQihhWzBdLCBcImh0bWxcIikgfHwgKGQgPSBhLm9mZnNldCgpKSwgZCA9IHtcclxuICAgICAgICAgICAgICAgICAgICB0b3A6IGQudG9wICsgci5jc3MoYVswXSwgXCJib3JkZXJUb3BXaWR0aFwiLCAhMCksXHJcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogZC5sZWZ0ICsgci5jc3MoYVswXSwgXCJib3JkZXJMZWZ0V2lkdGhcIiwgITApXHJcbiAgICAgICAgICAgICAgICB9KSwge1xyXG4gICAgICAgICAgICAgICAgICAgIHRvcDogYi50b3AgLSBkLnRvcCAtIHIuY3NzKGMsIFwibWFyZ2luVG9wXCIsICEwKSxcclxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiBiLmxlZnQgLSBkLmxlZnQgLSByLmNzcyhjLCBcIm1hcmdpbkxlZnRcIiwgITApXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIG9mZnNldFBhcmVudDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHZhciBhID0gdGhpcy5vZmZzZXRQYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoYSAmJiBcInN0YXRpY1wiID09PSByLmNzcyhhLCBcInBvc2l0aW9uXCIpKSBhID0gYS5vZmZzZXRQYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYSB8fCByYVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuICAgIH0pLCByLmVhY2goe1xyXG4gICAgICAgIHNjcm9sbExlZnQ6IFwicGFnZVhPZmZzZXRcIixcclxuICAgICAgICBzY3JvbGxUb3A6IFwicGFnZVlPZmZzZXRcIlxyXG4gICAgfSwgZnVuY3Rpb24oYSwgYikge1xyXG4gICAgICAgIHZhciBjID0gXCJwYWdlWU9mZnNldFwiID09PSBiO1xyXG4gICAgICAgIHIuZm5bYV0gPSBmdW5jdGlvbihkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBUKHRoaXMsIGZ1bmN0aW9uKGEsIGQsIGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBmO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHIuaXNXaW5kb3coYSkgPyBmID0gYSA6IDkgPT09IGEubm9kZVR5cGUgJiYgKGYgPSBhLmRlZmF1bHRWaWV3KSwgdm9pZCAwID09PSBlID8gZiA/IGZbYl0gOiBhW2RdIDogdm9pZChmID8gZi5zY3JvbGxUbyhjID8gZi5wYWdlWE9mZnNldCA6IGUsIGMgPyBlIDogZi5wYWdlWU9mZnNldCkgOiBhW2RdID0gZSlcclxuICAgICAgICAgICAgfSwgYSwgZCwgYXJndW1lbnRzLmxlbmd0aClcclxuICAgICAgICB9XHJcbiAgICB9KSwgci5lYWNoKFtcInRvcFwiLCBcImxlZnRcIl0sIGZ1bmN0aW9uKGEsIGIpIHtcclxuICAgICAgICByLmNzc0hvb2tzW2JdID0gUGEoby5waXhlbFBvc2l0aW9uLCBmdW5jdGlvbihhLCBjKSB7XHJcbiAgICAgICAgICAgIGlmIChjKSByZXR1cm4gYyA9IE9hKGEsIGIpLCBNYS50ZXN0KGMpID8gcihhKS5wb3NpdGlvbigpW2JdICsgXCJweFwiIDogY1xyXG4gICAgICAgIH0pXHJcbiAgICB9KSwgci5lYWNoKHtcclxuICAgICAgICBIZWlnaHQ6IFwiaGVpZ2h0XCIsXHJcbiAgICAgICAgV2lkdGg6IFwid2lkdGhcIlxyXG4gICAgfSwgZnVuY3Rpb24oYSwgYikge1xyXG4gICAgICAgIHIuZWFjaCh7XHJcbiAgICAgICAgICAgIHBhZGRpbmc6IFwiaW5uZXJcIiArIGEsXHJcbiAgICAgICAgICAgIGNvbnRlbnQ6IGIsXHJcbiAgICAgICAgICAgIFwiXCI6IFwib3V0ZXJcIiArIGFcclxuICAgICAgICB9LCBmdW5jdGlvbihjLCBkKSB7XHJcbiAgICAgICAgICAgIHIuZm5bZF0gPSBmdW5jdGlvbihlLCBmKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZyA9IGFyZ3VtZW50cy5sZW5ndGggJiYgKGMgfHwgXCJib29sZWFuXCIgIT0gdHlwZW9mIGUpLFxyXG4gICAgICAgICAgICAgICAgICAgIGggPSBjIHx8IChlID09PSAhMCB8fCBmID09PSAhMCA/IFwibWFyZ2luXCIgOiBcImJvcmRlclwiKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBUKHRoaXMsIGZ1bmN0aW9uKGIsIGMsIGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZjtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gci5pc1dpbmRvdyhiKSA/IDAgPT09IGQuaW5kZXhPZihcIm91dGVyXCIpID8gYltcImlubmVyXCIgKyBhXSA6IGIuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50W1wiY2xpZW50XCIgKyBhXSA6IDkgPT09IGIubm9kZVR5cGUgPyAoZiA9IGIuZG9jdW1lbnRFbGVtZW50LCBNYXRoLm1heChiLmJvZHlbXCJzY3JvbGxcIiArIGFdLCBmW1wic2Nyb2xsXCIgKyBhXSwgYi5ib2R5W1wib2Zmc2V0XCIgKyBhXSwgZltcIm9mZnNldFwiICsgYV0sIGZbXCJjbGllbnRcIiArIGFdKSkgOiB2b2lkIDAgPT09IGUgPyByLmNzcyhiLCBjLCBoKSA6IHIuc3R5bGUoYiwgYywgZSwgaClcclxuICAgICAgICAgICAgICAgIH0sIGIsIGcgPyBlIDogdm9pZCAwLCBnKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgIH0pLCByLmZuLmV4dGVuZCh7XHJcbiAgICAgICAgYmluZDogZnVuY3Rpb24oYSwgYiwgYykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vbihhLCBudWxsLCBiLCBjKVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdW5iaW5kOiBmdW5jdGlvbihhLCBiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9mZihhLCBudWxsLCBiKVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGVsZWdhdGU6IGZ1bmN0aW9uKGEsIGIsIGMsIGQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMub24oYiwgYSwgYywgZClcclxuICAgICAgICB9LFxyXG4gICAgICAgIHVuZGVsZWdhdGU6IGZ1bmN0aW9uKGEsIGIsIGMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDEgPT09IGFyZ3VtZW50cy5sZW5ndGggPyB0aGlzLm9mZihhLCBcIioqXCIpIDogdGhpcy5vZmYoYiwgYSB8fCBcIioqXCIsIGMpXHJcbiAgICAgICAgfVxyXG4gICAgfSksIHIuaG9sZFJlYWR5ID0gZnVuY3Rpb24oYSkge1xyXG4gICAgICAgIGEgPyByLnJlYWR5V2FpdCsrIDogci5yZWFkeSghMClcclxuICAgIH0sIHIuaXNBcnJheSA9IEFycmF5LmlzQXJyYXksIHIucGFyc2VKU09OID0gSlNPTi5wYXJzZSwgci5ub2RlTmFtZSA9IEIsIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZGVmaW5lICYmIGRlZmluZS5hbWQgJiYgZGVmaW5lKFwianF1ZXJ5XCIsIFtdLCBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gclxyXG4gICAgfSk7XHJcbiAgICB2YXIgVmIgPSBhLmpRdWVyeSxcclxuICAgICAgICBXYiA9IGEuJDtcclxuICAgIHJldHVybiByLm5vQ29uZmxpY3QgPSBmdW5jdGlvbihiKSB7XHJcbiAgICAgICAgcmV0dXJuIGEuJCA9PT0gciAmJiAoYS4kID0gV2IpLCBiICYmIGEualF1ZXJ5ID09PSByICYmIChhLmpRdWVyeSA9IFZiKSwgclxyXG4gICAgfSwgYiB8fCAoYS5qUXVlcnkgPSBhLiQgPSByKSwgclxyXG59KTsiXSwiZmlsZSI6ImpxdWVyeS5taW4uanMifQ==
