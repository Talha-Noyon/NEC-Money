/*
 Copyright (C) Federico Zivolo 2017
 Distributed under the MIT License (license terms are at http://opensource.org/licenses/MIT).
 */
(function(e, t) {
    'object' == typeof exports && 'undefined' != typeof module ? module.exports = t() : 'function' == typeof define && define.amd ? define(t) : e.Popper = t()
})(this, function() {
    'use strict';

    function e(e) {
        return e && '[object Function]' === {}.toString.call(e)
    }

    function t(e, t) {
        if (1 !== e.nodeType) return [];
        var o = window.getComputedStyle(e, null);
        return t ? o[t] : o
    }

    function o(e) {
        return 'HTML' === e.nodeName ? e : e.parentNode || e.host
    }

    function n(e) {
        if (!e || -1 !== ['HTML', 'BODY', '#document'].indexOf(e.nodeName)) return window.document.body;
        var i = t(e),
            r = i.overflow,
            p = i.overflowX,
            s = i.overflowY;
        return /(auto|scroll)/.test(r + s + p) ? e : n(o(e))
    }

    function r(e) {
        var o = e && e.offsetParent,
            i = o && o.nodeName;
        return i && 'BODY' !== i && 'HTML' !== i ? -1 !== ['TD', 'TABLE'].indexOf(o.nodeName) && 'static' === t(o, 'position') ? r(o) : o : window.document.documentElement
    }

    function p(e) {
        var t = e.nodeName;
        return 'BODY' !== t && ('HTML' === t || r(e.firstElementChild) === e)
    }

    function s(e) {
        return null === e.parentNode ? e : s(e.parentNode)
    }

    function d(e, t) {
        if (!e || !e.nodeType || !t || !t.nodeType) return window.document.documentElement;
        var o = e.compareDocumentPosition(t) & Node.DOCUMENT_POSITION_FOLLOWING,
            i = o ? e : t,
            n = o ? t : e,
            a = document.createRange();
        a.setStart(i, 0), a.setEnd(n, 0);
        var f = a.commonAncestorContainer;
        if (e !== f && t !== f || i.contains(n)) return p(f) ? f : r(f);
        var l = s(e);
        return l.host ? d(l.host, t) : d(e, s(t).host)
    }

    function a(e) {
        var t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 'top',
            o = 'top' === t ? 'scrollTop' : 'scrollLeft',
            i = e.nodeName;
        if ('BODY' === i || 'HTML' === i) {
            var n = window.document.documentElement,
                r = window.document.scrollingElement || n;
            return r[o]
        }
        return e[o]
    }

    function f(e, t) {
        var o = 2 < arguments.length && void 0 !== arguments[2] && arguments[2],
            i = a(t, 'top'),
            n = a(t, 'left'),
            r = o ? -1 : 1;
        return e.top += i * r, e.bottom += i * r, e.left += n * r, e.right += n * r, e
    }

    function l(e, t) {
        var o = 'x' === t ? 'Left' : 'Top',
            i = 'Left' == o ? 'Right' : 'Bottom';
        return +e['border' + o + 'Width'].split('px')[0] + +e['border' + i + 'Width'].split('px')[0]
    }

    function m(e, t, o, i) {
        return _(t['offset' + e], o['client' + e], o['offset' + e], ie() ? o['offset' + e] + i['margin' + ('Height' === e ? 'Top' : 'Left')] + i['margin' + ('Height' === e ? 'Bottom' : 'Right')] : 0)
    }

    function h() {
        var e = window.document.body,
            t = window.document.documentElement,
            o = ie() && window.getComputedStyle(t);
        return {
            height: m('Height', e, t, o),
            width: m('Width', e, t, o)
        }
    }

    function c(e) {
        return se({}, e, {
            right: e.left + e.width,
            bottom: e.top + e.height
        })
    }

    function g(e) {
        var o = {};
        if (ie()) try {
            o = e.getBoundingClientRect();
            var i = a(e, 'top'),
                n = a(e, 'left');
            o.top += i, o.left += n, o.bottom += i, o.right += n
        } catch (e) {} else o = e.getBoundingClientRect();
        var r = {
                left: o.left,
                top: o.top,
                width: o.right - o.left,
                height: o.bottom - o.top
            },
            p = 'HTML' === e.nodeName ? h() : {},
            s = p.width || e.clientWidth || r.right - r.left,
            d = p.height || e.clientHeight || r.bottom - r.top,
            f = e.offsetWidth - s,
            m = e.offsetHeight - d;
        if (f || m) {
            var g = t(e);
            f -= l(g, 'x'), m -= l(g, 'y'), r.width -= f, r.height -= m
        }
        return c(r)
    }

    function u(e, o) {
        var i = ie(),
            r = 'HTML' === o.nodeName,
            p = g(e),
            s = g(o),
            d = n(e),
            a = t(o),
            l = +a.borderTopWidth.split('px')[0],
            m = +a.borderLeftWidth.split('px')[0],
            h = c({
                top: p.top - s.top - l,
                left: p.left - s.left - m,
                width: p.width,
                height: p.height
            });
        if (h.marginTop = 0, h.marginLeft = 0, !i && r) {
            var u = +a.marginTop.split('px')[0],
                b = +a.marginLeft.split('px')[0];
            h.top -= l - u, h.bottom -= l - u, h.left -= m - b, h.right -= m - b, h.marginTop = u, h.marginLeft = b
        }
        return (i ? o.contains(d) : o === d && 'BODY' !== d.nodeName) && (h = f(h, o)), h
    }

    function b(e) {
        var t = window.document.documentElement,
            o = u(e, t),
            i = _(t.clientWidth, window.innerWidth || 0),
            n = _(t.clientHeight, window.innerHeight || 0),
            r = a(t),
            p = a(t, 'left'),
            s = {
                top: r - o.top + o.marginTop,
                left: p - o.left + o.marginLeft,
                width: i,
                height: n
            };
        return c(s)
    }

    function y(e) {
        var i = e.nodeName;
        return 'BODY' === i || 'HTML' === i ? !1 : 'fixed' === t(e, 'position') || y(o(e))
    }

    function w(e, t, i, r) {
        var p = {
                top: 0,
                left: 0
            },
            s = d(e, t);
        if ('viewport' === r) p = b(s);
        else {
            var a;
            'scrollParent' === r ? (a = n(o(e)), 'BODY' === a.nodeName && (a = window.document.documentElement)) : 'window' === r ? a = window.document.documentElement : a = r;
            var f = u(a, s);
            if ('HTML' === a.nodeName && !y(s)) {
                var l = h(),
                    m = l.height,
                    c = l.width;
                p.top += f.top - f.marginTop, p.bottom = m + f.top, p.left += f.left - f.marginLeft, p.right = c + f.left
            } else p = f
        }
        return p.left += i, p.top += i, p.right -= i, p.bottom -= i, p
    }

    function v(e) {
        var t = e.width,
            o = e.height;
        return t * o
    }

    function E(e, t, o, i, n) {
        var r = 5 < arguments.length && void 0 !== arguments[5] ? arguments[5] : 0;
        if (-1 === e.indexOf('auto')) return e;
        var p = w(o, i, r, n),
            s = {
                top: {
                    width: p.width,
                    height: t.top - p.top
                },
                right: {
                    width: p.right - t.right,
                    height: p.height
                },
                bottom: {
                    width: p.width,
                    height: p.bottom - t.bottom
                },
                left: {
                    width: t.left - p.left,
                    height: p.height
                }
            },
            d = Object.keys(s).map(function(e) {
                return se({
                    key: e
                }, s[e], {
                    area: v(s[e])
                })
            }).sort(function(e, t) {
                return t.area - e.area
            }),
            a = d.filter(function(e) {
                var t = e.width,
                    i = e.height;
                return t >= o.clientWidth && i >= o.clientHeight
            }),
            f = 0 < a.length ? a[0].key : d[0].key,
            l = e.split('-')[1];
        return f + (l ? '-' + l : '')
    }

    function x(e, t, o) {
        var i = d(t, o);
        return u(o, i)
    }

    function O(e) {
        var t = window.getComputedStyle(e),
            o = parseFloat(t.marginTop) + parseFloat(t.marginBottom),
            i = parseFloat(t.marginLeft) + parseFloat(t.marginRight),
            n = {
                width: e.offsetWidth + i,
                height: e.offsetHeight + o
            };
        return n
    }

    function L(e) {
        var t = {
            left: 'right',
            right: 'left',
            bottom: 'top',
            top: 'bottom'
        };
        return e.replace(/left|right|bottom|top/g, function(e) {
            return t[e]
        })
    }

    function S(e, t, o) {
        o = o.split('-')[0];
        var i = O(e),
            n = {
                width: i.width,
                height: i.height
            },
            r = -1 !== ['right', 'left'].indexOf(o),
            p = r ? 'top' : 'left',
            s = r ? 'left' : 'top',
            d = r ? 'height' : 'width',
            a = r ? 'width' : 'height';
        return n[p] = t[p] + t[d] / 2 - i[d] / 2, n[s] = o === s ? t[s] - i[a] : t[L(s)], n
    }

    function T(e, t) {
        return Array.prototype.find ? e.find(t) : e.filter(t)[0]
    }

    function C(e, t, o) {
        if (Array.prototype.findIndex) return e.findIndex(function(e) {
            return e[t] === o
        });
        var i = T(e, function(e) {
            return e[t] === o
        });
        return e.indexOf(i)
    }

    function N(t, o, i) {
        var n = void 0 === i ? t : t.slice(0, C(t, 'name', i));
        return n.forEach(function(t) {
            t.function && console.warn('`modifier.function` is deprecated, use `modifier.fn`!');
            var i = t.function || t.fn;
            t.enabled && e(i) && (o.offsets.popper = c(o.offsets.popper), o.offsets.reference = c(o.offsets.reference), o = i(o, t))
        }), o
    }

    function k() {
        if (!this.state.isDestroyed) {
            var e = {
                instance: this,
                styles: {},
                attributes: {},
                flipped: !1,
                offsets: {}
            };
            e.offsets.reference = x(this.state, this.popper, this.reference), e.placement = E(this.options.placement, e.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding), e.originalPlacement = e.placement, e.offsets.popper = S(this.popper, e.offsets.reference, e.placement), e.offsets.popper.position = 'absolute', e = N(this.modifiers, e), this.state.isCreated ? this.options.onUpdate(e) : (this.state.isCreated = !0, this.options.onCreate(e))
        }
    }

    function W(e, t) {
        return e.some(function(e) {
            var o = e.name,
                i = e.enabled;
            return i && o === t
        })
    }

    function B(e) {
        for (var t = [!1, 'ms', 'Webkit', 'Moz', 'O'], o = e.charAt(0).toUpperCase() + e.slice(1), n = 0; n < t.length - 1; n++) {
            var i = t[n],
                r = i ? '' + i + o : e;
            if ('undefined' != typeof window.document.body.style[r]) return r
        }
        return null
    }

    function D() {
        return this.state.isDestroyed = !0, W(this.modifiers, 'applyStyle') && (this.popper.removeAttribute('x-placement'), this.popper.style.left = '', this.popper.style.position = '', this.popper.style.top = '', this.popper.style[B('transform')] = ''), this.disableEventListeners(), this.options.removeOnDestroy && this.popper.parentNode.removeChild(this.popper), this
    }

    function H(e, t, o, i) {
        var r = 'BODY' === e.nodeName,
            p = r ? window : e;
        p.addEventListener(t, o, {
            passive: !0
        }), r || H(n(p.parentNode), t, o, i), i.push(p)
    }

    function P(e, t, o, i) {
        o.updateBound = i, window.addEventListener('resize', o.updateBound, {
            passive: !0
        });
        var r = n(e);
        return H(r, 'scroll', o.updateBound, o.scrollParents), o.scrollElement = r, o.eventsEnabled = !0, o
    }

    function A() {
        this.state.eventsEnabled || (this.state = P(this.reference, this.options, this.state, this.scheduleUpdate))
    }

    function M(e, t) {
        return window.removeEventListener('resize', t.updateBound), t.scrollParents.forEach(function(e) {
            e.removeEventListener('scroll', t.updateBound)
        }), t.updateBound = null, t.scrollParents = [], t.scrollElement = null, t.eventsEnabled = !1, t
    }

    function I() {
        this.state.eventsEnabled && (window.cancelAnimationFrame(this.scheduleUpdate), this.state = M(this.reference, this.state))
    }

    function R(e) {
        return '' !== e && !isNaN(parseFloat(e)) && isFinite(e)
    }

    function U(e, t) {
        Object.keys(t).forEach(function(o) {
            var i = ''; - 1 !== ['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(o) && R(t[o]) && (i = 'px'), e.style[o] = t[o] + i
        })
    }

    function Y(e, t) {
        Object.keys(t).forEach(function(o) {
            var i = t[o];
            !1 === i ? e.removeAttribute(o) : e.setAttribute(o, t[o])
        })
    }

    function F(e, t, o) {
        var i = T(e, function(e) {
                var o = e.name;
                return o === t
            }),
            n = !!i && e.some(function(e) {
                return e.name === o && e.enabled && e.order < i.order
            });
        if (!n) {
            var r = '`' + t + '`';
            console.warn('`' + o + '`' + ' modifier is required by ' + r + ' modifier in order to work, be sure to include it before ' + r + '!')
        }
        return n
    }

    function j(e) {
        return 'end' === e ? 'start' : 'start' === e ? 'end' : e
    }

    function K(e) {
        var t = 1 < arguments.length && void 0 !== arguments[1] && arguments[1],
            o = ae.indexOf(e),
            i = ae.slice(o + 1).concat(ae.slice(0, o));
        return t ? i.reverse() : i
    }

    function q(e, t, o, i) {
        var n = e.match(/((?:\-|\+)?\d*\.?\d*)(.*)/),
            r = +n[1],
            p = n[2];
        if (!r) return e;
        if (0 === p.indexOf('%')) {
            var s;
            switch (p) {
                case '%p':
                    s = o;
                    break;
                case '%':
                case '%r':
                default:
                    s = i;
            }
            var d = c(s);
            return d[t] / 100 * r
        }
        if ('vh' === p || 'vw' === p) {
            var a;
            return a = 'vh' === p ? _(document.documentElement.clientHeight, window.innerHeight || 0) : _(document.documentElement.clientWidth, window.innerWidth || 0), a / 100 * r
        }
        return r
    }

    function G(e, t, o, i) {
        var n = [0, 0],
            r = -1 !== ['right', 'left'].indexOf(i),
            p = e.split(/(\+|\-)/).map(function(e) {
                return e.trim()
            }),
            s = p.indexOf(T(p, function(e) {
                return -1 !== e.search(/,|\s/)
            }));
        p[s] && -1 === p[s].indexOf(',') && console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');
        var d = /\s*,\s*|\s+/,
            a = -1 === s ? [p] : [p.slice(0, s).concat([p[s].split(d)[0]]), [p[s].split(d)[1]].concat(p.slice(s + 1))];
        return a = a.map(function(e, i) {
            var n = (1 === i ? !r : r) ? 'height' : 'width',
                p = !1;
            return e.reduce(function(e, t) {
                return '' === e[e.length - 1] && -1 !== ['+', '-'].indexOf(t) ? (e[e.length - 1] = t, p = !0, e) : p ? (e[e.length - 1] += t, p = !1, e) : e.concat(t)
            }, []).map(function(e) {
                return q(e, n, t, o)
            })
        }), a.forEach(function(e, t) {
            e.forEach(function(o, i) {
                R(o) && (n[t] += o * ('-' === e[i - 1] ? -1 : 1))
            })
        }), n
    }
    for (var z = Math.min, V = Math.floor, _ = Math.max, X = ['native code', '[object MutationObserverConstructor]'], Q = function(e) {
            return X.some(function(t) {
                return -1 < (e || '').toString().indexOf(t)
            })
        }, J = 'undefined' != typeof window, Z = ['Edge', 'Trident', 'Firefox'], $ = 0, ee = 0; ee < Z.length; ee += 1)
        if (J && 0 <= navigator.userAgent.indexOf(Z[ee])) {
            $ = 1;
            break
        }
    var i, te = J && Q(window.MutationObserver),
        oe = te ? function(e) {
            var t = !1,
                o = 0,
                i = document.createElement('span'),
                n = new MutationObserver(function() {
                    e(), t = !1
                });
            return n.observe(i, {
                    attributes: !0
                }),
                function() {
                    t || (t = !0, i.setAttribute('x-index', o), ++o)
                }
        } : function(e) {
            var t = !1;
            return function() {
                t || (t = !0, setTimeout(function() {
                    t = !1, e()
                }, $))
            }
        },
        ie = function() {
            return void 0 == i && (i = -1 !== navigator.appVersion.indexOf('MSIE 10')), i
        },
        ne = function(e, t) {
            if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function')
        },
        re = function() {
            function e(e, t) {
                for (var o, n = 0; n < t.length; n++) o = t[n], o.enumerable = o.enumerable || !1, o.configurable = !0, 'value' in o && (o.writable = !0), Object.defineProperty(e, o.key, o)
            }
            return function(t, o, i) {
                return o && e(t.prototype, o), i && e(t, i), t
            }
        }(),
        pe = function(e, t, o) {
            return t in e ? Object.defineProperty(e, t, {
                value: o,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : e[t] = o, e
        },
        se = Object.assign || function(e) {
            for (var t, o = 1; o < arguments.length; o++)
                for (var i in t = arguments[o], t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
            return e
        },
        de = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start'],
        ae = de.slice(3),
        fe = {
            FLIP: 'flip',
            CLOCKWISE: 'clockwise',
            COUNTERCLOCKWISE: 'counterclockwise'
        },
        le = function() {
            function t(o, i) {
                var n = this,
                    r = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : {};
                ne(this, t), this.scheduleUpdate = function() {
                    return requestAnimationFrame(n.update)
                }, this.update = oe(this.update.bind(this)), this.options = se({}, t.Defaults, r), this.state = {
                    isDestroyed: !1,
                    isCreated: !1,
                    scrollParents: []
                }, this.reference = o.jquery ? o[0] : o, this.popper = i.jquery ? i[0] : i, this.options.modifiers = {}, Object.keys(se({}, t.Defaults.modifiers, r.modifiers)).forEach(function(e) {
                    n.options.modifiers[e] = se({}, t.Defaults.modifiers[e] || {}, r.modifiers ? r.modifiers[e] : {})
                }), this.modifiers = Object.keys(this.options.modifiers).map(function(e) {
                    return se({
                        name: e
                    }, n.options.modifiers[e])
                }).sort(function(e, t) {
                    return e.order - t.order
                }), this.modifiers.forEach(function(t) {
                    t.enabled && e(t.onLoad) && t.onLoad(n.reference, n.popper, n.options, t, n.state)
                }), this.update();
                var p = this.options.eventsEnabled;
                p && this.enableEventListeners(), this.state.eventsEnabled = p
            }
            return re(t, [{
                key: 'update',
                value: function() {
                    return k.call(this)
                }
            }, {
                key: 'destroy',
                value: function() {
                    return D.call(this)
                }
            }, {
                key: 'enableEventListeners',
                value: function() {
                    return A.call(this)
                }
            }, {
                key: 'disableEventListeners',
                value: function() {
                    return I.call(this)
                }
            }]), t
        }();
    return le.Utils = ('undefined' == typeof window ? global : window).PopperUtils, le.placements = de, le.Defaults = {
        placement: 'bottom',
        eventsEnabled: !0,
        removeOnDestroy: !1,
        onCreate: function() {},
        onUpdate: function() {},
        modifiers: {
            shift: {
                order: 100,
                enabled: !0,
                fn: function(e) {
                    var t = e.placement,
                        o = t.split('-')[0],
                        i = t.split('-')[1];
                    if (i) {
                        var n = e.offsets,
                            r = n.reference,
                            p = n.popper,
                            s = -1 !== ['bottom', 'top'].indexOf(o),
                            d = s ? 'left' : 'top',
                            a = s ? 'width' : 'height',
                            f = {
                                start: pe({}, d, r[d]),
                                end: pe({}, d, r[d] + r[a] - p[a])
                            };
                        e.offsets.popper = se({}, p, f[i])
                    }
                    return e
                }
            },
            offset: {
                order: 200,
                enabled: !0,
                fn: function(e, t) {
                    var o, i = t.offset,
                        n = e.placement,
                        r = e.offsets,
                        p = r.popper,
                        s = r.reference,
                        d = n.split('-')[0];
                    return o = R(+i) ? [+i, 0] : G(i, p, s, d), 'left' === d ? (p.top += o[0], p.left -= o[1]) : 'right' === d ? (p.top += o[0], p.left += o[1]) : 'top' === d ? (p.left += o[0], p.top -= o[1]) : 'bottom' === d && (p.left += o[0], p.top += o[1]), e.popper = p, e
                },
                offset: 0
            },
            preventOverflow: {
                order: 300,
                enabled: !0,
                fn: function(e, t) {
                    var o = t.boundariesElement || r(e.instance.popper);
                    e.instance.reference === o && (o = r(o));
                    var i = w(e.instance.popper, e.instance.reference, t.padding, o);
                    t.boundaries = i;
                    var n = t.priority,
                        p = e.offsets.popper,
                        s = {
                            primary: function(e) {
                                var o = p[e];
                                return p[e] < i[e] && !t.escapeWithReference && (o = _(p[e], i[e])), pe({}, e, o)
                            },
                            secondary: function(e) {
                                var o = 'right' === e ? 'left' : 'top',
                                    n = p[o];
                                return p[e] > i[e] && !t.escapeWithReference && (n = z(p[o], i[e] - ('right' === e ? p.width : p.height))), pe({}, o, n)
                            }
                        };
                    return n.forEach(function(e) {
                        var t = -1 === ['left', 'top'].indexOf(e) ? 'secondary' : 'primary';
                        p = se({}, p, s[t](e))
                    }), e.offsets.popper = p, e
                },
                priority: ['left', 'right', 'top', 'bottom'],
                padding: 5,
                boundariesElement: 'scrollParent'
            },
            keepTogether: {
                order: 400,
                enabled: !0,
                fn: function(e) {
                    var t = e.offsets,
                        o = t.popper,
                        i = t.reference,
                        n = e.placement.split('-')[0],
                        r = V,
                        p = -1 !== ['top', 'bottom'].indexOf(n),
                        s = p ? 'right' : 'bottom',
                        d = p ? 'left' : 'top',
                        a = p ? 'width' : 'height';
                    return o[s] < r(i[d]) && (e.offsets.popper[d] = r(i[d]) - o[a]), o[d] > r(i[s]) && (e.offsets.popper[d] = r(i[s])), e
                }
            },
            arrow: {
                order: 500,
                enabled: !0,
                fn: function(e, t) {
                    if (!F(e.instance.modifiers, 'arrow', 'keepTogether')) return e;
                    var o = t.element;
                    if ('string' == typeof o) {
                        if (o = e.instance.popper.querySelector(o), !o) return e;
                    } else if (!e.instance.popper.contains(o)) return console.warn('WARNING: `arrow.element` must be child of its popper element!'), e;
                    var i = e.placement.split('-')[0],
                        n = e.offsets,
                        r = n.popper,
                        p = n.reference,
                        s = -1 !== ['left', 'right'].indexOf(i),
                        d = s ? 'height' : 'width',
                        a = s ? 'top' : 'left',
                        f = s ? 'left' : 'top',
                        l = s ? 'bottom' : 'right',
                        m = O(o)[d];
                    p[l] - m < r[a] && (e.offsets.popper[a] -= r[a] - (p[l] - m)), p[a] + m > r[l] && (e.offsets.popper[a] += p[a] + m - r[l]);
                    var h = p[a] + p[d] / 2 - m / 2,
                        g = h - c(e.offsets.popper)[a];
                    return g = _(z(r[d] - m, g), 0), e.arrowElement = o, e.offsets.arrow = {}, e.offsets.arrow[a] = Math.round(g), e.offsets.arrow[f] = '', e
                },
                element: '[x-arrow]'
            },
            flip: {
                order: 600,
                enabled: !0,
                fn: function(e, t) {
                    if (W(e.instance.modifiers, 'inner')) return e;
                    if (e.flipped && e.placement === e.originalPlacement) return e;
                    var o = w(e.instance.popper, e.instance.reference, t.padding, t.boundariesElement),
                        i = e.placement.split('-')[0],
                        n = L(i),
                        r = e.placement.split('-')[1] || '',
                        p = [];
                    switch (t.behavior) {
                        case fe.FLIP:
                            p = [i, n];
                            break;
                        case fe.CLOCKWISE:
                            p = K(i);
                            break;
                        case fe.COUNTERCLOCKWISE:
                            p = K(i, !0);
                            break;
                        default:
                            p = t.behavior;
                    }
                    return p.forEach(function(s, d) {
                        if (i !== s || p.length === d + 1) return e;
                        i = e.placement.split('-')[0], n = L(i);
                        var a = e.offsets.popper,
                            f = e.offsets.reference,
                            l = V,
                            m = 'left' === i && l(a.right) > l(f.left) || 'right' === i && l(a.left) < l(f.right) || 'top' === i && l(a.bottom) > l(f.top) || 'bottom' === i && l(a.top) < l(f.bottom),
                            h = l(a.left) < l(o.left),
                            c = l(a.right) > l(o.right),
                            g = l(a.top) < l(o.top),
                            u = l(a.bottom) > l(o.bottom),
                            b = 'left' === i && h || 'right' === i && c || 'top' === i && g || 'bottom' === i && u,
                            y = -1 !== ['top', 'bottom'].indexOf(i),
                            w = !!t.flipVariations && (y && 'start' === r && h || y && 'end' === r && c || !y && 'start' === r && g || !y && 'end' === r && u);
                        (m || b || w) && (e.flipped = !0, (m || b) && (i = p[d + 1]), w && (r = j(r)), e.placement = i + (r ? '-' + r : ''), e.offsets.popper = se({}, e.offsets.popper, S(e.instance.popper, e.offsets.reference, e.placement)), e = N(e.instance.modifiers, e, 'flip'))
                    }), e
                },
                behavior: 'flip',
                padding: 5,
                boundariesElement: 'viewport'
            },
            inner: {
                order: 700,
                enabled: !1,
                fn: function(e) {
                    var t = e.placement,
                        o = t.split('-')[0],
                        i = e.offsets,
                        n = i.popper,
                        r = i.reference,
                        p = -1 !== ['left', 'right'].indexOf(o),
                        s = -1 === ['top', 'left'].indexOf(o);
                    return n[p ? 'left' : 'top'] = r[t] - (s ? n[p ? 'width' : 'height'] : 0), e.placement = L(t), e.offsets.popper = c(n), e
                }
            },
            hide: {
                order: 800,
                enabled: !0,
                fn: function(e) {
                    if (!F(e.instance.modifiers, 'hide', 'preventOverflow')) return e;
                    var t = e.offsets.reference,
                        o = T(e.instance.modifiers, function(e) {
                            return 'preventOverflow' === e.name
                        }).boundaries;
                    if (t.bottom < o.top || t.left > o.right || t.top > o.bottom || t.right < o.left) {
                        if (!0 === e.hide) return e;
                        e.hide = !0, e.attributes['x-out-of-boundaries'] = ''
                    } else {
                        if (!1 === e.hide) return e;
                        e.hide = !1, e.attributes['x-out-of-boundaries'] = !1
                    }
                    return e
                }
            },
            computeStyle: {
                order: 850,
                enabled: !0,
                fn: function(e, t) {
                    var o = t.x,
                        i = t.y,
                        n = e.offsets.popper,
                        p = T(e.instance.modifiers, function(e) {
                            return 'applyStyle' === e.name
                        }).gpuAcceleration;
                    void 0 !== p && console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');
                    var s, d, a = void 0 === p ? t.gpuAcceleration : p,
                        f = r(e.instance.popper),
                        l = g(f),
                        m = {
                            position: n.position
                        },
                        h = {
                            left: V(n.left),
                            top: V(n.top),
                            bottom: V(n.bottom),
                            right: V(n.right)
                        },
                        c = 'bottom' === o ? 'top' : 'bottom',
                        u = 'right' === i ? 'left' : 'right',
                        b = B('transform');
                    if (d = 'bottom' == c ? -l.height + h.bottom : h.top, s = 'right' == u ? -l.width + h.right : h.left, a && b) m[b] = 'translate3d(' + s + 'px, ' + d + 'px, 0)', m[c] = 0, m[u] = 0, m.willChange = 'transform';
                    else {
                        var y = 'bottom' == c ? -1 : 1,
                            w = 'right' == u ? -1 : 1;
                        m[c] = d * y, m[u] = s * w, m.willChange = c + ', ' + u
                    }
                    var v = {
                        "x-placement": e.placement
                    };
                    return e.attributes = se({}, v, e.attributes), e.styles = se({}, m, e.styles), e
                },
                gpuAcceleration: !0,
                x: 'bottom',
                y: 'right'
            },
            applyStyle: {
                order: 900,
                enabled: !0,
                fn: function(e) {
                    return U(e.instance.popper, e.styles), Y(e.instance.popper, e.attributes), e.offsets.arrow && U(e.arrowElement, e.offsets.arrow), e
                },
                onLoad: function(e, t, o, i, n) {
                    var r = x(n, t, e),
                        p = E(o.placement, r, t, e, o.modifiers.flip.boundariesElement, o.modifiers.flip.padding);
                    return t.setAttribute('x-placement', p), U(t, {
                        position: 'absolute'
                    }), o
                },
                gpuAcceleration: void 0
            }
        }
    }, le
});
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiIiwic291cmNlcyI6WyJwb3BwZXIubWluLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXHJcbiBDb3B5cmlnaHQgKEMpIEZlZGVyaWNvIFppdm9sbyAyMDE3XHJcbiBEaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UgKGxpY2Vuc2UgdGVybXMgYXJlIGF0IGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQpLlxyXG4gKi9cclxuKGZ1bmN0aW9uKGUsIHQpIHtcclxuICAgICdvYmplY3QnID09IHR5cGVvZiBleHBvcnRzICYmICd1bmRlZmluZWQnICE9IHR5cGVvZiBtb2R1bGUgPyBtb2R1bGUuZXhwb3J0cyA9IHQoKSA6ICdmdW5jdGlvbicgPT0gdHlwZW9mIGRlZmluZSAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKHQpIDogZS5Qb3BwZXIgPSB0KClcclxufSkodGhpcywgZnVuY3Rpb24oKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcblxyXG4gICAgZnVuY3Rpb24gZShlKSB7XHJcbiAgICAgICAgcmV0dXJuIGUgJiYgJ1tvYmplY3QgRnVuY3Rpb25dJyA9PT0ge30udG9TdHJpbmcuY2FsbChlKVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHQoZSwgdCkge1xyXG4gICAgICAgIGlmICgxICE9PSBlLm5vZGVUeXBlKSByZXR1cm4gW107XHJcbiAgICAgICAgdmFyIG8gPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlLCBudWxsKTtcclxuICAgICAgICByZXR1cm4gdCA/IG9bdF0gOiBvXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbyhlKSB7XHJcbiAgICAgICAgcmV0dXJuICdIVE1MJyA9PT0gZS5ub2RlTmFtZSA/IGUgOiBlLnBhcmVudE5vZGUgfHwgZS5ob3N0XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbihlKSB7XHJcbiAgICAgICAgaWYgKCFlIHx8IC0xICE9PSBbJ0hUTUwnLCAnQk9EWScsICcjZG9jdW1lbnQnXS5pbmRleE9mKGUubm9kZU5hbWUpKSByZXR1cm4gd2luZG93LmRvY3VtZW50LmJvZHk7XHJcbiAgICAgICAgdmFyIGkgPSB0KGUpLFxyXG4gICAgICAgICAgICByID0gaS5vdmVyZmxvdyxcclxuICAgICAgICAgICAgcCA9IGkub3ZlcmZsb3dYLFxyXG4gICAgICAgICAgICBzID0gaS5vdmVyZmxvd1k7XHJcbiAgICAgICAgcmV0dXJuIC8oYXV0b3xzY3JvbGwpLy50ZXN0KHIgKyBzICsgcCkgPyBlIDogbihvKGUpKVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHIoZSkge1xyXG4gICAgICAgIHZhciBvID0gZSAmJiBlLm9mZnNldFBhcmVudCxcclxuICAgICAgICAgICAgaSA9IG8gJiYgby5ub2RlTmFtZTtcclxuICAgICAgICByZXR1cm4gaSAmJiAnQk9EWScgIT09IGkgJiYgJ0hUTUwnICE9PSBpID8gLTEgIT09IFsnVEQnLCAnVEFCTEUnXS5pbmRleE9mKG8ubm9kZU5hbWUpICYmICdzdGF0aWMnID09PSB0KG8sICdwb3NpdGlvbicpID8gcihvKSA6IG8gOiB3aW5kb3cuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcChlKSB7XHJcbiAgICAgICAgdmFyIHQgPSBlLm5vZGVOYW1lO1xyXG4gICAgICAgIHJldHVybiAnQk9EWScgIT09IHQgJiYgKCdIVE1MJyA9PT0gdCB8fCByKGUuZmlyc3RFbGVtZW50Q2hpbGQpID09PSBlKVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHMoZSkge1xyXG4gICAgICAgIHJldHVybiBudWxsID09PSBlLnBhcmVudE5vZGUgPyBlIDogcyhlLnBhcmVudE5vZGUpXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZChlLCB0KSB7XHJcbiAgICAgICAgaWYgKCFlIHx8ICFlLm5vZGVUeXBlIHx8ICF0IHx8ICF0Lm5vZGVUeXBlKSByZXR1cm4gd2luZG93LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcclxuICAgICAgICB2YXIgbyA9IGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24odCkgJiBOb2RlLkRPQ1VNRU5UX1BPU0lUSU9OX0ZPTExPV0lORyxcclxuICAgICAgICAgICAgaSA9IG8gPyBlIDogdCxcclxuICAgICAgICAgICAgbiA9IG8gPyB0IDogZSxcclxuICAgICAgICAgICAgYSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XHJcbiAgICAgICAgYS5zZXRTdGFydChpLCAwKSwgYS5zZXRFbmQobiwgMCk7XHJcbiAgICAgICAgdmFyIGYgPSBhLmNvbW1vbkFuY2VzdG9yQ29udGFpbmVyO1xyXG4gICAgICAgIGlmIChlICE9PSBmICYmIHQgIT09IGYgfHwgaS5jb250YWlucyhuKSkgcmV0dXJuIHAoZikgPyBmIDogcihmKTtcclxuICAgICAgICB2YXIgbCA9IHMoZSk7XHJcbiAgICAgICAgcmV0dXJuIGwuaG9zdCA/IGQobC5ob3N0LCB0KSA6IGQoZSwgcyh0KS5ob3N0KVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGEoZSkge1xyXG4gICAgICAgIHZhciB0ID0gMSA8IGFyZ3VtZW50cy5sZW5ndGggJiYgdm9pZCAwICE9PSBhcmd1bWVudHNbMV0gPyBhcmd1bWVudHNbMV0gOiAndG9wJyxcclxuICAgICAgICAgICAgbyA9ICd0b3AnID09PSB0ID8gJ3Njcm9sbFRvcCcgOiAnc2Nyb2xsTGVmdCcsXHJcbiAgICAgICAgICAgIGkgPSBlLm5vZGVOYW1lO1xyXG4gICAgICAgIGlmICgnQk9EWScgPT09IGkgfHwgJ0hUTUwnID09PSBpKSB7XHJcbiAgICAgICAgICAgIHZhciBuID0gd2luZG93LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxcclxuICAgICAgICAgICAgICAgIHIgPSB3aW5kb3cuZG9jdW1lbnQuc2Nyb2xsaW5nRWxlbWVudCB8fCBuO1xyXG4gICAgICAgICAgICByZXR1cm4gcltvXVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZVtvXVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGYoZSwgdCkge1xyXG4gICAgICAgIHZhciBvID0gMiA8IGFyZ3VtZW50cy5sZW5ndGggJiYgdm9pZCAwICE9PSBhcmd1bWVudHNbMl0gJiYgYXJndW1lbnRzWzJdLFxyXG4gICAgICAgICAgICBpID0gYSh0LCAndG9wJyksXHJcbiAgICAgICAgICAgIG4gPSBhKHQsICdsZWZ0JyksXHJcbiAgICAgICAgICAgIHIgPSBvID8gLTEgOiAxO1xyXG4gICAgICAgIHJldHVybiBlLnRvcCArPSBpICogciwgZS5ib3R0b20gKz0gaSAqIHIsIGUubGVmdCArPSBuICogciwgZS5yaWdodCArPSBuICogciwgZVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGwoZSwgdCkge1xyXG4gICAgICAgIHZhciBvID0gJ3gnID09PSB0ID8gJ0xlZnQnIDogJ1RvcCcsXHJcbiAgICAgICAgICAgIGkgPSAnTGVmdCcgPT0gbyA/ICdSaWdodCcgOiAnQm90dG9tJztcclxuICAgICAgICByZXR1cm4gK2VbJ2JvcmRlcicgKyBvICsgJ1dpZHRoJ10uc3BsaXQoJ3B4JylbMF0gKyArZVsnYm9yZGVyJyArIGkgKyAnV2lkdGgnXS5zcGxpdCgncHgnKVswXVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG0oZSwgdCwgbywgaSkge1xyXG4gICAgICAgIHJldHVybiBfKHRbJ29mZnNldCcgKyBlXSwgb1snY2xpZW50JyArIGVdLCBvWydvZmZzZXQnICsgZV0sIGllKCkgPyBvWydvZmZzZXQnICsgZV0gKyBpWydtYXJnaW4nICsgKCdIZWlnaHQnID09PSBlID8gJ1RvcCcgOiAnTGVmdCcpXSArIGlbJ21hcmdpbicgKyAoJ0hlaWdodCcgPT09IGUgPyAnQm90dG9tJyA6ICdSaWdodCcpXSA6IDApXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaCgpIHtcclxuICAgICAgICB2YXIgZSA9IHdpbmRvdy5kb2N1bWVudC5ib2R5LFxyXG4gICAgICAgICAgICB0ID0gd2luZG93LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxcclxuICAgICAgICAgICAgbyA9IGllKCkgJiYgd2luZG93LmdldENvbXB1dGVkU3R5bGUodCk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgaGVpZ2h0OiBtKCdIZWlnaHQnLCBlLCB0LCBvKSxcclxuICAgICAgICAgICAgd2lkdGg6IG0oJ1dpZHRoJywgZSwgdCwgbylcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gYyhlKSB7XHJcbiAgICAgICAgcmV0dXJuIHNlKHt9LCBlLCB7XHJcbiAgICAgICAgICAgIHJpZ2h0OiBlLmxlZnQgKyBlLndpZHRoLFxyXG4gICAgICAgICAgICBib3R0b206IGUudG9wICsgZS5oZWlnaHRcclxuICAgICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGcoZSkge1xyXG4gICAgICAgIHZhciBvID0ge307XHJcbiAgICAgICAgaWYgKGllKCkpIHRyeSB7XHJcbiAgICAgICAgICAgIG8gPSBlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgICAgICB2YXIgaSA9IGEoZSwgJ3RvcCcpLFxyXG4gICAgICAgICAgICAgICAgbiA9IGEoZSwgJ2xlZnQnKTtcclxuICAgICAgICAgICAgby50b3AgKz0gaSwgby5sZWZ0ICs9IG4sIG8uYm90dG9tICs9IGksIG8ucmlnaHQgKz0gblxyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHt9IGVsc2UgbyA9IGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICAgICAgdmFyIHIgPSB7XHJcbiAgICAgICAgICAgICAgICBsZWZ0OiBvLmxlZnQsXHJcbiAgICAgICAgICAgICAgICB0b3A6IG8udG9wLFxyXG4gICAgICAgICAgICAgICAgd2lkdGg6IG8ucmlnaHQgLSBvLmxlZnQsXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IG8uYm90dG9tIC0gby50b3BcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcCA9ICdIVE1MJyA9PT0gZS5ub2RlTmFtZSA/IGgoKSA6IHt9LFxyXG4gICAgICAgICAgICBzID0gcC53aWR0aCB8fCBlLmNsaWVudFdpZHRoIHx8IHIucmlnaHQgLSByLmxlZnQsXHJcbiAgICAgICAgICAgIGQgPSBwLmhlaWdodCB8fCBlLmNsaWVudEhlaWdodCB8fCByLmJvdHRvbSAtIHIudG9wLFxyXG4gICAgICAgICAgICBmID0gZS5vZmZzZXRXaWR0aCAtIHMsXHJcbiAgICAgICAgICAgIG0gPSBlLm9mZnNldEhlaWdodCAtIGQ7XHJcbiAgICAgICAgaWYgKGYgfHwgbSkge1xyXG4gICAgICAgICAgICB2YXIgZyA9IHQoZSk7XHJcbiAgICAgICAgICAgIGYgLT0gbChnLCAneCcpLCBtIC09IGwoZywgJ3knKSwgci53aWR0aCAtPSBmLCByLmhlaWdodCAtPSBtXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjKHIpXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdShlLCBvKSB7XHJcbiAgICAgICAgdmFyIGkgPSBpZSgpLFxyXG4gICAgICAgICAgICByID0gJ0hUTUwnID09PSBvLm5vZGVOYW1lLFxyXG4gICAgICAgICAgICBwID0gZyhlKSxcclxuICAgICAgICAgICAgcyA9IGcobyksXHJcbiAgICAgICAgICAgIGQgPSBuKGUpLFxyXG4gICAgICAgICAgICBhID0gdChvKSxcclxuICAgICAgICAgICAgbCA9ICthLmJvcmRlclRvcFdpZHRoLnNwbGl0KCdweCcpWzBdLFxyXG4gICAgICAgICAgICBtID0gK2EuYm9yZGVyTGVmdFdpZHRoLnNwbGl0KCdweCcpWzBdLFxyXG4gICAgICAgICAgICBoID0gYyh7XHJcbiAgICAgICAgICAgICAgICB0b3A6IHAudG9wIC0gcy50b3AgLSBsLFxyXG4gICAgICAgICAgICAgICAgbGVmdDogcC5sZWZ0IC0gcy5sZWZ0IC0gbSxcclxuICAgICAgICAgICAgICAgIHdpZHRoOiBwLndpZHRoLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBwLmhlaWdodFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICBpZiAoaC5tYXJnaW5Ub3AgPSAwLCBoLm1hcmdpbkxlZnQgPSAwLCAhaSAmJiByKSB7XHJcbiAgICAgICAgICAgIHZhciB1ID0gK2EubWFyZ2luVG9wLnNwbGl0KCdweCcpWzBdLFxyXG4gICAgICAgICAgICAgICAgYiA9ICthLm1hcmdpbkxlZnQuc3BsaXQoJ3B4JylbMF07XHJcbiAgICAgICAgICAgIGgudG9wIC09IGwgLSB1LCBoLmJvdHRvbSAtPSBsIC0gdSwgaC5sZWZ0IC09IG0gLSBiLCBoLnJpZ2h0IC09IG0gLSBiLCBoLm1hcmdpblRvcCA9IHUsIGgubWFyZ2luTGVmdCA9IGJcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIChpID8gby5jb250YWlucyhkKSA6IG8gPT09IGQgJiYgJ0JPRFknICE9PSBkLm5vZGVOYW1lKSAmJiAoaCA9IGYoaCwgbykpLCBoXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gYihlKSB7XHJcbiAgICAgICAgdmFyIHQgPSB3aW5kb3cuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LFxyXG4gICAgICAgICAgICBvID0gdShlLCB0KSxcclxuICAgICAgICAgICAgaSA9IF8odC5jbGllbnRXaWR0aCwgd2luZG93LmlubmVyV2lkdGggfHwgMCksXHJcbiAgICAgICAgICAgIG4gPSBfKHQuY2xpZW50SGVpZ2h0LCB3aW5kb3cuaW5uZXJIZWlnaHQgfHwgMCksXHJcbiAgICAgICAgICAgIHIgPSBhKHQpLFxyXG4gICAgICAgICAgICBwID0gYSh0LCAnbGVmdCcpLFxyXG4gICAgICAgICAgICBzID0ge1xyXG4gICAgICAgICAgICAgICAgdG9wOiByIC0gby50b3AgKyBvLm1hcmdpblRvcCxcclxuICAgICAgICAgICAgICAgIGxlZnQ6IHAgLSBvLmxlZnQgKyBvLm1hcmdpbkxlZnQsXHJcbiAgICAgICAgICAgICAgICB3aWR0aDogaSxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogblxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBjKHMpXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24geShlKSB7XHJcbiAgICAgICAgdmFyIGkgPSBlLm5vZGVOYW1lO1xyXG4gICAgICAgIHJldHVybiAnQk9EWScgPT09IGkgfHwgJ0hUTUwnID09PSBpID8gITEgOiAnZml4ZWQnID09PSB0KGUsICdwb3NpdGlvbicpIHx8IHkobyhlKSlcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB3KGUsIHQsIGksIHIpIHtcclxuICAgICAgICB2YXIgcCA9IHtcclxuICAgICAgICAgICAgICAgIHRvcDogMCxcclxuICAgICAgICAgICAgICAgIGxlZnQ6IDBcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcyA9IGQoZSwgdCk7XHJcbiAgICAgICAgaWYgKCd2aWV3cG9ydCcgPT09IHIpIHAgPSBiKHMpO1xyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgYTtcclxuICAgICAgICAgICAgJ3Njcm9sbFBhcmVudCcgPT09IHIgPyAoYSA9IG4obyhlKSksICdCT0RZJyA9PT0gYS5ub2RlTmFtZSAmJiAoYSA9IHdpbmRvdy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpKSA6ICd3aW5kb3cnID09PSByID8gYSA9IHdpbmRvdy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgOiBhID0gcjtcclxuICAgICAgICAgICAgdmFyIGYgPSB1KGEsIHMpO1xyXG4gICAgICAgICAgICBpZiAoJ0hUTUwnID09PSBhLm5vZGVOYW1lICYmICF5KHMpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbCA9IGgoKSxcclxuICAgICAgICAgICAgICAgICAgICBtID0gbC5oZWlnaHQsXHJcbiAgICAgICAgICAgICAgICAgICAgYyA9IGwud2lkdGg7XHJcbiAgICAgICAgICAgICAgICBwLnRvcCArPSBmLnRvcCAtIGYubWFyZ2luVG9wLCBwLmJvdHRvbSA9IG0gKyBmLnRvcCwgcC5sZWZ0ICs9IGYubGVmdCAtIGYubWFyZ2luTGVmdCwgcC5yaWdodCA9IGMgKyBmLmxlZnRcclxuICAgICAgICAgICAgfSBlbHNlIHAgPSBmXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwLmxlZnQgKz0gaSwgcC50b3AgKz0gaSwgcC5yaWdodCAtPSBpLCBwLmJvdHRvbSAtPSBpLCBwXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdihlKSB7XHJcbiAgICAgICAgdmFyIHQgPSBlLndpZHRoLFxyXG4gICAgICAgICAgICBvID0gZS5oZWlnaHQ7XHJcbiAgICAgICAgcmV0dXJuIHQgKiBvXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gRShlLCB0LCBvLCBpLCBuKSB7XHJcbiAgICAgICAgdmFyIHIgPSA1IDwgYXJndW1lbnRzLmxlbmd0aCAmJiB2b2lkIDAgIT09IGFyZ3VtZW50c1s1XSA/IGFyZ3VtZW50c1s1XSA6IDA7XHJcbiAgICAgICAgaWYgKC0xID09PSBlLmluZGV4T2YoJ2F1dG8nKSkgcmV0dXJuIGU7XHJcbiAgICAgICAgdmFyIHAgPSB3KG8sIGksIHIsIG4pLFxyXG4gICAgICAgICAgICBzID0ge1xyXG4gICAgICAgICAgICAgICAgdG9wOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHAud2lkdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiB0LnRvcCAtIHAudG9wXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgcmlnaHQ6IHtcclxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogcC5yaWdodCAtIHQucmlnaHQsXHJcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBwLmhlaWdodFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGJvdHRvbToge1xyXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBwLndpZHRoLFxyXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogcC5ib3R0b20gLSB0LmJvdHRvbVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGxlZnQ6IHtcclxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogdC5sZWZ0IC0gcC5sZWZ0LFxyXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogcC5oZWlnaHRcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZCA9IE9iamVjdC5rZXlzKHMpLm1hcChmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2Uoe1xyXG4gICAgICAgICAgICAgICAgICAgIGtleTogZVxyXG4gICAgICAgICAgICAgICAgfSwgc1tlXSwge1xyXG4gICAgICAgICAgICAgICAgICAgIGFyZWE6IHYoc1tlXSlcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIH0pLnNvcnQoZnVuY3Rpb24oZSwgdCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHQuYXJlYSAtIGUuYXJlYVxyXG4gICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgYSA9IGQuZmlsdGVyKGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciB0ID0gZS53aWR0aCxcclxuICAgICAgICAgICAgICAgICAgICBpID0gZS5oZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdCA+PSBvLmNsaWVudFdpZHRoICYmIGkgPj0gby5jbGllbnRIZWlnaHRcclxuICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgIGYgPSAwIDwgYS5sZW5ndGggPyBhWzBdLmtleSA6IGRbMF0ua2V5LFxyXG4gICAgICAgICAgICBsID0gZS5zcGxpdCgnLScpWzFdO1xyXG4gICAgICAgIHJldHVybiBmICsgKGwgPyAnLScgKyBsIDogJycpXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24geChlLCB0LCBvKSB7XHJcbiAgICAgICAgdmFyIGkgPSBkKHQsIG8pO1xyXG4gICAgICAgIHJldHVybiB1KG8sIGkpXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gTyhlKSB7XHJcbiAgICAgICAgdmFyIHQgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlKSxcclxuICAgICAgICAgICAgbyA9IHBhcnNlRmxvYXQodC5tYXJnaW5Ub3ApICsgcGFyc2VGbG9hdCh0Lm1hcmdpbkJvdHRvbSksXHJcbiAgICAgICAgICAgIGkgPSBwYXJzZUZsb2F0KHQubWFyZ2luTGVmdCkgKyBwYXJzZUZsb2F0KHQubWFyZ2luUmlnaHQpLFxyXG4gICAgICAgICAgICBuID0ge1xyXG4gICAgICAgICAgICAgICAgd2lkdGg6IGUub2Zmc2V0V2lkdGggKyBpLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBlLm9mZnNldEhlaWdodCArIG9cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gblxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIEwoZSkge1xyXG4gICAgICAgIHZhciB0ID0ge1xyXG4gICAgICAgICAgICBsZWZ0OiAncmlnaHQnLFxyXG4gICAgICAgICAgICByaWdodDogJ2xlZnQnLFxyXG4gICAgICAgICAgICBib3R0b206ICd0b3AnLFxyXG4gICAgICAgICAgICB0b3A6ICdib3R0b20nXHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gZS5yZXBsYWNlKC9sZWZ0fHJpZ2h0fGJvdHRvbXx0b3AvZywgZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdFtlXVxyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gUyhlLCB0LCBvKSB7XHJcbiAgICAgICAgbyA9IG8uc3BsaXQoJy0nKVswXTtcclxuICAgICAgICB2YXIgaSA9IE8oZSksXHJcbiAgICAgICAgICAgIG4gPSB7XHJcbiAgICAgICAgICAgICAgICB3aWR0aDogaS53aWR0aCxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogaS5oZWlnaHRcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgciA9IC0xICE9PSBbJ3JpZ2h0JywgJ2xlZnQnXS5pbmRleE9mKG8pLFxyXG4gICAgICAgICAgICBwID0gciA/ICd0b3AnIDogJ2xlZnQnLFxyXG4gICAgICAgICAgICBzID0gciA/ICdsZWZ0JyA6ICd0b3AnLFxyXG4gICAgICAgICAgICBkID0gciA/ICdoZWlnaHQnIDogJ3dpZHRoJyxcclxuICAgICAgICAgICAgYSA9IHIgPyAnd2lkdGgnIDogJ2hlaWdodCc7XHJcbiAgICAgICAgcmV0dXJuIG5bcF0gPSB0W3BdICsgdFtkXSAvIDIgLSBpW2RdIC8gMiwgbltzXSA9IG8gPT09IHMgPyB0W3NdIC0gaVthXSA6IHRbTChzKV0sIG5cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBUKGUsIHQpIHtcclxuICAgICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmZpbmQgPyBlLmZpbmQodCkgOiBlLmZpbHRlcih0KVswXVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIEMoZSwgdCwgbykge1xyXG4gICAgICAgIGlmIChBcnJheS5wcm90b3R5cGUuZmluZEluZGV4KSByZXR1cm4gZS5maW5kSW5kZXgoZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZVt0XSA9PT0gb1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHZhciBpID0gVChlLCBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBlW3RdID09PSBvXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGUuaW5kZXhPZihpKVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIE4odCwgbywgaSkge1xyXG4gICAgICAgIHZhciBuID0gdm9pZCAwID09PSBpID8gdCA6IHQuc2xpY2UoMCwgQyh0LCAnbmFtZScsIGkpKTtcclxuICAgICAgICByZXR1cm4gbi5mb3JFYWNoKGZ1bmN0aW9uKHQpIHtcclxuICAgICAgICAgICAgdC5mdW5jdGlvbiAmJiBjb25zb2xlLndhcm4oJ2Btb2RpZmllci5mdW5jdGlvbmAgaXMgZGVwcmVjYXRlZCwgdXNlIGBtb2RpZmllci5mbmAhJyk7XHJcbiAgICAgICAgICAgIHZhciBpID0gdC5mdW5jdGlvbiB8fCB0LmZuO1xyXG4gICAgICAgICAgICB0LmVuYWJsZWQgJiYgZShpKSAmJiAoby5vZmZzZXRzLnBvcHBlciA9IGMoby5vZmZzZXRzLnBvcHBlciksIG8ub2Zmc2V0cy5yZWZlcmVuY2UgPSBjKG8ub2Zmc2V0cy5yZWZlcmVuY2UpLCBvID0gaShvLCB0KSlcclxuICAgICAgICB9KSwgb1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGsoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnN0YXRlLmlzRGVzdHJveWVkKSB7XHJcbiAgICAgICAgICAgIHZhciBlID0ge1xyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2U6IHRoaXMsXHJcbiAgICAgICAgICAgICAgICBzdHlsZXM6IHt9LFxyXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlczoge30sXHJcbiAgICAgICAgICAgICAgICBmbGlwcGVkOiAhMSxcclxuICAgICAgICAgICAgICAgIG9mZnNldHM6IHt9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGUub2Zmc2V0cy5yZWZlcmVuY2UgPSB4KHRoaXMuc3RhdGUsIHRoaXMucG9wcGVyLCB0aGlzLnJlZmVyZW5jZSksIGUucGxhY2VtZW50ID0gRSh0aGlzLm9wdGlvbnMucGxhY2VtZW50LCBlLm9mZnNldHMucmVmZXJlbmNlLCB0aGlzLnBvcHBlciwgdGhpcy5yZWZlcmVuY2UsIHRoaXMub3B0aW9ucy5tb2RpZmllcnMuZmxpcC5ib3VuZGFyaWVzRWxlbWVudCwgdGhpcy5vcHRpb25zLm1vZGlmaWVycy5mbGlwLnBhZGRpbmcpLCBlLm9yaWdpbmFsUGxhY2VtZW50ID0gZS5wbGFjZW1lbnQsIGUub2Zmc2V0cy5wb3BwZXIgPSBTKHRoaXMucG9wcGVyLCBlLm9mZnNldHMucmVmZXJlbmNlLCBlLnBsYWNlbWVudCksIGUub2Zmc2V0cy5wb3BwZXIucG9zaXRpb24gPSAnYWJzb2x1dGUnLCBlID0gTih0aGlzLm1vZGlmaWVycywgZSksIHRoaXMuc3RhdGUuaXNDcmVhdGVkID8gdGhpcy5vcHRpb25zLm9uVXBkYXRlKGUpIDogKHRoaXMuc3RhdGUuaXNDcmVhdGVkID0gITAsIHRoaXMub3B0aW9ucy5vbkNyZWF0ZShlKSlcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gVyhlLCB0KSB7XHJcbiAgICAgICAgcmV0dXJuIGUuc29tZShmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgIHZhciBvID0gZS5uYW1lLFxyXG4gICAgICAgICAgICAgICAgaSA9IGUuZW5hYmxlZDtcclxuICAgICAgICAgICAgcmV0dXJuIGkgJiYgbyA9PT0gdFxyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gQihlKSB7XHJcbiAgICAgICAgZm9yICh2YXIgdCA9IFshMSwgJ21zJywgJ1dlYmtpdCcsICdNb3onLCAnTyddLCBvID0gZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGUuc2xpY2UoMSksIG4gPSAwOyBuIDwgdC5sZW5ndGggLSAxOyBuKyspIHtcclxuICAgICAgICAgICAgdmFyIGkgPSB0W25dLFxyXG4gICAgICAgICAgICAgICAgciA9IGkgPyAnJyArIGkgKyBvIDogZTtcclxuICAgICAgICAgICAgaWYgKCd1bmRlZmluZWQnICE9IHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQuYm9keS5zdHlsZVtyXSkgcmV0dXJuIHJcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGxcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBEKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmlzRGVzdHJveWVkID0gITAsIFcodGhpcy5tb2RpZmllcnMsICdhcHBseVN0eWxlJykgJiYgKHRoaXMucG9wcGVyLnJlbW92ZUF0dHJpYnV0ZSgneC1wbGFjZW1lbnQnKSwgdGhpcy5wb3BwZXIuc3R5bGUubGVmdCA9ICcnLCB0aGlzLnBvcHBlci5zdHlsZS5wb3NpdGlvbiA9ICcnLCB0aGlzLnBvcHBlci5zdHlsZS50b3AgPSAnJywgdGhpcy5wb3BwZXIuc3R5bGVbQigndHJhbnNmb3JtJyldID0gJycpLCB0aGlzLmRpc2FibGVFdmVudExpc3RlbmVycygpLCB0aGlzLm9wdGlvbnMucmVtb3ZlT25EZXN0cm95ICYmIHRoaXMucG9wcGVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5wb3BwZXIpLCB0aGlzXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gSChlLCB0LCBvLCBpKSB7XHJcbiAgICAgICAgdmFyIHIgPSAnQk9EWScgPT09IGUubm9kZU5hbWUsXHJcbiAgICAgICAgICAgIHAgPSByID8gd2luZG93IDogZTtcclxuICAgICAgICBwLmFkZEV2ZW50TGlzdGVuZXIodCwgbywge1xyXG4gICAgICAgICAgICBwYXNzaXZlOiAhMFxyXG4gICAgICAgIH0pLCByIHx8IEgobihwLnBhcmVudE5vZGUpLCB0LCBvLCBpKSwgaS5wdXNoKHApXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gUChlLCB0LCBvLCBpKSB7XHJcbiAgICAgICAgby51cGRhdGVCb3VuZCA9IGksIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBvLnVwZGF0ZUJvdW5kLCB7XHJcbiAgICAgICAgICAgIHBhc3NpdmU6ICEwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdmFyIHIgPSBuKGUpO1xyXG4gICAgICAgIHJldHVybiBIKHIsICdzY3JvbGwnLCBvLnVwZGF0ZUJvdW5kLCBvLnNjcm9sbFBhcmVudHMpLCBvLnNjcm9sbEVsZW1lbnQgPSByLCBvLmV2ZW50c0VuYWJsZWQgPSAhMCwgb1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIEEoKSB7XHJcbiAgICAgICAgdGhpcy5zdGF0ZS5ldmVudHNFbmFibGVkIHx8ICh0aGlzLnN0YXRlID0gUCh0aGlzLnJlZmVyZW5jZSwgdGhpcy5vcHRpb25zLCB0aGlzLnN0YXRlLCB0aGlzLnNjaGVkdWxlVXBkYXRlKSlcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBNKGUsIHQpIHtcclxuICAgICAgICByZXR1cm4gd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHQudXBkYXRlQm91bmQpLCB0LnNjcm9sbFBhcmVudHMuZm9yRWFjaChmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgIGUucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdC51cGRhdGVCb3VuZClcclxuICAgICAgICB9KSwgdC51cGRhdGVCb3VuZCA9IG51bGwsIHQuc2Nyb2xsUGFyZW50cyA9IFtdLCB0LnNjcm9sbEVsZW1lbnQgPSBudWxsLCB0LmV2ZW50c0VuYWJsZWQgPSAhMSwgdFxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIEkoKSB7XHJcbiAgICAgICAgdGhpcy5zdGF0ZS5ldmVudHNFbmFibGVkICYmICh3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5zY2hlZHVsZVVwZGF0ZSksIHRoaXMuc3RhdGUgPSBNKHRoaXMucmVmZXJlbmNlLCB0aGlzLnN0YXRlKSlcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBSKGUpIHtcclxuICAgICAgICByZXR1cm4gJycgIT09IGUgJiYgIWlzTmFOKHBhcnNlRmxvYXQoZSkpICYmIGlzRmluaXRlKGUpXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gVShlLCB0KSB7XHJcbiAgICAgICAgT2JqZWN0LmtleXModCkuZm9yRWFjaChmdW5jdGlvbihvKSB7XHJcbiAgICAgICAgICAgIHZhciBpID0gJyc7IC0gMSAhPT0gWyd3aWR0aCcsICdoZWlnaHQnLCAndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbScsICdsZWZ0J10uaW5kZXhPZihvKSAmJiBSKHRbb10pICYmIChpID0gJ3B4JyksIGUuc3R5bGVbb10gPSB0W29dICsgaVxyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gWShlLCB0KSB7XHJcbiAgICAgICAgT2JqZWN0LmtleXModCkuZm9yRWFjaChmdW5jdGlvbihvKSB7XHJcbiAgICAgICAgICAgIHZhciBpID0gdFtvXTtcclxuICAgICAgICAgICAgITEgPT09IGkgPyBlLnJlbW92ZUF0dHJpYnV0ZShvKSA6IGUuc2V0QXR0cmlidXRlKG8sIHRbb10pXHJcbiAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBGKGUsIHQsIG8pIHtcclxuICAgICAgICB2YXIgaSA9IFQoZSwgZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG8gPSBlLm5hbWU7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbyA9PT0gdFxyXG4gICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgbiA9ICEhaSAmJiBlLnNvbWUoZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGUubmFtZSA9PT0gbyAmJiBlLmVuYWJsZWQgJiYgZS5vcmRlciA8IGkub3JkZXJcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKCFuKSB7XHJcbiAgICAgICAgICAgIHZhciByID0gJ2AnICsgdCArICdgJztcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKCdgJyArIG8gKyAnYCcgKyAnIG1vZGlmaWVyIGlzIHJlcXVpcmVkIGJ5ICcgKyByICsgJyBtb2RpZmllciBpbiBvcmRlciB0byB3b3JrLCBiZSBzdXJlIHRvIGluY2x1ZGUgaXQgYmVmb3JlICcgKyByICsgJyEnKVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gblxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGooZSkge1xyXG4gICAgICAgIHJldHVybiAnZW5kJyA9PT0gZSA/ICdzdGFydCcgOiAnc3RhcnQnID09PSBlID8gJ2VuZCcgOiBlXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gSyhlKSB7XHJcbiAgICAgICAgdmFyIHQgPSAxIDwgYXJndW1lbnRzLmxlbmd0aCAmJiB2b2lkIDAgIT09IGFyZ3VtZW50c1sxXSAmJiBhcmd1bWVudHNbMV0sXHJcbiAgICAgICAgICAgIG8gPSBhZS5pbmRleE9mKGUpLFxyXG4gICAgICAgICAgICBpID0gYWUuc2xpY2UobyArIDEpLmNvbmNhdChhZS5zbGljZSgwLCBvKSk7XHJcbiAgICAgICAgcmV0dXJuIHQgPyBpLnJldmVyc2UoKSA6IGlcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBxKGUsIHQsIG8sIGkpIHtcclxuICAgICAgICB2YXIgbiA9IGUubWF0Y2goLygoPzpcXC18XFwrKT9cXGQqXFwuP1xcZCopKC4qKS8pLFxyXG4gICAgICAgICAgICByID0gK25bMV0sXHJcbiAgICAgICAgICAgIHAgPSBuWzJdO1xyXG4gICAgICAgIGlmICghcikgcmV0dXJuIGU7XHJcbiAgICAgICAgaWYgKDAgPT09IHAuaW5kZXhPZignJScpKSB7XHJcbiAgICAgICAgICAgIHZhciBzO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKHApIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgJyVwJzpcclxuICAgICAgICAgICAgICAgICAgICBzID0gbztcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJyUnOlxyXG4gICAgICAgICAgICAgICAgY2FzZSAnJXInOlxyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBzID0gaTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgZCA9IGMocyk7XHJcbiAgICAgICAgICAgIHJldHVybiBkW3RdIC8gMTAwICogclxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoJ3ZoJyA9PT0gcCB8fCAndncnID09PSBwKSB7XHJcbiAgICAgICAgICAgIHZhciBhO1xyXG4gICAgICAgICAgICByZXR1cm4gYSA9ICd2aCcgPT09IHAgPyBfKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQsIHdpbmRvdy5pbm5lckhlaWdodCB8fCAwKSA6IF8oZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoLCB3aW5kb3cuaW5uZXJXaWR0aCB8fCAwKSwgYSAvIDEwMCAqIHJcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBHKGUsIHQsIG8sIGkpIHtcclxuICAgICAgICB2YXIgbiA9IFswLCAwXSxcclxuICAgICAgICAgICAgciA9IC0xICE9PSBbJ3JpZ2h0JywgJ2xlZnQnXS5pbmRleE9mKGkpLFxyXG4gICAgICAgICAgICBwID0gZS5zcGxpdCgvKFxcK3xcXC0pLykubWFwKGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBlLnRyaW0oKVxyXG4gICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgcyA9IHAuaW5kZXhPZihUKHAsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAtMSAhPT0gZS5zZWFyY2goLyx8XFxzLylcclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgIHBbc10gJiYgLTEgPT09IHBbc10uaW5kZXhPZignLCcpICYmIGNvbnNvbGUud2FybignT2Zmc2V0cyBzZXBhcmF0ZWQgYnkgd2hpdGUgc3BhY2UocykgYXJlIGRlcHJlY2F0ZWQsIHVzZSBhIGNvbW1hICgsKSBpbnN0ZWFkLicpO1xyXG4gICAgICAgIHZhciBkID0gL1xccyosXFxzKnxcXHMrLyxcclxuICAgICAgICAgICAgYSA9IC0xID09PSBzID8gW3BdIDogW3Auc2xpY2UoMCwgcykuY29uY2F0KFtwW3NdLnNwbGl0KGQpWzBdXSksIFtwW3NdLnNwbGl0KGQpWzFdXS5jb25jYXQocC5zbGljZShzICsgMSkpXTtcclxuICAgICAgICByZXR1cm4gYSA9IGEubWFwKGZ1bmN0aW9uKGUsIGkpIHtcclxuICAgICAgICAgICAgdmFyIG4gPSAoMSA9PT0gaSA/ICFyIDogcikgPyAnaGVpZ2h0JyA6ICd3aWR0aCcsXHJcbiAgICAgICAgICAgICAgICBwID0gITE7XHJcbiAgICAgICAgICAgIHJldHVybiBlLnJlZHVjZShmdW5jdGlvbihlLCB0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJycgPT09IGVbZS5sZW5ndGggLSAxXSAmJiAtMSAhPT0gWycrJywgJy0nXS5pbmRleE9mKHQpID8gKGVbZS5sZW5ndGggLSAxXSA9IHQsIHAgPSAhMCwgZSkgOiBwID8gKGVbZS5sZW5ndGggLSAxXSArPSB0LCBwID0gITEsIGUpIDogZS5jb25jYXQodClcclxuICAgICAgICAgICAgfSwgW10pLm1hcChmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcShlLCBuLCB0LCBvKVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH0pLCBhLmZvckVhY2goZnVuY3Rpb24oZSwgdCkge1xyXG4gICAgICAgICAgICBlLmZvckVhY2goZnVuY3Rpb24obywgaSkge1xyXG4gICAgICAgICAgICAgICAgUihvKSAmJiAoblt0XSArPSBvICogKCctJyA9PT0gZVtpIC0gMV0gPyAtMSA6IDEpKVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH0pLCBuXHJcbiAgICB9XHJcbiAgICBmb3IgKHZhciB6ID0gTWF0aC5taW4sIFYgPSBNYXRoLmZsb29yLCBfID0gTWF0aC5tYXgsIFggPSBbJ25hdGl2ZSBjb2RlJywgJ1tvYmplY3QgTXV0YXRpb25PYnNlcnZlckNvbnN0cnVjdG9yXSddLCBRID0gZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gWC5zb21lKGZ1bmN0aW9uKHQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAtMSA8IChlIHx8ICcnKS50b1N0cmluZygpLmluZGV4T2YodClcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9LCBKID0gJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIHdpbmRvdywgWiA9IFsnRWRnZScsICdUcmlkZW50JywgJ0ZpcmVmb3gnXSwgJCA9IDAsIGVlID0gMDsgZWUgPCBaLmxlbmd0aDsgZWUgKz0gMSlcclxuICAgICAgICBpZiAoSiAmJiAwIDw9IG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZihaW2VlXSkpIHtcclxuICAgICAgICAgICAgJCA9IDE7XHJcbiAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgfVxyXG4gICAgdmFyIGksIHRlID0gSiAmJiBRKHdpbmRvdy5NdXRhdGlvbk9ic2VydmVyKSxcclxuICAgICAgICBvZSA9IHRlID8gZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICB2YXIgdCA9ICExLFxyXG4gICAgICAgICAgICAgICAgbyA9IDAsXHJcbiAgICAgICAgICAgICAgICBpID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpLFxyXG4gICAgICAgICAgICAgICAgbiA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGUoKSwgdCA9ICExXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIG4ub2JzZXJ2ZShpLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczogITBcclxuICAgICAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdCB8fCAodCA9ICEwLCBpLnNldEF0dHJpYnV0ZSgneC1pbmRleCcsIG8pLCArK28pXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgfSA6IGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgdmFyIHQgPSAhMTtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgdCB8fCAodCA9ICEwLCBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHQgPSAhMSwgZSgpXHJcbiAgICAgICAgICAgICAgICB9LCAkKSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaWUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHZvaWQgMCA9PSBpICYmIChpID0gLTEgIT09IG5hdmlnYXRvci5hcHBWZXJzaW9uLmluZGV4T2YoJ01TSUUgMTAnKSksIGlcclxuICAgICAgICB9LFxyXG4gICAgICAgIG5lID0gZnVuY3Rpb24oZSwgdCkge1xyXG4gICAgICAgICAgICBpZiAoIShlIGluc3RhbmNlb2YgdCkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpXHJcbiAgICAgICAgfSxcclxuICAgICAgICByZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBlKGUsIHQpIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIG8sIG4gPSAwOyBuIDwgdC5sZW5ndGg7IG4rKykgbyA9IHRbbl0sIG8uZW51bWVyYWJsZSA9IG8uZW51bWVyYWJsZSB8fCAhMSwgby5jb25maWd1cmFibGUgPSAhMCwgJ3ZhbHVlJyBpbiBvICYmIChvLndyaXRhYmxlID0gITApLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgby5rZXksIG8pXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHQsIG8sIGkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBvICYmIGUodC5wcm90b3R5cGUsIG8pLCBpICYmIGUodCwgaSksIHRcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0oKSxcclxuICAgICAgICBwZSA9IGZ1bmN0aW9uKGUsIHQsIG8pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHQgaW4gZSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCB0LCB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogbyxcclxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxyXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiAhMCxcclxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiAhMFxyXG4gICAgICAgICAgICB9KSA6IGVbdF0gPSBvLCBlXHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZSA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciB0LCBvID0gMTsgbyA8IGFyZ3VtZW50cy5sZW5ndGg7IG8rKylcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgaW4gdCA9IGFyZ3VtZW50c1tvXSwgdCkgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsIGkpICYmIChlW2ldID0gdFtpXSk7XHJcbiAgICAgICAgICAgIHJldHVybiBlXHJcbiAgICAgICAgfSxcclxuICAgICAgICBkZSA9IFsnYXV0by1zdGFydCcsICdhdXRvJywgJ2F1dG8tZW5kJywgJ3RvcC1zdGFydCcsICd0b3AnLCAndG9wLWVuZCcsICdyaWdodC1zdGFydCcsICdyaWdodCcsICdyaWdodC1lbmQnLCAnYm90dG9tLWVuZCcsICdib3R0b20nLCAnYm90dG9tLXN0YXJ0JywgJ2xlZnQtZW5kJywgJ2xlZnQnLCAnbGVmdC1zdGFydCddLFxyXG4gICAgICAgIGFlID0gZGUuc2xpY2UoMyksXHJcbiAgICAgICAgZmUgPSB7XHJcbiAgICAgICAgICAgIEZMSVA6ICdmbGlwJyxcclxuICAgICAgICAgICAgQ0xPQ0tXSVNFOiAnY2xvY2t3aXNlJyxcclxuICAgICAgICAgICAgQ09VTlRFUkNMT0NLV0lTRTogJ2NvdW50ZXJjbG9ja3dpc2UnXHJcbiAgICAgICAgfSxcclxuICAgICAgICBsZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBmdW5jdGlvbiB0KG8sIGkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBuID0gdGhpcyxcclxuICAgICAgICAgICAgICAgICAgICByID0gMiA8IGFyZ3VtZW50cy5sZW5ndGggJiYgdm9pZCAwICE9PSBhcmd1bWVudHNbMl0gPyBhcmd1bWVudHNbMl0gOiB7fTtcclxuICAgICAgICAgICAgICAgIG5lKHRoaXMsIHQpLCB0aGlzLnNjaGVkdWxlVXBkYXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3RBbmltYXRpb25GcmFtZShuLnVwZGF0ZSlcclxuICAgICAgICAgICAgICAgIH0sIHRoaXMudXBkYXRlID0gb2UodGhpcy51cGRhdGUuYmluZCh0aGlzKSksIHRoaXMub3B0aW9ucyA9IHNlKHt9LCB0LkRlZmF1bHRzLCByKSwgdGhpcy5zdGF0ZSA9IHtcclxuICAgICAgICAgICAgICAgICAgICBpc0Rlc3Ryb3llZDogITEsXHJcbiAgICAgICAgICAgICAgICAgICAgaXNDcmVhdGVkOiAhMSxcclxuICAgICAgICAgICAgICAgICAgICBzY3JvbGxQYXJlbnRzOiBbXVxyXG4gICAgICAgICAgICAgICAgfSwgdGhpcy5yZWZlcmVuY2UgPSBvLmpxdWVyeSA/IG9bMF0gOiBvLCB0aGlzLnBvcHBlciA9IGkuanF1ZXJ5ID8gaVswXSA6IGksIHRoaXMub3B0aW9ucy5tb2RpZmllcnMgPSB7fSwgT2JqZWN0LmtleXMoc2Uoe30sIHQuRGVmYXVsdHMubW9kaWZpZXJzLCByLm1vZGlmaWVycykpLmZvckVhY2goZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG4ub3B0aW9ucy5tb2RpZmllcnNbZV0gPSBzZSh7fSwgdC5EZWZhdWx0cy5tb2RpZmllcnNbZV0gfHwge30sIHIubW9kaWZpZXJzID8gci5tb2RpZmllcnNbZV0gOiB7fSlcclxuICAgICAgICAgICAgICAgIH0pLCB0aGlzLm1vZGlmaWVycyA9IE9iamVjdC5rZXlzKHRoaXMub3B0aW9ucy5tb2RpZmllcnMpLm1hcChmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogZVxyXG4gICAgICAgICAgICAgICAgICAgIH0sIG4ub3B0aW9ucy5tb2RpZmllcnNbZV0pXHJcbiAgICAgICAgICAgICAgICB9KS5zb3J0KGZ1bmN0aW9uKGUsIHQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZS5vcmRlciAtIHQub3JkZXJcclxuICAgICAgICAgICAgICAgIH0pLCB0aGlzLm1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uKHQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0LmVuYWJsZWQgJiYgZSh0Lm9uTG9hZCkgJiYgdC5vbkxvYWQobi5yZWZlcmVuY2UsIG4ucG9wcGVyLCBuLm9wdGlvbnMsIHQsIG4uc3RhdGUpXHJcbiAgICAgICAgICAgICAgICB9KSwgdGhpcy51cGRhdGUoKTtcclxuICAgICAgICAgICAgICAgIHZhciBwID0gdGhpcy5vcHRpb25zLmV2ZW50c0VuYWJsZWQ7XHJcbiAgICAgICAgICAgICAgICBwICYmIHRoaXMuZW5hYmxlRXZlbnRMaXN0ZW5lcnMoKSwgdGhpcy5zdGF0ZS5ldmVudHNFbmFibGVkID0gcFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZSh0LCBbe1xyXG4gICAgICAgICAgICAgICAga2V5OiAndXBkYXRlJyxcclxuICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gay5jYWxsKHRoaXMpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIHtcclxuICAgICAgICAgICAgICAgIGtleTogJ2Rlc3Ryb3knLFxyXG4gICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBELmNhbGwodGhpcylcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwge1xyXG4gICAgICAgICAgICAgICAga2V5OiAnZW5hYmxlRXZlbnRMaXN0ZW5lcnMnLFxyXG4gICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBBLmNhbGwodGhpcylcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwge1xyXG4gICAgICAgICAgICAgICAga2V5OiAnZGlzYWJsZUV2ZW50TGlzdGVuZXJzJyxcclxuICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSS5jYWxsKHRoaXMpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1dKSwgdFxyXG4gICAgICAgIH0oKTtcclxuICAgIHJldHVybiBsZS5VdGlscyA9ICgndW5kZWZpbmVkJyA9PSB0eXBlb2Ygd2luZG93ID8gZ2xvYmFsIDogd2luZG93KS5Qb3BwZXJVdGlscywgbGUucGxhY2VtZW50cyA9IGRlLCBsZS5EZWZhdWx0cyA9IHtcclxuICAgICAgICBwbGFjZW1lbnQ6ICdib3R0b20nLFxyXG4gICAgICAgIGV2ZW50c0VuYWJsZWQ6ICEwLFxyXG4gICAgICAgIHJlbW92ZU9uRGVzdHJveTogITEsXHJcbiAgICAgICAgb25DcmVhdGU6IGZ1bmN0aW9uKCkge30sXHJcbiAgICAgICAgb25VcGRhdGU6IGZ1bmN0aW9uKCkge30sXHJcbiAgICAgICAgbW9kaWZpZXJzOiB7XHJcbiAgICAgICAgICAgIHNoaWZ0OiB7XHJcbiAgICAgICAgICAgICAgICBvcmRlcjogMTAwLFxyXG4gICAgICAgICAgICAgICAgZW5hYmxlZDogITAsXHJcbiAgICAgICAgICAgICAgICBmbjogZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ID0gZS5wbGFjZW1lbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG8gPSB0LnNwbGl0KCctJylbMF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgPSB0LnNwbGl0KCctJylbMV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBlLm9mZnNldHMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByID0gbi5yZWZlcmVuY2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwID0gbi5wb3BwZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzID0gLTEgIT09IFsnYm90dG9tJywgJ3RvcCddLmluZGV4T2YobyksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkID0gcyA/ICdsZWZ0JyA6ICd0b3AnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYSA9IHMgPyAnd2lkdGgnIDogJ2hlaWdodCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBwZSh7fSwgZCwgcltkXSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBwZSh7fSwgZCwgcltkXSArIHJbYV0gLSBwW2FdKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZS5vZmZzZXRzLnBvcHBlciA9IHNlKHt9LCBwLCBmW2ldKVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBvZmZzZXQ6IHtcclxuICAgICAgICAgICAgICAgIG9yZGVyOiAyMDAsXHJcbiAgICAgICAgICAgICAgICBlbmFibGVkOiAhMCxcclxuICAgICAgICAgICAgICAgIGZuOiBmdW5jdGlvbihlLCB0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG8sIGkgPSB0Lm9mZnNldCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbiA9IGUucGxhY2VtZW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByID0gZS5vZmZzZXRzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwID0gci5wb3BwZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHMgPSByLnJlZmVyZW5jZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZCA9IG4uc3BsaXQoJy0nKVswXTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbyA9IFIoK2kpID8gWytpLCAwXSA6IEcoaSwgcCwgcywgZCksICdsZWZ0JyA9PT0gZCA/IChwLnRvcCArPSBvWzBdLCBwLmxlZnQgLT0gb1sxXSkgOiAncmlnaHQnID09PSBkID8gKHAudG9wICs9IG9bMF0sIHAubGVmdCArPSBvWzFdKSA6ICd0b3AnID09PSBkID8gKHAubGVmdCArPSBvWzBdLCBwLnRvcCAtPSBvWzFdKSA6ICdib3R0b20nID09PSBkICYmIChwLmxlZnQgKz0gb1swXSwgcC50b3AgKz0gb1sxXSksIGUucG9wcGVyID0gcCwgZVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIG9mZnNldDogMFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBwcmV2ZW50T3ZlcmZsb3c6IHtcclxuICAgICAgICAgICAgICAgIG9yZGVyOiAzMDAsXHJcbiAgICAgICAgICAgICAgICBlbmFibGVkOiAhMCxcclxuICAgICAgICAgICAgICAgIGZuOiBmdW5jdGlvbihlLCB0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG8gPSB0LmJvdW5kYXJpZXNFbGVtZW50IHx8IHIoZS5pbnN0YW5jZS5wb3BwZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGUuaW5zdGFuY2UucmVmZXJlbmNlID09PSBvICYmIChvID0gcihvKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSB3KGUuaW5zdGFuY2UucG9wcGVyLCBlLmluc3RhbmNlLnJlZmVyZW5jZSwgdC5wYWRkaW5nLCBvKTtcclxuICAgICAgICAgICAgICAgICAgICB0LmJvdW5kYXJpZXMgPSBpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBuID0gdC5wcmlvcml0eSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcCA9IGUub2Zmc2V0cy5wb3BwZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHMgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmltYXJ5OiBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG8gPSBwW2VdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwW2VdIDwgaVtlXSAmJiAhdC5lc2NhcGVXaXRoUmVmZXJlbmNlICYmIChvID0gXyhwW2VdLCBpW2VdKSksIHBlKHt9LCBlLCBvKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlY29uZGFyeTogZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvID0gJ3JpZ2h0JyA9PT0gZSA/ICdsZWZ0JyA6ICd0b3AnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuID0gcFtvXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcFtlXSA+IGlbZV0gJiYgIXQuZXNjYXBlV2l0aFJlZmVyZW5jZSAmJiAobiA9IHoocFtvXSwgaVtlXSAtICgncmlnaHQnID09PSBlID8gcC53aWR0aCA6IHAuaGVpZ2h0KSkpLCBwZSh7fSwgbywgbilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbi5mb3JFYWNoKGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSAtMSA9PT0gWydsZWZ0JywgJ3RvcCddLmluZGV4T2YoZSkgPyAnc2Vjb25kYXJ5JyA6ICdwcmltYXJ5JztcclxuICAgICAgICAgICAgICAgICAgICAgICAgcCA9IHNlKHt9LCBwLCBzW3RdKGUpKVxyXG4gICAgICAgICAgICAgICAgICAgIH0pLCBlLm9mZnNldHMucG9wcGVyID0gcCwgZVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHByaW9yaXR5OiBbJ2xlZnQnLCAncmlnaHQnLCAndG9wJywgJ2JvdHRvbSddLFxyXG4gICAgICAgICAgICAgICAgcGFkZGluZzogNSxcclxuICAgICAgICAgICAgICAgIGJvdW5kYXJpZXNFbGVtZW50OiAnc2Nyb2xsUGFyZW50J1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBrZWVwVG9nZXRoZXI6IHtcclxuICAgICAgICAgICAgICAgIG9yZGVyOiA0MDAsXHJcbiAgICAgICAgICAgICAgICBlbmFibGVkOiAhMCxcclxuICAgICAgICAgICAgICAgIGZuOiBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBlLm9mZnNldHMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG8gPSB0LnBvcHBlcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgaSA9IHQucmVmZXJlbmNlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuID0gZS5wbGFjZW1lbnQuc3BsaXQoJy0nKVswXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgciA9IFYsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHAgPSAtMSAhPT0gWyd0b3AnLCAnYm90dG9tJ10uaW5kZXhPZihuKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcyA9IHAgPyAncmlnaHQnIDogJ2JvdHRvbScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGQgPSBwID8gJ2xlZnQnIDogJ3RvcCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGEgPSBwID8gJ3dpZHRoJyA6ICdoZWlnaHQnO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvW3NdIDwgcihpW2RdKSAmJiAoZS5vZmZzZXRzLnBvcHBlcltkXSA9IHIoaVtkXSkgLSBvW2FdKSwgb1tkXSA+IHIoaVtzXSkgJiYgKGUub2Zmc2V0cy5wb3BwZXJbZF0gPSByKGlbc10pKSwgZVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBhcnJvdzoge1xyXG4gICAgICAgICAgICAgICAgb3JkZXI6IDUwMCxcclxuICAgICAgICAgICAgICAgIGVuYWJsZWQ6ICEwLFxyXG4gICAgICAgICAgICAgICAgZm46IGZ1bmN0aW9uKGUsIHQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIUYoZS5pbnN0YW5jZS5tb2RpZmllcnMsICdhcnJvdycsICdrZWVwVG9nZXRoZXInKSkgcmV0dXJuIGU7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG8gPSB0LmVsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCdzdHJpbmcnID09IHR5cGVvZiBvKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvID0gZS5pbnN0YW5jZS5wb3BwZXIucXVlcnlTZWxlY3RvcihvKSwgIW8pIHJldHVybiBlO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWUuaW5zdGFuY2UucG9wcGVyLmNvbnRhaW5zKG8pKSByZXR1cm4gY29uc29sZS53YXJuKCdXQVJOSU5HOiBgYXJyb3cuZWxlbWVudGAgbXVzdCBiZSBjaGlsZCBvZiBpdHMgcG9wcGVyIGVsZW1lbnQhJyksIGU7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSBlLnBsYWNlbWVudC5zcGxpdCgnLScpWzBdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuID0gZS5vZmZzZXRzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByID0gbi5wb3BwZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHAgPSBuLnJlZmVyZW5jZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcyA9IC0xICE9PSBbJ2xlZnQnLCAncmlnaHQnXS5pbmRleE9mKGkpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkID0gcyA/ICdoZWlnaHQnIDogJ3dpZHRoJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYSA9IHMgPyAndG9wJyA6ICdsZWZ0JyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZiA9IHMgPyAnbGVmdCcgOiAndG9wJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbCA9IHMgPyAnYm90dG9tJyA6ICdyaWdodCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG0gPSBPKG8pW2RdO1xyXG4gICAgICAgICAgICAgICAgICAgIHBbbF0gLSBtIDwgclthXSAmJiAoZS5vZmZzZXRzLnBvcHBlclthXSAtPSByW2FdIC0gKHBbbF0gLSBtKSksIHBbYV0gKyBtID4gcltsXSAmJiAoZS5vZmZzZXRzLnBvcHBlclthXSArPSBwW2FdICsgbSAtIHJbbF0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBoID0gcFthXSArIHBbZF0gLyAyIC0gbSAvIDIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGcgPSBoIC0gYyhlLm9mZnNldHMucG9wcGVyKVthXTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZyA9IF8oeihyW2RdIC0gbSwgZyksIDApLCBlLmFycm93RWxlbWVudCA9IG8sIGUub2Zmc2V0cy5hcnJvdyA9IHt9LCBlLm9mZnNldHMuYXJyb3dbYV0gPSBNYXRoLnJvdW5kKGcpLCBlLm9mZnNldHMuYXJyb3dbZl0gPSAnJywgZVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGVsZW1lbnQ6ICdbeC1hcnJvd10nXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGZsaXA6IHtcclxuICAgICAgICAgICAgICAgIG9yZGVyOiA2MDAsXHJcbiAgICAgICAgICAgICAgICBlbmFibGVkOiAhMCxcclxuICAgICAgICAgICAgICAgIGZuOiBmdW5jdGlvbihlLCB0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKFcoZS5pbnN0YW5jZS5tb2RpZmllcnMsICdpbm5lcicpKSByZXR1cm4gZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZS5mbGlwcGVkICYmIGUucGxhY2VtZW50ID09PSBlLm9yaWdpbmFsUGxhY2VtZW50KSByZXR1cm4gZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbyA9IHcoZS5pbnN0YW5jZS5wb3BwZXIsIGUuaW5zdGFuY2UucmVmZXJlbmNlLCB0LnBhZGRpbmcsIHQuYm91bmRhcmllc0VsZW1lbnQpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpID0gZS5wbGFjZW1lbnQuc3BsaXQoJy0nKVswXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbiA9IEwoaSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHIgPSBlLnBsYWNlbWVudC5zcGxpdCgnLScpWzFdIHx8ICcnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0LmJlaGF2aW9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgZmUuRkxJUDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAgPSBbaSwgbl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBmZS5DTE9DS1dJU0U6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwID0gSyhpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGZlLkNPVU5URVJDTE9DS1dJU0U6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwID0gSyhpLCAhMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAgPSB0LmJlaGF2aW9yO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcC5mb3JFYWNoKGZ1bmN0aW9uKHMsIGQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgIT09IHMgfHwgcC5sZW5ndGggPT09IGQgKyAxKSByZXR1cm4gZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaSA9IGUucGxhY2VtZW50LnNwbGl0KCctJylbMF0sIG4gPSBMKGkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IGUub2Zmc2V0cy5wb3BwZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmID0gZS5vZmZzZXRzLnJlZmVyZW5jZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGwgPSBWLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbSA9ICdsZWZ0JyA9PT0gaSAmJiBsKGEucmlnaHQpID4gbChmLmxlZnQpIHx8ICdyaWdodCcgPT09IGkgJiYgbChhLmxlZnQpIDwgbChmLnJpZ2h0KSB8fCAndG9wJyA9PT0gaSAmJiBsKGEuYm90dG9tKSA+IGwoZi50b3ApIHx8ICdib3R0b20nID09PSBpICYmIGwoYS50b3ApIDwgbChmLmJvdHRvbSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoID0gbChhLmxlZnQpIDwgbChvLmxlZnQpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYyA9IGwoYS5yaWdodCkgPiBsKG8ucmlnaHQpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZyA9IGwoYS50b3ApIDwgbChvLnRvcCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1ID0gbChhLmJvdHRvbSkgPiBsKG8uYm90dG9tKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIgPSAnbGVmdCcgPT09IGkgJiYgaCB8fCAncmlnaHQnID09PSBpICYmIGMgfHwgJ3RvcCcgPT09IGkgJiYgZyB8fCAnYm90dG9tJyA9PT0gaSAmJiB1LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeSA9IC0xICE9PSBbJ3RvcCcsICdib3R0b20nXS5pbmRleE9mKGkpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdyA9ICEhdC5mbGlwVmFyaWF0aW9ucyAmJiAoeSAmJiAnc3RhcnQnID09PSByICYmIGggfHwgeSAmJiAnZW5kJyA9PT0gciAmJiBjIHx8ICF5ICYmICdzdGFydCcgPT09IHIgJiYgZyB8fCAheSAmJiAnZW5kJyA9PT0gciAmJiB1KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgKG0gfHwgYiB8fCB3KSAmJiAoZS5mbGlwcGVkID0gITAsIChtIHx8IGIpICYmIChpID0gcFtkICsgMV0pLCB3ICYmIChyID0gaihyKSksIGUucGxhY2VtZW50ID0gaSArIChyID8gJy0nICsgciA6ICcnKSwgZS5vZmZzZXRzLnBvcHBlciA9IHNlKHt9LCBlLm9mZnNldHMucG9wcGVyLCBTKGUuaW5zdGFuY2UucG9wcGVyLCBlLm9mZnNldHMucmVmZXJlbmNlLCBlLnBsYWNlbWVudCkpLCBlID0gTihlLmluc3RhbmNlLm1vZGlmaWVycywgZSwgJ2ZsaXAnKSlcclxuICAgICAgICAgICAgICAgICAgICB9KSwgZVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGJlaGF2aW9yOiAnZmxpcCcsXHJcbiAgICAgICAgICAgICAgICBwYWRkaW5nOiA1LFxyXG4gICAgICAgICAgICAgICAgYm91bmRhcmllc0VsZW1lbnQ6ICd2aWV3cG9ydCdcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgaW5uZXI6IHtcclxuICAgICAgICAgICAgICAgIG9yZGVyOiA3MDAsXHJcbiAgICAgICAgICAgICAgICBlbmFibGVkOiAhMSxcclxuICAgICAgICAgICAgICAgIGZuOiBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBlLnBsYWNlbWVudCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbyA9IHQuc3BsaXQoJy0nKVswXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaSA9IGUub2Zmc2V0cyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbiA9IGkucG9wcGVyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByID0gaS5yZWZlcmVuY2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHAgPSAtMSAhPT0gWydsZWZ0JywgJ3JpZ2h0J10uaW5kZXhPZihvKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcyA9IC0xID09PSBbJ3RvcCcsICdsZWZ0J10uaW5kZXhPZihvKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbltwID8gJ2xlZnQnIDogJ3RvcCddID0gclt0XSAtIChzID8gbltwID8gJ3dpZHRoJyA6ICdoZWlnaHQnXSA6IDApLCBlLnBsYWNlbWVudCA9IEwodCksIGUub2Zmc2V0cy5wb3BwZXIgPSBjKG4pLCBlXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGhpZGU6IHtcclxuICAgICAgICAgICAgICAgIG9yZGVyOiA4MDAsXHJcbiAgICAgICAgICAgICAgICBlbmFibGVkOiAhMCxcclxuICAgICAgICAgICAgICAgIGZuOiBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFGKGUuaW5zdGFuY2UubW9kaWZpZXJzLCAnaGlkZScsICdwcmV2ZW50T3ZlcmZsb3cnKSkgcmV0dXJuIGU7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBlLm9mZnNldHMucmVmZXJlbmNlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvID0gVChlLmluc3RhbmNlLm1vZGlmaWVycywgZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdwcmV2ZW50T3ZlcmZsb3cnID09PSBlLm5hbWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSkuYm91bmRhcmllcztcclxuICAgICAgICAgICAgICAgICAgICBpZiAodC5ib3R0b20gPCBvLnRvcCB8fCB0LmxlZnQgPiBvLnJpZ2h0IHx8IHQudG9wID4gby5ib3R0b20gfHwgdC5yaWdodCA8IG8ubGVmdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoITAgPT09IGUuaGlkZSkgcmV0dXJuIGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuaGlkZSA9ICEwLCBlLmF0dHJpYnV0ZXNbJ3gtb3V0LW9mLWJvdW5kYXJpZXMnXSA9ICcnXHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCExID09PSBlLmhpZGUpIHJldHVybiBlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlLmhpZGUgPSAhMSwgZS5hdHRyaWJ1dGVzWyd4LW91dC1vZi1ib3VuZGFyaWVzJ10gPSAhMVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBjb21wdXRlU3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIG9yZGVyOiA4NTAsXHJcbiAgICAgICAgICAgICAgICBlbmFibGVkOiAhMCxcclxuICAgICAgICAgICAgICAgIGZuOiBmdW5jdGlvbihlLCB0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG8gPSB0LngsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgPSB0LnksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG4gPSBlLm9mZnNldHMucG9wcGVyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwID0gVChlLmluc3RhbmNlLm1vZGlmaWVycywgZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdhcHBseVN0eWxlJyA9PT0gZS5uYW1lXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLmdwdUFjY2VsZXJhdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICB2b2lkIDAgIT09IHAgJiYgY29uc29sZS53YXJuKCdXQVJOSU5HOiBgZ3B1QWNjZWxlcmF0aW9uYCBvcHRpb24gbW92ZWQgdG8gYGNvbXB1dGVTdHlsZWAgbW9kaWZpZXIgYW5kIHdpbGwgbm90IGJlIHN1cHBvcnRlZCBpbiBmdXR1cmUgdmVyc2lvbnMgb2YgUG9wcGVyLmpzIScpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzLCBkLCBhID0gdm9pZCAwID09PSBwID8gdC5ncHVBY2NlbGVyYXRpb24gOiBwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmID0gcihlLmluc3RhbmNlLnBvcHBlciksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGwgPSBnKGYpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IG4ucG9zaXRpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaCA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IFYobi5sZWZ0KSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogVihuLnRvcCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3R0b206IFYobi5ib3R0b20pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IFYobi5yaWdodClcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYyA9ICdib3R0b20nID09PSBvID8gJ3RvcCcgOiAnYm90dG9tJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdSA9ICdyaWdodCcgPT09IGkgPyAnbGVmdCcgOiAncmlnaHQnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBiID0gQigndHJhbnNmb3JtJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGQgPSAnYm90dG9tJyA9PSBjID8gLWwuaGVpZ2h0ICsgaC5ib3R0b20gOiBoLnRvcCwgcyA9ICdyaWdodCcgPT0gdSA/IC1sLndpZHRoICsgaC5yaWdodCA6IGgubGVmdCwgYSAmJiBiKSBtW2JdID0gJ3RyYW5zbGF0ZTNkKCcgKyBzICsgJ3B4LCAnICsgZCArICdweCwgMCknLCBtW2NdID0gMCwgbVt1XSA9IDAsIG0ud2lsbENoYW5nZSA9ICd0cmFuc2Zvcm0nO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeSA9ICdib3R0b20nID09IGMgPyAtMSA6IDEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3ID0gJ3JpZ2h0JyA9PSB1ID8gLTEgOiAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtW2NdID0gZCAqIHksIG1bdV0gPSBzICogdywgbS53aWxsQ2hhbmdlID0gYyArICcsICcgKyB1XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2ID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBcIngtcGxhY2VtZW50XCI6IGUucGxhY2VtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZS5hdHRyaWJ1dGVzID0gc2Uoe30sIHYsIGUuYXR0cmlidXRlcyksIGUuc3R5bGVzID0gc2Uoe30sIG0sIGUuc3R5bGVzKSwgZVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGdwdUFjY2VsZXJhdGlvbjogITAsXHJcbiAgICAgICAgICAgICAgICB4OiAnYm90dG9tJyxcclxuICAgICAgICAgICAgICAgIHk6ICdyaWdodCdcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgYXBwbHlTdHlsZToge1xyXG4gICAgICAgICAgICAgICAgb3JkZXI6IDkwMCxcclxuICAgICAgICAgICAgICAgIGVuYWJsZWQ6ICEwLFxyXG4gICAgICAgICAgICAgICAgZm46IGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVShlLmluc3RhbmNlLnBvcHBlciwgZS5zdHlsZXMpLCBZKGUuaW5zdGFuY2UucG9wcGVyLCBlLmF0dHJpYnV0ZXMpLCBlLm9mZnNldHMuYXJyb3cgJiYgVShlLmFycm93RWxlbWVudCwgZS5vZmZzZXRzLmFycm93KSwgZVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIG9uTG9hZDogZnVuY3Rpb24oZSwgdCwgbywgaSwgbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByID0geChuLCB0LCBlKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcCA9IEUoby5wbGFjZW1lbnQsIHIsIHQsIGUsIG8ubW9kaWZpZXJzLmZsaXAuYm91bmRhcmllc0VsZW1lbnQsIG8ubW9kaWZpZXJzLmZsaXAucGFkZGluZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHQuc2V0QXR0cmlidXRlKCd4LXBsYWNlbWVudCcsIHApLCBVKHQsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZSdcclxuICAgICAgICAgICAgICAgICAgICB9KSwgb1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGdwdUFjY2VsZXJhdGlvbjogdm9pZCAwXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LCBsZVxyXG59KTsiXSwiZmlsZSI6InBvcHBlci5taW4uanMifQ==
